
// Code generated by https://github.com/lyraproj/bridge DO NOT EDIT.

//
// This code is generated but is also a temporary measure
// Our hope is to replace this with a generally applicable dynamic approach
//

package generated

import (
	"github.com/lyraproj/lyra/cmd/goplugin-tf-aws/bridge"
	"github.com/lyraproj/puppet-evaluator/eval"
	"github.com/lyraproj/servicesdk/service"
	"github.com/hashicorp/terraform/helper/schema"
 	"github.com/hashicorp/terraform/terraform"
)

func convertMap(in map[string]interface{}) map[string]string {
	m  := map[string]string{}
	for k,v := range in {
		m[k] = v.(string)
	}
	return m
}


func unconvertMap(in map[string]string  ) map[string]interface{} {
	m  := map[string]interface{}{}
	for k,v := range in {
		m[k] = v
	}
	return m
}

func Initialize(sb *service.ServerBuilder, p *schema.Provider) {
    var evs []eval.Type
    evs = sb.RegisterTypes("AwsTerraform", Aws_codepipeline_webhook{})
    sb.RegisterHandler("AwsTerraform::Aws_codepipeline_webhookHandler", &Aws_codepipeline_webhookHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elastic_beanstalk_application_version{})
    sb.RegisterHandler("AwsTerraform::Aws_elastic_beanstalk_application_versionHandler", &Aws_elastic_beanstalk_application_versionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_apns_voip_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_apns_voip_channelHandler", &Aws_pinpoint_apns_voip_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dms_replication_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_dms_replication_instanceHandler", &Aws_dms_replication_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_hosted_private_virtual_interface{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_hosted_private_virtual_interfaceHandler", &Aws_dx_hosted_private_virtual_interfaceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_emr_security_configuration{})
    sb.RegisterHandler("AwsTerraform::Aws_emr_security_configurationHandler", &Aws_emr_security_configurationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iot_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_iot_policyHandler", &Aws_iot_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_integration_response{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_integration_responseHandler", &Aws_api_gateway_integration_responseHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_peering_connection_options{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_peering_connection_optionsHandler", &Aws_vpc_peering_connection_optionsHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_baidu_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_baidu_channelHandler", &Aws_pinpoint_baidu_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_account{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_accountHandler", &Aws_api_gateway_accountHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_datasync_task{})
    sb.RegisterHandler("AwsTerraform::Aws_datasync_taskHandler", &Aws_datasync_taskHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ec2_transit_gateway_route{})
    sb.RegisterHandler("AwsTerraform::Aws_ec2_transit_gateway_routeHandler", &Aws_ec2_transit_gateway_routeHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_role{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_roleHandler", &Aws_iam_roleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_php_app_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_php_app_layerHandler", &Aws_opsworks_php_app_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_receipt_rule_set{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_receipt_rule_setHandler", &Aws_ses_receipt_rule_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_s3_bucket_public_access_block{})
    sb.RegisterHandler("AwsTerraform::Aws_s3_bucket_public_access_blockHandler", &Aws_s3_bucket_public_access_blockHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sqs_queue_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_sqs_queue_policyHandler", &Aws_sqs_queue_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_peering_connection_accepter{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_peering_connection_accepterHandler", &Aws_vpc_peering_connection_accepterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_alb_listener{})
    sb.RegisterHandler("AwsTerraform::Aws_alb_listenerHandler", &Aws_alb_listenerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_bgp_peer{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_bgp_peerHandler", &Aws_dx_bgp_peerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_user_login_profile{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_user_login_profileHandler", &Aws_iam_user_login_profileHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_macie_s3_bucket_association{})
    sb.RegisterHandler("AwsTerraform::Aws_macie_s3_bucket_associationHandler", &Aws_macie_s3_bucket_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sns_sms_preferences{})
    sb.RegisterHandler("AwsTerraform::Aws_sns_sms_preferencesHandler", &Aws_sns_sms_preferencesHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_budgets_budget{})
    sb.RegisterHandler("AwsTerraform::Aws_budgets_budgetHandler", &Aws_budgets_budgetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cognito_user_pool_domain{})
    sb.RegisterHandler("AwsTerraform::Aws_cognito_user_pool_domainHandler", &Aws_cognito_user_pool_domainHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iot_certificate{})
    sb.RegisterHandler("AwsTerraform::Aws_iot_certificateHandler", &Aws_iot_certificateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_java_app_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_java_app_layerHandler", &Aws_opsworks_java_app_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_service_discovery_public_dns_namespace{})
    sb.RegisterHandler("AwsTerraform::Aws_service_discovery_public_dns_namespaceHandler", &Aws_service_discovery_public_dns_namespaceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_ipset{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_ipsetHandler", &Aws_wafregional_ipsetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dax_subnet_group{})
    sb.RegisterHandler("AwsTerraform::Aws_dax_subnet_groupHandler", &Aws_dax_subnet_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_efs_mount_target{})
    sb.RegisterHandler("AwsTerraform::Aws_efs_mount_targetHandler", &Aws_efs_mount_targetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_main_route_table_association{})
    sb.RegisterHandler("AwsTerraform::Aws_main_route_table_associationHandler", &Aws_main_route_table_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sagemaker_notebook_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_sagemaker_notebook_instanceHandler", &Aws_sagemaker_notebook_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_storagegateway_cache{})
    sb.RegisterHandler("AwsTerraform::Aws_storagegateway_cacheHandler", &Aws_storagegateway_cacheHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ami_launch_permission{})
    sb.RegisterHandler("AwsTerraform::Aws_ami_launch_permissionHandler", &Aws_ami_launch_permissionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appsync_api_key{})
    sb.RegisterHandler("AwsTerraform::Aws_appsync_api_keyHandler", &Aws_appsync_api_keyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cognito_identity_pool{})
    sb.RegisterHandler("AwsTerraform::Aws_cognito_identity_poolHandler", &Aws_cognito_identity_poolHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_neptune_event_subscription{})
    sb.RegisterHandler("AwsTerraform::Aws_neptune_event_subscriptionHandler", &Aws_neptune_event_subscriptionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_email_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_email_channelHandler", &Aws_pinpoint_email_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_emr_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_emr_clusterHandler", &Aws_emr_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_account_alias{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_account_aliasHandler", &Aws_iam_account_aliasHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_user_group_membership{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_user_group_membershipHandler", &Aws_iam_user_group_membershipHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_storagegateway_gateway{})
    sb.RegisterHandler("AwsTerraform::Aws_storagegateway_gatewayHandler", &Aws_storagegateway_gatewayHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_method_response{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_method_responseHandler", &Aws_api_gateway_method_responseHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_codebuild_project{})
    sb.RegisterHandler("AwsTerraform::Aws_codebuild_projectHandler", &Aws_codebuild_projectHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_private_virtual_interface{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_private_virtual_interfaceHandler", &Aws_dx_private_virtual_interfaceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ebs_volume{})
    sb.RegisterHandler("AwsTerraform::Aws_ebs_volumeHandler", &Aws_ebs_volumeHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_autoscaling_group{})
    sb.RegisterHandler("AwsTerraform::Aws_autoscaling_groupHandler", &Aws_autoscaling_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dynamodb_table_item{})
    sb.RegisterHandler("AwsTerraform::Aws_dynamodb_table_itemHandler", &Aws_dynamodb_table_itemHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_redshift_security_group{})
    sb.RegisterHandler("AwsTerraform::Aws_redshift_security_groupHandler", &Aws_redshift_security_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_apns_sandbox_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_apns_sandbox_channelHandler", &Aws_pinpoint_apns_sandbox_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_documentation_part{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_documentation_partHandler", &Aws_api_gateway_documentation_partHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_openid_connect_provider{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_openid_connect_providerHandler", &Aws_iam_openid_connect_providerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_redshift_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_redshift_clusterHandler", &Aws_redshift_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_template{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_templateHandler", &Aws_ses_templateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_alb_listener_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_alb_listener_ruleHandler", &Aws_alb_listener_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_log_group{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_log_groupHandler", &Aws_cloudwatch_log_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_codecommit_repository{})
    sb.RegisterHandler("AwsTerraform::Aws_codecommit_repositoryHandler", &Aws_codecommit_repositoryHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_domain_mail_from{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_domain_mail_fromHandler", &Aws_ses_domain_mail_fromHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_swf_domain{})
    sb.RegisterHandler("AwsTerraform::Aws_swf_domainHandler", &Aws_swf_domainHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpn_gateway_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_vpn_gateway_attachmentHandler", &Aws_vpn_gateway_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elasticsearch_domain{})
    sb.RegisterHandler("AwsTerraform::Aws_elasticsearch_domainHandler", &Aws_elasticsearch_domainHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lambda_event_source_mapping{})
    sb.RegisterHandler("AwsTerraform::Aws_lambda_event_source_mappingHandler", &Aws_lambda_event_source_mappingHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_proxy_protocol_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_proxy_protocol_policyHandler", &Aws_proxy_protocol_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cognito_user_pool_client{})
    sb.RegisterHandler("AwsTerraform::Aws_cognito_user_pool_clientHandler", &Aws_cognito_user_pool_clientHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_devicefarm_project{})
    sb.RegisterHandler("AwsTerraform::Aws_devicefarm_projectHandler", &Aws_devicefarm_projectHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_network_interface{})
    sb.RegisterHandler("AwsTerraform::Aws_network_interfaceHandler", &Aws_network_interfaceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_maintenance_window_target{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_maintenance_window_targetHandler", &Aws_ssm_maintenance_window_targetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_eks_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_eks_clusterHandler", &Aws_eks_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elastictranscoder_preset{})
    sb.RegisterHandler("AwsTerraform::Aws_elastictranscoder_presetHandler", &Aws_elastictranscoder_presetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_securityhub_product_subscription{})
    sb.RegisterHandler("AwsTerraform::Aws_securityhub_product_subscriptionHandler", &Aws_securityhub_product_subscriptionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dms_endpoint{})
    sb.RegisterHandler("AwsTerraform::Aws_dms_endpointHandler", &Aws_dms_endpointHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_flow_log{})
    sb.RegisterHandler("AwsTerraform::Aws_flow_logHandler", &Aws_flow_logHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_organizations_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_organizations_policyHandler", &Aws_organizations_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_authorizer{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_authorizerHandler", &Aws_api_gateway_authorizerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_method_settings{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_method_settingsHandler", &Aws_api_gateway_method_settingsHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_neptune_cluster_parameter_group{})
    sb.RegisterHandler("AwsTerraform::Aws_neptune_cluster_parameter_groupHandler", &Aws_neptune_cluster_parameter_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_eip{})
    sb.RegisterHandler("AwsTerraform::Aws_eipHandler", &Aws_eipHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ram_resource_share{})
    sb.RegisterHandler("AwsTerraform::Aws_ram_resource_shareHandler", &Aws_ram_resource_shareHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_receipt_filter{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_receipt_filterHandler", &Aws_ses_receipt_filterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpn_gateway{})
    sb.RegisterHandler("AwsTerraform::Aws_vpn_gatewayHandler", &Aws_vpn_gatewayHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_alb_listener_certificate{})
    sb.RegisterHandler("AwsTerraform::Aws_alb_listener_certificateHandler", &Aws_alb_listener_certificateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_client_certificate{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_client_certificateHandler", &Aws_api_gateway_client_certificateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_group_membership{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_group_membershipHandler", &Aws_iam_group_membershipHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_regex_pattern_set{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_regex_pattern_setHandler", &Aws_wafregional_regex_pattern_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_kms_alias{})
    sb.RegisterHandler("AwsTerraform::Aws_kms_aliasHandler", &Aws_kms_aliasHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_patch_group{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_patch_groupHandler", &Aws_ssm_patch_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_app_cookie_stickiness_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_app_cookie_stickiness_policyHandler", &Aws_app_cookie_stickiness_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloud9_environment_ec2{})
    sb.RegisterHandler("AwsTerraform::Aws_cloud9_environment_ec2Handler", &Aws_cloud9_environment_ec2Handler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dms_certificate{})
    sb.RegisterHandler("AwsTerraform::Aws_dms_certificateHandler", &Aws_dms_certificateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_sql_injection_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_sql_injection_match_setHandler", &Aws_wafregional_sql_injection_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_apns_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_apns_channelHandler", &Aws_pinpoint_apns_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_gcm_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_gcm_channelHandler", &Aws_pinpoint_gcm_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_method{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_methodHandler", &Aws_api_gateway_methodHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_connection{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_connectionHandler", &Aws_dx_connectionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_mq_broker{})
    sb.RegisterHandler("AwsTerraform::Aws_mq_brokerHandler", &Aws_mq_brokerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_spot_datafeed_subscription{})
    sb.RegisterHandler("AwsTerraform::Aws_spot_datafeed_subscriptionHandler", &Aws_spot_datafeed_subscriptionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dms_replication_task{})
    sb.RegisterHandler("AwsTerraform::Aws_dms_replication_taskHandler", &Aws_dms_replication_taskHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ec2_transit_gateway_route_table_association{})
    sb.RegisterHandler("AwsTerraform::Aws_ec2_transit_gateway_route_table_associationHandler", &Aws_ec2_transit_gateway_route_table_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_service_discovery_http_namespace{})
    sb.RegisterHandler("AwsTerraform::Aws_service_discovery_http_namespaceHandler", &Aws_service_discovery_http_namespaceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lb_listener_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_lb_listener_ruleHandler", &Aws_lb_listener_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_role_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_role_policyHandler", &Aws_iam_role_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_internet_gateway{})
    sb.RegisterHandler("AwsTerraform::Aws_internet_gatewayHandler", &Aws_internet_gatewayHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_haproxy_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_haproxy_layerHandler", &Aws_opsworks_haproxy_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_mysql_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_mysql_layerHandler", &Aws_opsworks_mysql_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_rds_cluster_endpoint{})
    sb.RegisterHandler("AwsTerraform::Aws_rds_cluster_endpointHandler", &Aws_rds_cluster_endpointHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sfn_activity{})
    sb.RegisterHandler("AwsTerraform::Aws_sfn_activityHandler", &Aws_sfn_activityHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_default_subnet{})
    sb.RegisterHandler("AwsTerraform::Aws_default_subnetHandler", &Aws_default_subnetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_guardduty_detector{})
    sb.RegisterHandler("AwsTerraform::Aws_guardduty_detectorHandler", &Aws_guardduty_detectorHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_load_balancer_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_load_balancer_policyHandler", &Aws_load_balancer_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_app{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_appHandler", &Aws_pinpoint_appHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elastic_beanstalk_configuration_template{})
    sb.RegisterHandler("AwsTerraform::Aws_elastic_beanstalk_configuration_templateHandler", &Aws_elastic_beanstalk_configuration_templateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_instance_profile{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_instance_profileHandler", &Aws_iam_instance_profileHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_service_discovery_private_dns_namespace{})
    sb.RegisterHandler("AwsTerraform::Aws_service_discovery_private_dns_namespaceHandler", &Aws_service_discovery_private_dns_namespaceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lb_target_group_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_lb_target_group_attachmentHandler", &Aws_lb_target_group_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lightsail_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_lightsail_instanceHandler", &Aws_lightsail_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lb_ssl_negotiation_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_lb_ssl_negotiation_policyHandler", &Aws_lb_ssl_negotiation_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_rds_global_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_rds_global_clusterHandler", &Aws_rds_global_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_deployment{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_deploymentHandler", &Aws_api_gateway_deploymentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_integration{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_integrationHandler", &Aws_api_gateway_integrationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_log_metric_filter{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_log_metric_filterHandler", &Aws_cloudwatch_log_metric_filterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_rds_cluster_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_rds_cluster_instanceHandler", &Aws_rds_cluster_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_ruleHandler", &Aws_waf_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_db_security_group{})
    sb.RegisterHandler("AwsTerraform::Aws_db_security_groupHandler", &Aws_db_security_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_hosted_public_virtual_interface{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_hosted_public_virtual_interfaceHandler", &Aws_dx_hosted_public_virtual_interfaceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_receipt_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_receipt_ruleHandler", &Aws_ses_receipt_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_configuration_set{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_configuration_setHandler", &Aws_ses_configuration_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ecr_lifecycle_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_ecr_lifecycle_policyHandler", &Aws_ecr_lifecycle_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lightsail_static_ip_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_lightsail_static_ip_attachmentHandler", &Aws_lightsail_static_ip_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_mq_configuration{})
    sb.RegisterHandler("AwsTerraform::Aws_mq_configurationHandler", &Aws_mq_configurationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_web_acl{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_web_aclHandler", &Aws_wafregional_web_aclHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_usage_plan_key{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_usage_plan_keyHandler", &Aws_api_gateway_usage_plan_keyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_codebuild_webhook{})
    sb.RegisterHandler("AwsTerraform::Aws_codebuild_webhookHandler", &Aws_codebuild_webhookHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_db_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_db_instanceHandler", &Aws_db_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_gateway{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_gatewayHandler", &Aws_dx_gatewayHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_security_group_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_security_group_ruleHandler", &Aws_security_group_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lb{})
    sb.RegisterHandler("AwsTerraform::Aws_lbHandler", &Aws_lbHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_efs_file_system{})
    sb.RegisterHandler("AwsTerraform::Aws_efs_file_systemHandler", &Aws_efs_file_systemHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_server_certificate{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_server_certificateHandler", &Aws_iam_server_certificateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_resource_data_sync{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_resource_data_syncHandler", &Aws_ssm_resource_data_syncHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_dhcp_options_association{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_dhcp_options_associationHandler", &Aws_vpc_dhcp_options_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_log_destination{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_log_destinationHandler", &Aws_cloudwatch_log_destinationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_globalaccelerator_accelerator{})
    sb.RegisterHandler("AwsTerraform::Aws_globalaccelerator_acceleratorHandler", &Aws_globalaccelerator_acceleratorHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_policyHandler", &Aws_iam_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_secretsmanager_secret_version{})
    sb.RegisterHandler("AwsTerraform::Aws_secretsmanager_secret_versionHandler", &Aws_secretsmanager_secret_versionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_route53_zone_association{})
    sb.RegisterHandler("AwsTerraform::Aws_route53_zone_associationHandler", &Aws_route53_zone_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_securityhub_account{})
    sb.RegisterHandler("AwsTerraform::Aws_securityhub_accountHandler", &Aws_securityhub_accountHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_ipset{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_ipsetHandler", &Aws_waf_ipsetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudfront_distribution{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudfront_distributionHandler", &Aws_cloudfront_distributionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_inspector_assessment_template{})
    sb.RegisterHandler("AwsTerraform::Aws_inspector_assessment_templateHandler", &Aws_inspector_assessment_templateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_load_balancer_listener_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_load_balancer_listener_policyHandler", &Aws_load_balancer_listener_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_peering_connection{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_peering_connectionHandler", &Aws_vpc_peering_connectionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_event_stream{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_event_streamHandler", &Aws_pinpoint_event_streamHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glue_connection{})
    sb.RegisterHandler("AwsTerraform::Aws_glue_connectionHandler", &Aws_glue_connectionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_guardduty_threatintelset{})
    sb.RegisterHandler("AwsTerraform::Aws_guardduty_threatintelsetHandler", &Aws_guardduty_threatintelsetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_storagegateway_nfs_file_share{})
    sb.RegisterHandler("AwsTerraform::Aws_storagegateway_nfs_file_shareHandler", &Aws_storagegateway_nfs_file_shareHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_rate_based_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_rate_based_ruleHandler", &Aws_waf_rate_based_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cognito_identity_provider{})
    sb.RegisterHandler("AwsTerraform::Aws_cognito_identity_providerHandler", &Aws_cognito_identity_providerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cognito_resource_server{})
    sb.RegisterHandler("AwsTerraform::Aws_cognito_resource_serverHandler", &Aws_cognito_resource_serverHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elasticache_replication_group{})
    sb.RegisterHandler("AwsTerraform::Aws_elasticache_replication_groupHandler", &Aws_elasticache_replication_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sns_topic_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_sns_topic_policyHandler", &Aws_sns_topic_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_batch_job_queue{})
    sb.RegisterHandler("AwsTerraform::Aws_batch_job_queueHandler", &Aws_batch_job_queueHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_log_stream{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_log_streamHandler", &Aws_cloudwatch_log_streamHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_config_configuration_recorder_status{})
    sb.RegisterHandler("AwsTerraform::Aws_config_configuration_recorder_statusHandler", &Aws_config_configuration_recorder_statusHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_guardduty_member{})
    sb.RegisterHandler("AwsTerraform::Aws_guardduty_memberHandler", &Aws_guardduty_memberHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_saml_provider{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_saml_providerHandler", &Aws_iam_saml_providerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_storagegateway_upload_buffer{})
    sb.RegisterHandler("AwsTerraform::Aws_storagegateway_upload_bufferHandler", &Aws_storagegateway_upload_bufferHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_rule_group{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_rule_groupHandler", &Aws_waf_rule_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dax_parameter_group{})
    sb.RegisterHandler("AwsTerraform::Aws_dax_parameter_groupHandler", &Aws_dax_parameter_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_kinesis_firehose_delivery_stream{})
    sb.RegisterHandler("AwsTerraform::Aws_kinesis_firehose_delivery_streamHandler", &Aws_kinesis_firehose_delivery_streamHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_stack{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_stackHandler", &Aws_opsworks_stackHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_byte_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_byte_match_setHandler", &Aws_wafregional_byte_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appmesh_mesh{})
    sb.RegisterHandler("AwsTerraform::Aws_appmesh_meshHandler", &Aws_appmesh_meshHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ec2_transit_gateway_vpc_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_ec2_transit_gateway_vpc_attachmentHandler", &Aws_ec2_transit_gateway_vpc_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sqs_queue{})
    sb.RegisterHandler("AwsTerraform::Aws_sqs_queueHandler", &Aws_sqs_queueHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_config_configuration_aggregator{})
    sb.RegisterHandler("AwsTerraform::Aws_config_configuration_aggregatorHandler", &Aws_config_configuration_aggregatorHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elasticache_security_group{})
    sb.RegisterHandler("AwsTerraform::Aws_elasticache_security_groupHandler", &Aws_elasticache_security_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_ganglia_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_ganglia_layerHandler", &Aws_opsworks_ganglia_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_batch_job_definition{})
    sb.RegisterHandler("AwsTerraform::Aws_batch_job_definitionHandler", &Aws_batch_job_definitionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_autoscaling_notification{})
    sb.RegisterHandler("AwsTerraform::Aws_autoscaling_notificationHandler", &Aws_autoscaling_notificationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glue_job{})
    sb.RegisterHandler("AwsTerraform::Aws_glue_jobHandler", &Aws_glue_jobHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_network_interface_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_network_interface_attachmentHandler", &Aws_network_interface_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_transfer_user{})
    sb.RegisterHandler("AwsTerraform::Aws_transfer_userHandler", &Aws_transfer_userHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ebs_snapshot{})
    sb.RegisterHandler("AwsTerraform::Aws_ebs_snapshotHandler", &Aws_ebs_snapshotHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_access_key{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_access_keyHandler", &Aws_iam_access_keyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iot_topic_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_iot_topic_ruleHandler", &Aws_iot_topic_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_web_acl_association{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_web_acl_associationHandler", &Aws_wafregional_web_acl_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_adm_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_adm_channelHandler", &Aws_pinpoint_adm_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elasticache_parameter_group{})
    sb.RegisterHandler("AwsTerraform::Aws_elasticache_parameter_groupHandler", &Aws_elasticache_parameter_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_launch_template{})
    sb.RegisterHandler("AwsTerraform::Aws_launch_templateHandler", &Aws_launch_templateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lightsail_static_ip{})
    sb.RegisterHandler("AwsTerraform::Aws_lightsail_static_ipHandler", &Aws_lightsail_static_ipHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_media_store_container_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_media_store_container_policyHandler", &Aws_media_store_container_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_route53_delegation_set{})
    sb.RegisterHandler("AwsTerraform::Aws_route53_delegation_setHandler", &Aws_route53_delegation_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_api_key{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_api_keyHandler", &Aws_api_gateway_api_keyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_user_profile{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_user_profileHandler", &Aws_opsworks_user_profileHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_storagegateway_cached_iscsi_volume{})
    sb.RegisterHandler("AwsTerraform::Aws_storagegateway_cached_iscsi_volumeHandler", &Aws_storagegateway_cached_iscsi_volumeHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_subnet{})
    sb.RegisterHandler("AwsTerraform::Aws_subnetHandler", &Aws_subnetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc{})
    sb.RegisterHandler("AwsTerraform::Aws_vpcHandler", &Aws_vpcHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_event_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_event_ruleHandler", &Aws_cloudwatch_event_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_s3_bucket_object{})
    sb.RegisterHandler("AwsTerraform::Aws_s3_bucket_objectHandler", &Aws_s3_bucket_objectHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_activation{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_activationHandler", &Aws_ssm_activationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_xss_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_xss_match_setHandler", &Aws_wafregional_xss_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_autoscaling_lifecycle_hook{})
    sb.RegisterHandler("AwsTerraform::Aws_autoscaling_lifecycle_hookHandler", &Aws_autoscaling_lifecycle_hookHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_user_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_user_policyHandler", &Aws_iam_user_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_kms_key{})
    sb.RegisterHandler("AwsTerraform::Aws_kms_keyHandler", &Aws_kms_keyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_simpledb_domain{})
    sb.RegisterHandler("AwsTerraform::Aws_simpledb_domainHandler", &Aws_simpledb_domainHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_vpc_link{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_vpc_linkHandler", &Aws_api_gateway_vpc_linkHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_datasync_location_nfs{})
    sb.RegisterHandler("AwsTerraform::Aws_datasync_location_nfsHandler", &Aws_datasync_location_nfsHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_service_linked_role{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_service_linked_roleHandler", &Aws_iam_service_linked_roleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_storagegateway_working_storage{})
    sb.RegisterHandler("AwsTerraform::Aws_storagegateway_working_storageHandler", &Aws_storagegateway_working_storageHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ami_from_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_ami_from_instanceHandler", &Aws_ami_from_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_group_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_group_policyHandler", &Aws_iam_group_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_nodejs_app_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_nodejs_app_layerHandler", &Aws_opsworks_nodejs_app_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_spot_instance_request{})
    sb.RegisterHandler("AwsTerraform::Aws_spot_instance_requestHandler", &Aws_spot_instance_requestHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appsync_datasource{})
    sb.RegisterHandler("AwsTerraform::Aws_appsync_datasourceHandler", &Aws_appsync_datasourceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_codedeploy_deployment_config{})
    sb.RegisterHandler("AwsTerraform::Aws_codedeploy_deployment_configHandler", &Aws_codedeploy_deployment_configHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_user_policy_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_user_policy_attachmentHandler", &Aws_iam_user_policy_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_rds_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_rds_clusterHandler", &Aws_rds_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_hosted_public_virtual_interface_accepter{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_hosted_public_virtual_interface_accepterHandler", &Aws_dx_hosted_public_virtual_interface_accepterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elastictranscoder_pipeline{})
    sb.RegisterHandler("AwsTerraform::Aws_elastictranscoder_pipelineHandler", &Aws_elastictranscoder_pipelineHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glacier_vault{})
    sb.RegisterHandler("AwsTerraform::Aws_glacier_vaultHandler", &Aws_glacier_vaultHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_s3_bucket_inventory{})
    sb.RegisterHandler("AwsTerraform::Aws_s3_bucket_inventoryHandler", &Aws_s3_bucket_inventoryHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dynamodb_global_table{})
    sb.RegisterHandler("AwsTerraform::Aws_dynamodb_global_tableHandler", &Aws_dynamodb_global_tableHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iot_policy_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_iot_policy_attachmentHandler", &Aws_iot_policy_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sns_topic{})
    sb.RegisterHandler("AwsTerraform::Aws_sns_topicHandler", &Aws_sns_topicHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_ipv4_cidr_block_association{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_ipv4_cidr_block_associationHandler", &Aws_vpc_ipv4_cidr_block_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_web_acl{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_web_aclHandler", &Aws_waf_web_aclHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_instanceHandler", &Aws_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_application{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_applicationHandler", &Aws_opsworks_applicationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_log_subscription_filter{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_log_subscription_filterHandler", &Aws_cloudwatch_log_subscription_filterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_db_option_group{})
    sb.RegisterHandler("AwsTerraform::Aws_db_option_groupHandler", &Aws_db_option_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_directory_service_conditional_forwarder{})
    sb.RegisterHandler("AwsTerraform::Aws_directory_service_conditional_forwarderHandler", &Aws_directory_service_conditional_forwarderHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ec2_transit_gateway_route_table_propagation{})
    sb.RegisterHandler("AwsTerraform::Aws_ec2_transit_gateway_route_table_propagationHandler", &Aws_ec2_transit_gateway_route_table_propagationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_gamelift_build{})
    sb.RegisterHandler("AwsTerraform::Aws_gamelift_buildHandler", &Aws_gamelift_buildHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_network_interface_sg_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_network_interface_sg_attachmentHandler", &Aws_network_interface_sg_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_endpoint_service_allowed_principal{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_endpoint_service_allowed_principalHandler", &Aws_vpc_endpoint_service_allowed_principalHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_geo_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_geo_match_setHandler", &Aws_wafregional_geo_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_base_path_mapping{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_base_path_mappingHandler", &Aws_api_gateway_base_path_mappingHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_model{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_modelHandler", &Aws_api_gateway_modelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_organizations_organization{})
    sb.RegisterHandler("AwsTerraform::Aws_organizations_organizationHandler", &Aws_organizations_organizationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_resourcegroups_group{})
    sb.RegisterHandler("AwsTerraform::Aws_resourcegroups_groupHandler", &Aws_resourcegroups_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_gamelift_fleet{})
    sb.RegisterHandler("AwsTerraform::Aws_gamelift_fleetHandler", &Aws_gamelift_fleetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appmesh_virtual_router{})
    sb.RegisterHandler("AwsTerraform::Aws_appmesh_virtual_routerHandler", &Aws_appmesh_virtual_routerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_key_pair{})
    sb.RegisterHandler("AwsTerraform::Aws_key_pairHandler", &Aws_key_pairHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_redshift_snapshot_copy_grant{})
    sb.RegisterHandler("AwsTerraform::Aws_redshift_snapshot_copy_grantHandler", &Aws_redshift_snapshot_copy_grantHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_servicecatalog_portfolio{})
    sb.RegisterHandler("AwsTerraform::Aws_servicecatalog_portfolioHandler", &Aws_servicecatalog_portfolioHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_dhcp_options{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_dhcp_optionsHandler", &Aws_vpc_dhcp_optionsHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cognito_identity_pool_roles_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_cognito_identity_pool_roles_attachmentHandler", &Aws_cognito_identity_pool_roles_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_db_parameter_group{})
    sb.RegisterHandler("AwsTerraform::Aws_db_parameter_groupHandler", &Aws_db_parameter_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glue_catalog_table{})
    sb.RegisterHandler("AwsTerraform::Aws_glue_catalog_tableHandler", &Aws_glue_catalog_tableHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glue_classifier{})
    sb.RegisterHandler("AwsTerraform::Aws_glue_classifierHandler", &Aws_glue_classifierHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ec2_capacity_reservation{})
    sb.RegisterHandler("AwsTerraform::Aws_ec2_capacity_reservationHandler", &Aws_ec2_capacity_reservationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_rds_cluster_parameter_group{})
    sb.RegisterHandler("AwsTerraform::Aws_rds_cluster_parameter_groupHandler", &Aws_rds_cluster_parameter_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_redshift_subnet_group{})
    sb.RegisterHandler("AwsTerraform::Aws_redshift_subnet_groupHandler", &Aws_redshift_subnet_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elastic_beanstalk_application{})
    sb.RegisterHandler("AwsTerraform::Aws_elastic_beanstalk_applicationHandler", &Aws_elastic_beanstalk_applicationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_s3_bucket_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_s3_bucket_policyHandler", &Aws_s3_bucket_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lb_listener{})
    sb.RegisterHandler("AwsTerraform::Aws_lb_listenerHandler", &Aws_lb_listenerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudfront_public_key{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudfront_public_keyHandler", &Aws_cloudfront_public_keyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_user{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_userHandler", &Aws_iam_userHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_secretsmanager_secret{})
    sb.RegisterHandler("AwsTerraform::Aws_secretsmanager_secretHandler", &Aws_secretsmanager_secretHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_alb{})
    sb.RegisterHandler("AwsTerraform::Aws_albHandler", &Aws_albHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_volume_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_volume_attachmentHandler", &Aws_volume_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ebs_snapshot_copy{})
    sb.RegisterHandler("AwsTerraform::Aws_ebs_snapshot_copyHandler", &Aws_ebs_snapshot_copyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_s3_bucket_metric{})
    sb.RegisterHandler("AwsTerraform::Aws_s3_bucket_metricHandler", &Aws_s3_bucket_metricHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_size_constraint_set{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_size_constraint_setHandler", &Aws_waf_size_constraint_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_metric_alarm{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_metric_alarmHandler", &Aws_cloudwatch_metric_alarmHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dynamodb_table{})
    sb.RegisterHandler("AwsTerraform::Aws_dynamodb_tableHandler", &Aws_dynamodb_tableHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_rds_db_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_rds_db_instanceHandler", &Aws_opsworks_rds_db_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_document{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_documentHandler", &Aws_ssm_documentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_endpoint_service{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_endpoint_serviceHandler", &Aws_vpc_endpoint_serviceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_usage_plan{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_usage_planHandler", &Aws_api_gateway_usage_planHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_autoscaling_schedule{})
    sb.RegisterHandler("AwsTerraform::Aws_autoscaling_scheduleHandler", &Aws_autoscaling_scheduleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ecs_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_ecs_clusterHandler", &Aws_ecs_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sfn_state_machine{})
    sb.RegisterHandler("AwsTerraform::Aws_sfn_state_machineHandler", &Aws_sfn_state_machineHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_rate_based_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_rate_based_ruleHandler", &Aws_wafregional_rate_based_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_lag{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_lagHandler", &Aws_dx_lagHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_route53_health_check{})
    sb.RegisterHandler("AwsTerraform::Aws_route53_health_checkHandler", &Aws_route53_health_checkHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_maintenance_window{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_maintenance_windowHandler", &Aws_ssm_maintenance_windowHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elasticache_subnet_group{})
    sb.RegisterHandler("AwsTerraform::Aws_elasticache_subnet_groupHandler", &Aws_elasticache_subnet_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_licensemanager_association{})
    sb.RegisterHandler("AwsTerraform::Aws_licensemanager_associationHandler", &Aws_licensemanager_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_nat_gateway{})
    sb.RegisterHandler("AwsTerraform::Aws_nat_gatewayHandler", &Aws_nat_gatewayHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_neptune_parameter_group{})
    sb.RegisterHandler("AwsTerraform::Aws_neptune_parameter_groupHandler", &Aws_neptune_parameter_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_custom_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_custom_layerHandler", &Aws_opsworks_custom_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_datasync_location_efs{})
    sb.RegisterHandler("AwsTerraform::Aws_datasync_location_efsHandler", &Aws_datasync_location_efsHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpn_connection{})
    sb.RegisterHandler("AwsTerraform::Aws_vpn_connectionHandler", &Aws_vpn_connectionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ami_copy{})
    sb.RegisterHandler("AwsTerraform::Aws_ami_copyHandler", &Aws_ami_copyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_docdb_cluster_parameter_group{})
    sb.RegisterHandler("AwsTerraform::Aws_docdb_cluster_parameter_groupHandler", &Aws_docdb_cluster_parameter_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elasticsearch_domain_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_elasticsearch_domain_policyHandler", &Aws_elasticsearch_domain_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_static_web_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_static_web_layerHandler", &Aws_opsworks_static_web_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appmesh_virtual_node{})
    sb.RegisterHandler("AwsTerraform::Aws_appmesh_virtual_nodeHandler", &Aws_appmesh_virtual_nodeHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cognito_user_group{})
    sb.RegisterHandler("AwsTerraform::Aws_cognito_user_groupHandler", &Aws_cognito_user_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_datasync_agent{})
    sb.RegisterHandler("AwsTerraform::Aws_datasync_agentHandler", &Aws_datasync_agentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ami{})
    sb.RegisterHandler("AwsTerraform::Aws_amiHandler", &Aws_amiHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elastic_beanstalk_environment{})
    sb.RegisterHandler("AwsTerraform::Aws_elastic_beanstalk_environmentHandler", &Aws_elastic_beanstalk_environmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_default_route_table{})
    sb.RegisterHandler("AwsTerraform::Aws_default_route_tableHandler", &Aws_default_route_tableHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_parameter{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_parameterHandler", &Aws_ssm_parameterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_gateway_response{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_gateway_responseHandler", &Aws_api_gateway_gateway_responseHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_db_snapshot{})
    sb.RegisterHandler("AwsTerraform::Aws_db_snapshotHandler", &Aws_db_snapshotHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_account_password_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_account_password_policyHandler", &Aws_iam_account_password_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_inspector_resource_group{})
    sb.RegisterHandler("AwsTerraform::Aws_inspector_resource_groupHandler", &Aws_inspector_resource_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_service_discovery_service{})
    sb.RegisterHandler("AwsTerraform::Aws_service_discovery_serviceHandler", &Aws_service_discovery_serviceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_db_cluster_snapshot{})
    sb.RegisterHandler("AwsTerraform::Aws_db_cluster_snapshotHandler", &Aws_db_cluster_snapshotHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ec2_fleet{})
    sb.RegisterHandler("AwsTerraform::Aws_ec2_fleetHandler", &Aws_ec2_fleetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_transfer_server{})
    sb.RegisterHandler("AwsTerraform::Aws_transfer_serverHandler", &Aws_transfer_serverHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_rule_group{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_rule_groupHandler", &Aws_wafregional_rule_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_codedeploy_app{})
    sb.RegisterHandler("AwsTerraform::Aws_codedeploy_appHandler", &Aws_codedeploy_appHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glue_trigger{})
    sb.RegisterHandler("AwsTerraform::Aws_glue_triggerHandler", &Aws_glue_triggerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_redshift_event_subscription{})
    sb.RegisterHandler("AwsTerraform::Aws_redshift_event_subscriptionHandler", &Aws_redshift_event_subscriptionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_event_destination{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_event_destinationHandler", &Aws_ses_event_destinationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_config_config_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_config_config_ruleHandler", &Aws_config_config_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_policy_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_policy_attachmentHandler", &Aws_iam_policy_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sns_topic_subscription{})
    sb.RegisterHandler("AwsTerraform::Aws_sns_topic_subscriptionHandler", &Aws_sns_topic_subscriptionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_domain_name{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_domain_nameHandler", &Aws_api_gateway_domain_nameHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ec2_transit_gateway{})
    sb.RegisterHandler("AwsTerraform::Aws_ec2_transit_gatewayHandler", &Aws_ec2_transit_gatewayHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glue_catalog_database{})
    sb.RegisterHandler("AwsTerraform::Aws_glue_catalog_databaseHandler", &Aws_glue_catalog_databaseHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_neptune_subnet_group{})
    sb.RegisterHandler("AwsTerraform::Aws_neptune_subnet_groupHandler", &Aws_neptune_subnet_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_route_table_association{})
    sb.RegisterHandler("AwsTerraform::Aws_route_table_associationHandler", &Aws_route_table_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_s3_bucket{})
    sb.RegisterHandler("AwsTerraform::Aws_s3_bucketHandler", &Aws_s3_bucketHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_route53_query_log{})
    sb.RegisterHandler("AwsTerraform::Aws_route53_query_logHandler", &Aws_route53_query_logHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_domain_dkim{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_domain_dkimHandler", &Aws_ses_domain_dkimHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_patch_baseline{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_patch_baselineHandler", &Aws_ssm_patch_baselineHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_egress_only_internet_gateway{})
    sb.RegisterHandler("AwsTerraform::Aws_egress_only_internet_gatewayHandler", &Aws_egress_only_internet_gatewayHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_eip_association{})
    sb.RegisterHandler("AwsTerraform::Aws_eip_associationHandler", &Aws_eip_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_request_validator{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_request_validatorHandler", &Aws_api_gateway_request_validatorHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_load_balancer_backend_server_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_load_balancer_backend_server_policyHandler", &Aws_load_balancer_backend_server_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_neptune_cluster_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_neptune_cluster_instanceHandler", &Aws_neptune_cluster_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_alb_target_group_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_alb_target_group_attachmentHandler", &Aws_alb_target_group_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_user_ssh_key{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_user_ssh_keyHandler", &Aws_iam_user_ssh_keyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_snapshot_create_volume_permission{})
    sb.RegisterHandler("AwsTerraform::Aws_snapshot_create_volume_permissionHandler", &Aws_snapshot_create_volume_permissionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_endpoint_subnet_association{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_endpoint_subnet_associationHandler", &Aws_vpc_endpoint_subnet_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_geo_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_geo_match_setHandler", &Aws_waf_geo_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_alb_target_group{})
    sb.RegisterHandler("AwsTerraform::Aws_alb_target_groupHandler", &Aws_alb_target_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_db_event_subscription{})
    sb.RegisterHandler("AwsTerraform::Aws_db_event_subscriptionHandler", &Aws_db_event_subscriptionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_gamelift_alias{})
    sb.RegisterHandler("AwsTerraform::Aws_gamelift_aliasHandler", &Aws_gamelift_aliasHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lightsail_domain{})
    sb.RegisterHandler("AwsTerraform::Aws_lightsail_domainHandler", &Aws_lightsail_domainHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_placement_group{})
    sb.RegisterHandler("AwsTerraform::Aws_placement_groupHandler", &Aws_placement_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_default_vpc{})
    sb.RegisterHandler("AwsTerraform::Aws_default_vpcHandler", &Aws_default_vpcHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_size_constraint_set{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_size_constraint_setHandler", &Aws_wafregional_size_constraint_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_domain_identity_verification{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_domain_identity_verificationHandler", &Aws_ses_domain_identity_verificationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_log_destination_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_log_destination_policyHandler", &Aws_cloudwatch_log_destination_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_emr_instance_group{})
    sb.RegisterHandler("AwsTerraform::Aws_emr_instance_groupHandler", &Aws_emr_instance_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glacier_vault_lock{})
    sb.RegisterHandler("AwsTerraform::Aws_glacier_vault_lockHandler", &Aws_glacier_vault_lockHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_sns_platform_application{})
    sb.RegisterHandler("AwsTerraform::Aws_sns_platform_applicationHandler", &Aws_sns_platform_applicationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_customer_gateway{})
    sb.RegisterHandler("AwsTerraform::Aws_customer_gatewayHandler", &Aws_customer_gatewayHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_organizations_account{})
    sb.RegisterHandler("AwsTerraform::Aws_organizations_accountHandler", &Aws_organizations_accountHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_regex_pattern_set{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_regex_pattern_setHandler", &Aws_waf_regex_pattern_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_db_subnet_group{})
    sb.RegisterHandler("AwsTerraform::Aws_db_subnet_groupHandler", &Aws_db_subnet_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_inspector_assessment_target{})
    sb.RegisterHandler("AwsTerraform::Aws_inspector_assessment_targetHandler", &Aws_inspector_assessment_targetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_acmpca_certificate_authority{})
    sb.RegisterHandler("AwsTerraform::Aws_acmpca_certificate_authorityHandler", &Aws_acmpca_certificate_authorityHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lambda_alias{})
    sb.RegisterHandler("AwsTerraform::Aws_lambda_aliasHandler", &Aws_lambda_aliasHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lambda_permission{})
    sb.RegisterHandler("AwsTerraform::Aws_lambda_permissionHandler", &Aws_lambda_permissionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appautoscaling_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_appautoscaling_policyHandler", &Aws_appautoscaling_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_organizations_policy_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_organizations_policy_attachmentHandler", &Aws_organizations_policy_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_endpoint_route_table_association{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_endpoint_route_table_associationHandler", &Aws_vpc_endpoint_route_table_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appmesh_route{})
    sb.RegisterHandler("AwsTerraform::Aws_appmesh_routeHandler", &Aws_appmesh_routeHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_kinesis_analytics_application{})
    sb.RegisterHandler("AwsTerraform::Aws_kinesis_analytics_applicationHandler", &Aws_kinesis_analytics_applicationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_config_configuration_recorder{})
    sb.RegisterHandler("AwsTerraform::Aws_config_configuration_recorderHandler", &Aws_config_configuration_recorderHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_directory_service_directory{})
    sb.RegisterHandler("AwsTerraform::Aws_directory_service_directoryHandler", &Aws_directory_service_directoryHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_kinesis_stream{})
    sb.RegisterHandler("AwsTerraform::Aws_kinesis_streamHandler", &Aws_kinesis_streamHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dax_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_dax_clusterHandler", &Aws_dax_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elasticache_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_elasticache_clusterHandler", &Aws_elasticache_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_media_package_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_media_package_channelHandler", &Aws_media_package_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_active_receipt_rule_set{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_active_receipt_rule_setHandler", &Aws_ses_active_receipt_rule_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appsync_graphql_api{})
    sb.RegisterHandler("AwsTerraform::Aws_appsync_graphql_apiHandler", &Aws_appsync_graphql_apiHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_autoscaling_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_autoscaling_attachmentHandler", &Aws_autoscaling_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_autoscaling_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_autoscaling_policyHandler", &Aws_autoscaling_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ecs_service{})
    sb.RegisterHandler("AwsTerraform::Aws_ecs_serviceHandler", &Aws_ecs_serviceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elb_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_elb_attachmentHandler", &Aws_elb_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_redshift_parameter_group{})
    sb.RegisterHandler("AwsTerraform::Aws_redshift_parameter_groupHandler", &Aws_redshift_parameter_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_storagegateway_smb_file_share{})
    sb.RegisterHandler("AwsTerraform::Aws_storagegateway_smb_file_shareHandler", &Aws_storagegateway_smb_file_shareHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_codedeploy_deployment_group{})
    sb.RegisterHandler("AwsTerraform::Aws_codedeploy_deployment_groupHandler", &Aws_codedeploy_deployment_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ecr_repository_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_ecr_repository_policyHandler", &Aws_ecr_repository_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_group{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_groupHandler", &Aws_iam_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_default_network_acl{})
    sb.RegisterHandler("AwsTerraform::Aws_default_network_aclHandler", &Aws_default_network_aclHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_neptune_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_neptune_clusterHandler", &Aws_neptune_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_securityhub_standards_subscription{})
    sb.RegisterHandler("AwsTerraform::Aws_securityhub_standards_subscriptionHandler", &Aws_securityhub_standards_subscriptionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_stage{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_stageHandler", &Aws_api_gateway_stageHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_event_target{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_event_targetHandler", &Aws_cloudwatch_event_targetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_route{})
    sb.RegisterHandler("AwsTerraform::Aws_routeHandler", &Aws_routeHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_association{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_associationHandler", &Aws_ssm_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_memcached_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_memcached_layerHandler", &Aws_opsworks_memcached_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_codecommit_trigger{})
    sb.RegisterHandler("AwsTerraform::Aws_codecommit_triggerHandler", &Aws_codecommit_triggerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dlm_lifecycle_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_dlm_lifecycle_policyHandler", &Aws_dlm_lifecycle_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_kms_grant{})
    sb.RegisterHandler("AwsTerraform::Aws_kms_grantHandler", &Aws_kms_grantHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_event_permission{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_event_permissionHandler", &Aws_cloudwatch_event_permissionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_acm_certificate{})
    sb.RegisterHandler("AwsTerraform::Aws_acm_certificateHandler", &Aws_acm_certificateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ecs_task_definition{})
    sb.RegisterHandler("AwsTerraform::Aws_ecs_task_definitionHandler", &Aws_ecs_task_definitionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glue_crawler{})
    sb.RegisterHandler("AwsTerraform::Aws_glue_crawlerHandler", &Aws_glue_crawlerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_batch_compute_environment{})
    sb.RegisterHandler("AwsTerraform::Aws_batch_compute_environmentHandler", &Aws_batch_compute_environmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudformation_stack{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudformation_stackHandler", &Aws_cloudformation_stackHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lambda_function{})
    sb.RegisterHandler("AwsTerraform::Aws_lambda_functionHandler", &Aws_lambda_functionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_regex_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_regex_match_setHandler", &Aws_wafregional_regex_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_athena_named_query{})
    sb.RegisterHandler("AwsTerraform::Aws_athena_named_queryHandler", &Aws_athena_named_queryHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_group_policy_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_group_policy_attachmentHandler", &Aws_iam_group_policy_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_sms_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_sms_channelHandler", &Aws_pinpoint_sms_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_documentation_version{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_documentation_versionHandler", &Aws_api_gateway_documentation_versionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cognito_user_pool{})
    sb.RegisterHandler("AwsTerraform::Aws_cognito_user_poolHandler", &Aws_cognito_user_poolHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_docdb_subnet_group{})
    sb.RegisterHandler("AwsTerraform::Aws_docdb_subnet_groupHandler", &Aws_docdb_subnet_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iot_thing{})
    sb.RegisterHandler("AwsTerraform::Aws_iot_thingHandler", &Aws_iot_thingHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_default_security_group{})
    sb.RegisterHandler("AwsTerraform::Aws_default_security_groupHandler", &Aws_default_security_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_sql_injection_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_sql_injection_match_setHandler", &Aws_waf_sql_injection_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appautoscaling_scheduled_action{})
    sb.RegisterHandler("AwsTerraform::Aws_appautoscaling_scheduled_actionHandler", &Aws_appautoscaling_scheduled_actionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lb_target_group{})
    sb.RegisterHandler("AwsTerraform::Aws_lb_target_groupHandler", &Aws_lb_target_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudtrail{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudtrailHandler", &Aws_cloudtrailHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_gamelift_game_session_queue{})
    sb.RegisterHandler("AwsTerraform::Aws_gamelift_game_session_queueHandler", &Aws_gamelift_game_session_queueHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lambda_layer_version{})
    sb.RegisterHandler("AwsTerraform::Aws_lambda_layer_versionHandler", &Aws_lambda_layer_versionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_media_store_container{})
    sb.RegisterHandler("AwsTerraform::Aws_media_store_containerHandler", &Aws_media_store_containerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_rest_api{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_rest_apiHandler", &Aws_api_gateway_rest_apiHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iot_thing_principal_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_iot_thing_principal_attachmentHandler", &Aws_iot_thing_principal_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lb_cookie_stickiness_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_lb_cookie_stickiness_policyHandler", &Aws_lb_cookie_stickiness_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudhsm_v2_cluster{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudhsm_v2_clusterHandler", &Aws_cloudhsm_v2_clusterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_codepipeline{})
    sb.RegisterHandler("AwsTerraform::Aws_codepipelineHandler", &Aws_codepipelineHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ecr_repository{})
    sb.RegisterHandler("AwsTerraform::Aws_ecr_repositoryHandler", &Aws_ecr_repositoryHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_route53_record{})
    sb.RegisterHandler("AwsTerraform::Aws_route53_recordHandler", &Aws_route53_recordHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_route53_zone{})
    sb.RegisterHandler("AwsTerraform::Aws_route53_zoneHandler", &Aws_route53_zoneHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_endpoint{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_endpointHandler", &Aws_vpc_endpointHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpn_connection_route{})
    sb.RegisterHandler("AwsTerraform::Aws_vpn_connection_routeHandler", &Aws_vpn_connection_routeHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpn_gateway_route_propagation{})
    sb.RegisterHandler("AwsTerraform::Aws_vpn_gateway_route_propagationHandler", &Aws_vpn_gateway_route_propagationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_pinpoint_apns_voip_sandbox_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_pinpoint_apns_voip_sandbox_channelHandler", &Aws_pinpoint_apns_voip_sandbox_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_dashboard{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_dashboardHandler", &Aws_cloudwatch_dashboardHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_datasync_location_s3{})
    sb.RegisterHandler("AwsTerraform::Aws_datasync_location_s3Handler", &Aws_datasync_location_s3Handler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dms_replication_subnet_group{})
    sb.RegisterHandler("AwsTerraform::Aws_dms_replication_subnet_groupHandler", &Aws_dms_replication_subnet_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ec2_transit_gateway_route_table{})
    sb.RegisterHandler("AwsTerraform::Aws_ec2_transit_gateway_route_tableHandler", &Aws_ec2_transit_gateway_route_tableHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_identity_notification_topic{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_identity_notification_topicHandler", &Aws_ses_identity_notification_topicHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_connection_association{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_connection_associationHandler", &Aws_dx_connection_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_network_acl{})
    sb.RegisterHandler("AwsTerraform::Aws_network_aclHandler", &Aws_network_aclHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_neptune_cluster_snapshot{})
    sb.RegisterHandler("AwsTerraform::Aws_neptune_cluster_snapshotHandler", &Aws_neptune_cluster_snapshotHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_xss_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_xss_match_setHandler", &Aws_waf_xss_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_hosted_private_virtual_interface_accepter{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_hosted_private_virtual_interface_accepterHandler", &Aws_dx_hosted_private_virtual_interface_accepterHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_config_aggregate_authorization{})
    sb.RegisterHandler("AwsTerraform::Aws_config_aggregate_authorizationHandler", &Aws_config_aggregate_authorizationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudhsm_v2_hsm{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudhsm_v2_hsmHandler", &Aws_cloudhsm_v2_hsmHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iam_role_policy_attachment{})
    sb.RegisterHandler("AwsTerraform::Aws_iam_role_policy_attachmentHandler", &Aws_iam_role_policy_attachmentHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lightsail_key_pair{})
    sb.RegisterHandler("AwsTerraform::Aws_lightsail_key_pairHandler", &Aws_lightsail_key_pairHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_instance{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_instanceHandler", &Aws_opsworks_instanceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_s3_account_public_access_block{})
    sb.RegisterHandler("AwsTerraform::Aws_s3_account_public_access_blockHandler", &Aws_s3_account_public_access_blockHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_byte_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_byte_match_setHandler", &Aws_waf_byte_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_wafregional_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_wafregional_ruleHandler", &Aws_wafregional_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudfront_origin_access_identity{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudfront_origin_access_identityHandler", &Aws_cloudfront_origin_access_identityHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_config_delivery_channel{})
    sb.RegisterHandler("AwsTerraform::Aws_config_delivery_channelHandler", &Aws_config_delivery_channelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_launch_configuration{})
    sb.RegisterHandler("AwsTerraform::Aws_launch_configurationHandler", &Aws_launch_configurationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ssm_maintenance_window_task{})
    sb.RegisterHandler("AwsTerraform::Aws_ssm_maintenance_window_taskHandler", &Aws_ssm_maintenance_window_taskHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_macie_member_account_association{})
    sb.RegisterHandler("AwsTerraform::Aws_macie_member_account_associationHandler", &Aws_macie_member_account_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_ses_domain_identity{})
    sb.RegisterHandler("AwsTerraform::Aws_ses_domain_identityHandler", &Aws_ses_domain_identityHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_s3_bucket_notification{})
    sb.RegisterHandler("AwsTerraform::Aws_s3_bucket_notificationHandler", &Aws_s3_bucket_notificationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_default_vpc_dhcp_options{})
    sb.RegisterHandler("AwsTerraform::Aws_default_vpc_dhcp_optionsHandler", &Aws_default_vpc_dhcp_optionsHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_appautoscaling_target{})
    sb.RegisterHandler("AwsTerraform::Aws_appautoscaling_targetHandler", &Aws_appautoscaling_targetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_licensemanager_license_configuration{})
    sb.RegisterHandler("AwsTerraform::Aws_licensemanager_license_configurationHandler", &Aws_licensemanager_license_configurationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_waf_regex_match_set{})
    sb.RegisterHandler("AwsTerraform::Aws_waf_regex_match_setHandler", &Aws_waf_regex_match_setHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_api_gateway_resource{})
    sb.RegisterHandler("AwsTerraform::Aws_api_gateway_resourceHandler", &Aws_api_gateway_resourceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_glue_security_configuration{})
    sb.RegisterHandler("AwsTerraform::Aws_glue_security_configurationHandler", &Aws_glue_security_configurationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_guardduty_ipset{})
    sb.RegisterHandler("AwsTerraform::Aws_guardduty_ipsetHandler", &Aws_guardduty_ipsetHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_lb_listener_certificate{})
    sb.RegisterHandler("AwsTerraform::Aws_lb_listener_certificateHandler", &Aws_lb_listener_certificateHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_acm_certificate_validation{})
    sb.RegisterHandler("AwsTerraform::Aws_acm_certificate_validationHandler", &Aws_acm_certificate_validationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_athena_database{})
    sb.RegisterHandler("AwsTerraform::Aws_athena_databaseHandler", &Aws_athena_databaseHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_vpc_endpoint_connection_notification{})
    sb.RegisterHandler("AwsTerraform::Aws_vpc_endpoint_connection_notificationHandler", &Aws_vpc_endpoint_connection_notificationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_gateway_association{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_gateway_associationHandler", &Aws_dx_gateway_associationHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_elb{})
    sb.RegisterHandler("AwsTerraform::Aws_elbHandler", &Aws_elbHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_dx_public_virtual_interface{})
    sb.RegisterHandler("AwsTerraform::Aws_dx_public_virtual_interfaceHandler", &Aws_dx_public_virtual_interfaceHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_route_table{})
    sb.RegisterHandler("AwsTerraform::Aws_route_tableHandler", &Aws_route_tableHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_security_group{})
    sb.RegisterHandler("AwsTerraform::Aws_security_groupHandler", &Aws_security_groupHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_spot_fleet_request{})
    sb.RegisterHandler("AwsTerraform::Aws_spot_fleet_requestHandler", &Aws_spot_fleet_requestHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_iot_thing_type{})
    sb.RegisterHandler("AwsTerraform::Aws_iot_thing_typeHandler", &Aws_iot_thing_typeHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_cloudwatch_log_resource_policy{})
    sb.RegisterHandler("AwsTerraform::Aws_cloudwatch_log_resource_policyHandler", &Aws_cloudwatch_log_resource_policyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_rails_app_layer{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_rails_app_layerHandler", &Aws_opsworks_rails_app_layerHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_network_acl_rule{})
    sb.RegisterHandler("AwsTerraform::Aws_network_acl_ruleHandler", &Aws_network_acl_ruleHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_opsworks_permission{})
    sb.RegisterHandler("AwsTerraform::Aws_opsworks_permissionHandler", &Aws_opsworks_permissionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("AwsTerraform", Aws_transfer_ssh_key{})
    sb.RegisterHandler("AwsTerraform::Aws_transfer_ssh_keyHandler", &Aws_transfer_ssh_keyHandler{provider: p}, evs[0])
}

type Aws_docdb_subnet_group struct {
     Aws_docdb_subnet_group_id *string
     Name_prefix *string
     Description *string
     Tags *map[string]string
     Arn *string
     Name *string
}


func Aws_docdb_subnet_groupMapper(r *Aws_docdb_subnet_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_docdb_subnet_groupUnmapper(state map[string]interface{}) *Aws_docdb_subnet_group {
	r := &Aws_docdb_subnet_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_docdb_subnet_group_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}

// Aws_docdb_subnet_groupHandler ...
type Aws_docdb_subnet_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_docdb_subnet_groupHandler) Create(desired *Aws_docdb_subnet_group) (*Aws_docdb_subnet_group, string, error) {
	rState := Aws_docdb_subnet_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_docdb_subnet_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_docdb_subnet_groupHandler) Read(externalID string) (*Aws_docdb_subnet_group, error) {
	actual, err := bridge.Read(h.provider, "aws_docdb_subnet_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_docdb_subnet_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_docdb_subnet_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_docdb_subnet_group", externalID)
}

type Aws_iot_thing struct {
     Aws_iot_thing_id *string
     Name string
     Attributes *map[string]string
     Thing_type_name *string
     Default_client_id *string
     Arn *string
}


func Aws_iot_thingMapper(r *Aws_iot_thing) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Attributes != nil {
    config["attributes"] = *r.Attributes
}
if r.Thing_type_name != nil {
    config["thing_type_name"] = *r.Thing_type_name
}
if r.Default_client_id != nil {
    config["default_client_id"] = *r.Default_client_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iot_thingUnmapper(state map[string]interface{}) *Aws_iot_thing {
	r := &Aws_iot_thing{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iot_thing_id = &x
}

if x, ok := state["default_client_id"]; ok {
	x := x.(string)
	r.Default_client_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["attributes"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Attributes = &x
}

if x, ok := state["thing_type_name"]; ok {
	x := x.(string)
	r.Thing_type_name = &x
}
	return r
}


// Aws_iot_thingHandler ...
type Aws_iot_thingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iot_thingHandler) Create(desired *Aws_iot_thing) (*Aws_iot_thing, string, error) {
	rState := Aws_iot_thingMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iot_thing", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iot_thingHandler) Read(externalID string) (*Aws_iot_thing, error) {
	actual, err := bridge.Read(h.provider, "aws_iot_thing", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iot_thingUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iot_thingHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iot_thing", externalID)
}

type Aws_default_security_group struct {
     Aws_default_security_group_id *string
     Arn *string
     Owner_id *string
     Name *string
     Revoke_rules_on_delete *bool
     Vpc_id *string
     Tags *map[string]string
}


func Aws_default_security_groupMapper(r *Aws_default_security_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Revoke_rules_on_delete != nil {
    config["revoke_rules_on_delete"] = *r.Revoke_rules_on_delete
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_default_security_groupUnmapper(state map[string]interface{}) *Aws_default_security_group {
	r := &Aws_default_security_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_default_security_group_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["revoke_rules_on_delete"]; ok {
	x := x.(bool)
	r.Revoke_rules_on_delete = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}
	return r
}


// Aws_default_security_groupHandler ...
type Aws_default_security_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_default_security_groupHandler) Create(desired *Aws_default_security_group) (*Aws_default_security_group, string, error) {
	rState := Aws_default_security_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_default_security_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_default_security_groupHandler) Read(externalID string) (*Aws_default_security_group, error) {
	actual, err := bridge.Read(h.provider, "aws_default_security_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_default_security_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_default_security_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_default_security_group", externalID)
}

type Aws_waf_sql_injection_match_set struct {
     Aws_waf_sql_injection_match_set_id *string
     Name string
}


func Aws_waf_sql_injection_match_setMapper(r *Aws_waf_sql_injection_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_sql_injection_match_setUnmapper(state map[string]interface{}) *Aws_waf_sql_injection_match_set {
	r := &Aws_waf_sql_injection_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_sql_injection_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_waf_sql_injection_match_setHandler ...
type Aws_waf_sql_injection_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_sql_injection_match_setHandler) Create(desired *Aws_waf_sql_injection_match_set) (*Aws_waf_sql_injection_match_set, string, error) {
	rState := Aws_waf_sql_injection_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_sql_injection_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_sql_injection_match_setHandler) Read(externalID string) (*Aws_waf_sql_injection_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_sql_injection_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_sql_injection_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_sql_injection_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_sql_injection_match_set", externalID)
}

type Aws_api_gateway_documentation_version struct {
     Aws_api_gateway_documentation_version_id *string
     Description *string
     Version string
     Rest_api_id string
}


func Aws_api_gateway_documentation_versionMapper(r *Aws_api_gateway_documentation_version) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
    config["version"] = r.Version
    config["rest_api_id"] = r.Rest_api_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_documentation_versionUnmapper(state map[string]interface{}) *Aws_api_gateway_documentation_version {
	r := &Aws_api_gateway_documentation_version{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_documentation_version_id = &x
}

if x, ok := state["version"]; ok {
	r.Version = x.(string)
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_api_gateway_documentation_versionHandler ...
type Aws_api_gateway_documentation_versionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_documentation_versionHandler) Create(desired *Aws_api_gateway_documentation_version) (*Aws_api_gateway_documentation_version, string, error) {
	rState := Aws_api_gateway_documentation_versionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_documentation_version", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_documentation_versionHandler) Read(externalID string) (*Aws_api_gateway_documentation_version, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_documentation_version", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_documentation_versionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_documentation_versionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_documentation_version", externalID)
}

type Aws_cognito_user_pool struct {
     Aws_cognito_user_pool_id *string
     Creation_date *string
     Endpoint *string
     Sms_authentication_message *string
     Name string
     Last_modified_date *string
     Mfa_configuration *string
     Sms_verification_message *string
     Arn *string
     Email_verification_subject *string
     Email_verification_message *string
     Tags *map[string]string
}


func Aws_cognito_user_poolMapper(r *Aws_cognito_user_pool) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Last_modified_date != nil {
    config["last_modified_date"] = *r.Last_modified_date
}
if r.Mfa_configuration != nil {
    config["mfa_configuration"] = *r.Mfa_configuration
}
if r.Sms_verification_message != nil {
    config["sms_verification_message"] = *r.Sms_verification_message
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Email_verification_subject != nil {
    config["email_verification_subject"] = *r.Email_verification_subject
}
if r.Email_verification_message != nil {
    config["email_verification_message"] = *r.Email_verification_message
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Creation_date != nil {
    config["creation_date"] = *r.Creation_date
}
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
if r.Sms_authentication_message != nil {
    config["sms_authentication_message"] = *r.Sms_authentication_message
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cognito_user_poolUnmapper(state map[string]interface{}) *Aws_cognito_user_pool {
	r := &Aws_cognito_user_pool{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cognito_user_pool_id = &x
}

if x, ok := state["email_verification_subject"]; ok {
	x := x.(string)
	r.Email_verification_subject = &x
}

if x, ok := state["email_verification_message"]; ok {
	x := x.(string)
	r.Email_verification_message = &x
}

if x, ok := state["last_modified_date"]; ok {
	x := x.(string)
	r.Last_modified_date = &x
}

if x, ok := state["mfa_configuration"]; ok {
	x := x.(string)
	r.Mfa_configuration = &x
}

if x, ok := state["sms_verification_message"]; ok {
	x := x.(string)
	r.Sms_verification_message = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["creation_date"]; ok {
	x := x.(string)
	r.Creation_date = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["sms_authentication_message"]; ok {
	x := x.(string)
	r.Sms_authentication_message = &x
}
	return r
}


// Aws_cognito_user_poolHandler ...
type Aws_cognito_user_poolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cognito_user_poolHandler) Create(desired *Aws_cognito_user_pool) (*Aws_cognito_user_pool, string, error) {
	rState := Aws_cognito_user_poolMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cognito_user_pool", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cognito_user_poolHandler) Read(externalID string) (*Aws_cognito_user_pool, error) {
	actual, err := bridge.Read(h.provider, "aws_cognito_user_pool", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cognito_user_poolUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cognito_user_poolHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cognito_user_pool", externalID)
}

type Aws_appautoscaling_scheduled_action struct {
     Aws_appautoscaling_scheduled_action_id *string
     Service_namespace string
     Resource_id string
     Arn *string
     End_time *string
     Name string
     Scalable_dimension *string
     Schedule *string
     Start_time *string
}


func Aws_appautoscaling_scheduled_actionMapper(r *Aws_appautoscaling_scheduled_action) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["service_namespace"] = r.Service_namespace
    config["resource_id"] = r.Resource_id
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Start_time != nil {
    config["start_time"] = *r.Start_time
}
if r.End_time != nil {
    config["end_time"] = *r.End_time
}
    config["name"] = r.Name
if r.Scalable_dimension != nil {
    config["scalable_dimension"] = *r.Scalable_dimension
}
if r.Schedule != nil {
    config["schedule"] = *r.Schedule
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appautoscaling_scheduled_actionUnmapper(state map[string]interface{}) *Aws_appautoscaling_scheduled_action {
	r := &Aws_appautoscaling_scheduled_action{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appautoscaling_scheduled_action_id = &x
}

if x, ok := state["scalable_dimension"]; ok {
	x := x.(string)
	r.Scalable_dimension = &x
}

if x, ok := state["schedule"]; ok {
	x := x.(string)
	r.Schedule = &x
}

if x, ok := state["start_time"]; ok {
	x := x.(string)
	r.Start_time = &x
}

if x, ok := state["end_time"]; ok {
	x := x.(string)
	r.End_time = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["resource_id"]; ok {
	r.Resource_id = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["service_namespace"]; ok {
	r.Service_namespace = x.(string)
}
	return r
}


// Aws_appautoscaling_scheduled_actionHandler ...
type Aws_appautoscaling_scheduled_actionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appautoscaling_scheduled_actionHandler) Create(desired *Aws_appautoscaling_scheduled_action) (*Aws_appautoscaling_scheduled_action, string, error) {
	rState := Aws_appautoscaling_scheduled_actionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appautoscaling_scheduled_action", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appautoscaling_scheduled_actionHandler) Read(externalID string) (*Aws_appautoscaling_scheduled_action, error) {
	actual, err := bridge.Read(h.provider, "aws_appautoscaling_scheduled_action", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appautoscaling_scheduled_actionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appautoscaling_scheduled_actionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appautoscaling_scheduled_action", externalID)
}

type Aws_lb_target_group struct {
     Aws_lb_target_group_id *string
     Arn *string
     Arn_suffix *string
     Protocol *string
     Target_type *string
     Name *string
     Name_prefix *string
     Vpc_id *string
     Proxy_protocol_v2 *bool
     Tags *map[string]string
}


func Aws_lb_target_groupMapper(r *Aws_lb_target_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Proxy_protocol_v2 != nil {
    config["proxy_protocol_v2"] = *r.Proxy_protocol_v2
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Protocol != nil {
    config["protocol"] = *r.Protocol
}
if r.Target_type != nil {
    config["target_type"] = *r.Target_type
}
if r.Arn_suffix != nil {
    config["arn_suffix"] = *r.Arn_suffix
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lb_target_groupUnmapper(state map[string]interface{}) *Aws_lb_target_group {
	r := &Aws_lb_target_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lb_target_group_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["arn_suffix"]; ok {
	x := x.(string)
	r.Arn_suffix = &x
}

if x, ok := state["protocol"]; ok {
	x := x.(string)
	r.Protocol = &x
}

if x, ok := state["target_type"]; ok {
	x := x.(string)
	r.Target_type = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["proxy_protocol_v2"]; ok {
	x := x.(bool)
	r.Proxy_protocol_v2 = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_lb_target_groupHandler ...
type Aws_lb_target_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lb_target_groupHandler) Create(desired *Aws_lb_target_group) (*Aws_lb_target_group, string, error) {
	rState := Aws_lb_target_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lb_target_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lb_target_groupHandler) Read(externalID string) (*Aws_lb_target_group, error) {
	actual, err := bridge.Read(h.provider, "aws_lb_target_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lb_target_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lb_target_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lb_target_group", externalID)
}

type Aws_lambda_layer_version struct {
     Aws_lambda_layer_version_id *string
     S3_object_version *string
     License_info *string
     Arn *string
     Source_code_hash *string
     S3_key *string
     Description *string
     Created_date *string
     Version *string
     S3_bucket *string
     Layer_name string
     Filename *string
     Layer_arn *string
}


func Aws_lambda_layer_versionMapper(r *Aws_lambda_layer_version) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.License_info != nil {
    config["license_info"] = *r.License_info
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Source_code_hash != nil {
    config["source_code_hash"] = *r.Source_code_hash
}
if r.S3_object_version != nil {
    config["s3_object_version"] = *r.S3_object_version
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
if r.Version != nil {
    config["version"] = *r.Version
}
if r.S3_key != nil {
    config["s3_key"] = *r.S3_key
}
if r.S3_bucket != nil {
    config["s3_bucket"] = *r.S3_bucket
}
if r.Filename != nil {
    config["filename"] = *r.Filename
}
if r.Layer_arn != nil {
    config["layer_arn"] = *r.Layer_arn
}
    config["layer_name"] = r.Layer_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lambda_layer_versionUnmapper(state map[string]interface{}) *Aws_lambda_layer_version {
	r := &Aws_lambda_layer_version{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lambda_layer_version_id = &x
}

if x, ok := state["s3_key"]; ok {
	x := x.(string)
	r.S3_key = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}

if x, ok := state["version"]; ok {
	x := x.(string)
	r.Version = &x
}

if x, ok := state["s3_bucket"]; ok {
	x := x.(string)
	r.S3_bucket = &x
}

if x, ok := state["layer_name"]; ok {
	r.Layer_name = x.(string)
}

if x, ok := state["filename"]; ok {
	x := x.(string)
	r.Filename = &x
}

if x, ok := state["layer_arn"]; ok {
	x := x.(string)
	r.Layer_arn = &x
}

if x, ok := state["s3_object_version"]; ok {
	x := x.(string)
	r.S3_object_version = &x
}

if x, ok := state["license_info"]; ok {
	x := x.(string)
	r.License_info = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["source_code_hash"]; ok {
	x := x.(string)
	r.Source_code_hash = &x
}
	return r
}


// Aws_lambda_layer_versionHandler ...
type Aws_lambda_layer_versionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lambda_layer_versionHandler) Create(desired *Aws_lambda_layer_version) (*Aws_lambda_layer_version, string, error) {
	rState := Aws_lambda_layer_versionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lambda_layer_version", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lambda_layer_versionHandler) Read(externalID string) (*Aws_lambda_layer_version, error) {
	actual, err := bridge.Read(h.provider, "aws_lambda_layer_version", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lambda_layer_versionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lambda_layer_versionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lambda_layer_version", externalID)
}

type Aws_cloudtrail struct {
     Aws_cloudtrail_id *string
     Cloud_watch_logs_role_arn *string
     Enable_log_file_validation *bool
     Arn *string
     Name string
     Is_organization_trail *bool
     Cloud_watch_logs_group_arn *string
     Is_multi_region_trail *bool
     Kms_key_id *string
     Tags *map[string]string
     Home_region *string
     Enable_logging *bool
     S3_bucket_name string
     S3_key_prefix *string
     Include_global_service_events *bool
     Sns_topic_name *string
}


func Aws_cloudtrailMapper(r *Aws_cloudtrail) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Is_organization_trail != nil {
    config["is_organization_trail"] = *r.Is_organization_trail
}
if r.Cloud_watch_logs_group_arn != nil {
    config["cloud_watch_logs_group_arn"] = *r.Cloud_watch_logs_group_arn
}
if r.Is_multi_region_trail != nil {
    config["is_multi_region_trail"] = *r.Is_multi_region_trail
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Enable_logging != nil {
    config["enable_logging"] = *r.Enable_logging
}
    config["s3_bucket_name"] = r.S3_bucket_name
if r.S3_key_prefix != nil {
    config["s3_key_prefix"] = *r.S3_key_prefix
}
if r.Include_global_service_events != nil {
    config["include_global_service_events"] = *r.Include_global_service_events
}
if r.Sns_topic_name != nil {
    config["sns_topic_name"] = *r.Sns_topic_name
}
if r.Home_region != nil {
    config["home_region"] = *r.Home_region
}
if r.Cloud_watch_logs_role_arn != nil {
    config["cloud_watch_logs_role_arn"] = *r.Cloud_watch_logs_role_arn
}
if r.Enable_log_file_validation != nil {
    config["enable_log_file_validation"] = *r.Enable_log_file_validation
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudtrailUnmapper(state map[string]interface{}) *Aws_cloudtrail {
	r := &Aws_cloudtrail{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudtrail_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["is_organization_trail"]; ok {
	x := x.(bool)
	r.Is_organization_trail = &x
}

if x, ok := state["cloud_watch_logs_group_arn"]; ok {
	x := x.(string)
	r.Cloud_watch_logs_group_arn = &x
}

if x, ok := state["is_multi_region_trail"]; ok {
	x := x.(bool)
	r.Is_multi_region_trail = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["enable_logging"]; ok {
	x := x.(bool)
	r.Enable_logging = &x
}

if x, ok := state["s3_bucket_name"]; ok {
	r.S3_bucket_name = x.(string)
}

if x, ok := state["s3_key_prefix"]; ok {
	x := x.(string)
	r.S3_key_prefix = &x
}

if x, ok := state["include_global_service_events"]; ok {
	x := x.(bool)
	r.Include_global_service_events = &x
}

if x, ok := state["sns_topic_name"]; ok {
	x := x.(string)
	r.Sns_topic_name = &x
}

if x, ok := state["home_region"]; ok {
	x := x.(string)
	r.Home_region = &x
}

if x, ok := state["cloud_watch_logs_role_arn"]; ok {
	x := x.(string)
	r.Cloud_watch_logs_role_arn = &x
}

if x, ok := state["enable_log_file_validation"]; ok {
	x := x.(bool)
	r.Enable_log_file_validation = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_cloudtrailHandler ...
type Aws_cloudtrailHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudtrailHandler) Create(desired *Aws_cloudtrail) (*Aws_cloudtrail, string, error) {
	rState := Aws_cloudtrailMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudtrail", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudtrailHandler) Read(externalID string) (*Aws_cloudtrail, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudtrail", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudtrailUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudtrailHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudtrail", externalID)
}

type Aws_gamelift_game_session_queue struct {
     Aws_gamelift_game_session_queue_id *string
     Name string
     Arn *string
}


func Aws_gamelift_game_session_queueMapper(r *Aws_gamelift_game_session_queue) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_gamelift_game_session_queueUnmapper(state map[string]interface{}) *Aws_gamelift_game_session_queue {
	r := &Aws_gamelift_game_session_queue{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_gamelift_game_session_queue_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_gamelift_game_session_queueHandler ...
type Aws_gamelift_game_session_queueHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_gamelift_game_session_queueHandler) Create(desired *Aws_gamelift_game_session_queue) (*Aws_gamelift_game_session_queue, string, error) {
	rState := Aws_gamelift_game_session_queueMapper(desired)
	id, err := bridge.Create(h.provider, "aws_gamelift_game_session_queue", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_gamelift_game_session_queueHandler) Read(externalID string) (*Aws_gamelift_game_session_queue, error) {
	actual, err := bridge.Read(h.provider, "aws_gamelift_game_session_queue", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_gamelift_game_session_queueUnmapper(actual), nil
}

// Delete ...
func (h *Aws_gamelift_game_session_queueHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_gamelift_game_session_queue", externalID)
}

type Aws_media_store_container struct {
     Aws_media_store_container_id *string
     Name string
     Arn *string
     Endpoint *string
}


func Aws_media_store_containerMapper(r *Aws_media_store_container) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
    config["name"] = r.Name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_media_store_containerUnmapper(state map[string]interface{}) *Aws_media_store_container {
	r := &Aws_media_store_container{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_media_store_container_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}
	return r
}


// Aws_media_store_containerHandler ...
type Aws_media_store_containerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_media_store_containerHandler) Create(desired *Aws_media_store_container) (*Aws_media_store_container, string, error) {
	rState := Aws_media_store_containerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_media_store_container", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_media_store_containerHandler) Read(externalID string) (*Aws_media_store_container, error) {
	actual, err := bridge.Read(h.provider, "aws_media_store_container", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_media_store_containerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_media_store_containerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_media_store_container", externalID)
}

type Aws_lb_cookie_stickiness_policy struct {
     Aws_lb_cookie_stickiness_policy_id *string
     Name string
     Load_balancer string
}


func Aws_lb_cookie_stickiness_policyMapper(r *Aws_lb_cookie_stickiness_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["load_balancer"] = r.Load_balancer
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lb_cookie_stickiness_policyUnmapper(state map[string]interface{}) *Aws_lb_cookie_stickiness_policy {
	r := &Aws_lb_cookie_stickiness_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lb_cookie_stickiness_policy_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["load_balancer"]; ok {
	r.Load_balancer = x.(string)
}
	return r
}


// Aws_lb_cookie_stickiness_policyHandler ...
type Aws_lb_cookie_stickiness_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lb_cookie_stickiness_policyHandler) Create(desired *Aws_lb_cookie_stickiness_policy) (*Aws_lb_cookie_stickiness_policy, string, error) {
	rState := Aws_lb_cookie_stickiness_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lb_cookie_stickiness_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lb_cookie_stickiness_policyHandler) Read(externalID string) (*Aws_lb_cookie_stickiness_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_lb_cookie_stickiness_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lb_cookie_stickiness_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lb_cookie_stickiness_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lb_cookie_stickiness_policy", externalID)
}

type Aws_api_gateway_rest_api struct {
     Aws_api_gateway_rest_api_id *string
     Root_resource_id *string
     Created_date *string
     Description *string
     Policy *string
     Execution_arn *string
     Name string
     Api_key_source *string
     Body *string
}


func Aws_api_gateway_rest_apiMapper(r *Aws_api_gateway_rest_api) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
if r.Policy != nil {
    config["policy"] = *r.Policy
}
if r.Root_resource_id != nil {
    config["root_resource_id"] = *r.Root_resource_id
}
if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
    config["name"] = r.Name
if r.Api_key_source != nil {
    config["api_key_source"] = *r.Api_key_source
}
if r.Body != nil {
    config["body"] = *r.Body
}
if r.Execution_arn != nil {
    config["execution_arn"] = *r.Execution_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_rest_apiUnmapper(state map[string]interface{}) *Aws_api_gateway_rest_api {
	r := &Aws_api_gateway_rest_api{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_rest_api_id = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["policy"]; ok {
	x := x.(string)
	r.Policy = &x
}

if x, ok := state["root_resource_id"]; ok {
	x := x.(string)
	r.Root_resource_id = &x
}

if x, ok := state["execution_arn"]; ok {
	x := x.(string)
	r.Execution_arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["api_key_source"]; ok {
	x := x.(string)
	r.Api_key_source = &x
}

if x, ok := state["body"]; ok {
	x := x.(string)
	r.Body = &x
}
	return r
}


// Aws_api_gateway_rest_apiHandler ...
type Aws_api_gateway_rest_apiHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_rest_apiHandler) Create(desired *Aws_api_gateway_rest_api) (*Aws_api_gateway_rest_api, string, error) {
	rState := Aws_api_gateway_rest_apiMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_rest_api", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_rest_apiHandler) Read(externalID string) (*Aws_api_gateway_rest_api, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_rest_api", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_rest_apiUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_rest_apiHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_rest_api", externalID)
}

type Aws_iot_thing_principal_attachment struct {
     Aws_iot_thing_principal_attachment_id *string
     Principal string
     Thing string
}


func Aws_iot_thing_principal_attachmentMapper(r *Aws_iot_thing_principal_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["principal"] = r.Principal
    config["thing"] = r.Thing
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iot_thing_principal_attachmentUnmapper(state map[string]interface{}) *Aws_iot_thing_principal_attachment {
	r := &Aws_iot_thing_principal_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iot_thing_principal_attachment_id = &x
}

if x, ok := state["principal"]; ok {
	r.Principal = x.(string)
}

if x, ok := state["thing"]; ok {
	r.Thing = x.(string)
}
	return r
}


// Aws_iot_thing_principal_attachmentHandler ...
type Aws_iot_thing_principal_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iot_thing_principal_attachmentHandler) Create(desired *Aws_iot_thing_principal_attachment) (*Aws_iot_thing_principal_attachment, string, error) {
	rState := Aws_iot_thing_principal_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iot_thing_principal_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iot_thing_principal_attachmentHandler) Read(externalID string) (*Aws_iot_thing_principal_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_iot_thing_principal_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iot_thing_principal_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iot_thing_principal_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iot_thing_principal_attachment", externalID)
}

type Aws_ecr_repository struct {
     Aws_ecr_repository_id *string
     Name string
     Tags *map[string]string
     Arn *string
     Registry_id *string
     Repository_url *string
}


func Aws_ecr_repositoryMapper(r *Aws_ecr_repository) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Registry_id != nil {
    config["registry_id"] = *r.Registry_id
}
if r.Repository_url != nil {
    config["repository_url"] = *r.Repository_url
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ecr_repositoryUnmapper(state map[string]interface{}) *Aws_ecr_repository {
	r := &Aws_ecr_repository{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ecr_repository_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["registry_id"]; ok {
	x := x.(string)
	r.Registry_id = &x
}

if x, ok := state["repository_url"]; ok {
	x := x.(string)
	r.Repository_url = &x
}
	return r
}


// Aws_ecr_repositoryHandler ...
type Aws_ecr_repositoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ecr_repositoryHandler) Create(desired *Aws_ecr_repository) (*Aws_ecr_repository, string, error) {
	rState := Aws_ecr_repositoryMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ecr_repository", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ecr_repositoryHandler) Read(externalID string) (*Aws_ecr_repository, error) {
	actual, err := bridge.Read(h.provider, "aws_ecr_repository", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ecr_repositoryUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ecr_repositoryHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ecr_repository", externalID)
}

type Aws_route53_record struct {
     Aws_route53_record_id *string
     Resource_type string
     Zone_id string
     Fqdn *string
     Failover *string
     Health_check_id *string
     Multivalue_answer_routing_policy *bool
     Name string
     Set_identifier *string
     Allow_overwrite *bool
}


func Aws_route53_recordMapper(r *Aws_route53_record) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Multivalue_answer_routing_policy != nil {
    config["multivalue_answer_routing_policy"] = *r.Multivalue_answer_routing_policy
}
    config["name"] = r.Name
if r.Set_identifier != nil {
    config["set_identifier"] = *r.Set_identifier
}
if r.Allow_overwrite != nil {
    config["allow_overwrite"] = *r.Allow_overwrite
}
    config["resource_type"] = r.Resource_type
    config["zone_id"] = r.Zone_id
if r.Health_check_id != nil {
    config["health_check_id"] = *r.Health_check_id
}
if r.Fqdn != nil {
    config["fqdn"] = *r.Fqdn
}
if r.Failover != nil {
    config["failover"] = *r.Failover
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_route53_recordUnmapper(state map[string]interface{}) *Aws_route53_record {
	r := &Aws_route53_record{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_route53_record_id = &x
}

if x, ok := state["multivalue_answer_routing_policy"]; ok {
	x := x.(bool)
	r.Multivalue_answer_routing_policy = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["set_identifier"]; ok {
	x := x.(string)
	r.Set_identifier = &x
}

if x, ok := state["allow_overwrite"]; ok {
	x := x.(bool)
	r.Allow_overwrite = &x
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["zone_id"]; ok {
	r.Zone_id = x.(string)
}

if x, ok := state["health_check_id"]; ok {
	x := x.(string)
	r.Health_check_id = &x
}

if x, ok := state["fqdn"]; ok {
	x := x.(string)
	r.Fqdn = &x
}

if x, ok := state["failover"]; ok {
	x := x.(string)
	r.Failover = &x
}
	return r
}


// Aws_route53_recordHandler ...
type Aws_route53_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_route53_recordHandler) Create(desired *Aws_route53_record) (*Aws_route53_record, string, error) {
	rState := Aws_route53_recordMapper(desired)
	id, err := bridge.Create(h.provider, "aws_route53_record", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_route53_recordHandler) Read(externalID string) (*Aws_route53_record, error) {
	actual, err := bridge.Read(h.provider, "aws_route53_record", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_route53_recordUnmapper(actual), nil
}

// Delete ...
func (h *Aws_route53_recordHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_route53_record", externalID)
}

type Aws_route53_zone struct {
     Aws_route53_zone_id *string
     Vpc_id *string
     Delegation_set_id *string
     Tags *map[string]string
     Force_destroy *bool
     Zone_id *string
     Name string
     Comment *string
     Vpc_region *string
}


func Aws_route53_zoneMapper(r *Aws_route53_zone) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Comment != nil {
    config["comment"] = *r.Comment
}
if r.Vpc_region != nil {
    config["vpc_region"] = *r.Vpc_region
}
if r.Zone_id != nil {
    config["zone_id"] = *r.Zone_id
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Delegation_set_id != nil {
    config["delegation_set_id"] = *r.Delegation_set_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Force_destroy != nil {
    config["force_destroy"] = *r.Force_destroy
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_route53_zoneUnmapper(state map[string]interface{}) *Aws_route53_zone {
	r := &Aws_route53_zone{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_route53_zone_id = &x
}

if x, ok := state["vpc_region"]; ok {
	x := x.(string)
	r.Vpc_region = &x
}

if x, ok := state["zone_id"]; ok {
	x := x.(string)
	r.Zone_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["comment"]; ok {
	x := x.(string)
	r.Comment = &x
}

if x, ok := state["force_destroy"]; ok {
	x := x.(bool)
	r.Force_destroy = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["delegation_set_id"]; ok {
	x := x.(string)
	r.Delegation_set_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_route53_zoneHandler ...
type Aws_route53_zoneHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_route53_zoneHandler) Create(desired *Aws_route53_zone) (*Aws_route53_zone, string, error) {
	rState := Aws_route53_zoneMapper(desired)
	id, err := bridge.Create(h.provider, "aws_route53_zone", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_route53_zoneHandler) Read(externalID string) (*Aws_route53_zone, error) {
	actual, err := bridge.Read(h.provider, "aws_route53_zone", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_route53_zoneUnmapper(actual), nil
}

// Delete ...
func (h *Aws_route53_zoneHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_route53_zone", externalID)
}

type Aws_vpc_endpoint struct {
     Aws_vpc_endpoint_id *string
     Policy *string
     Private_dns_enabled *bool
     Prefix_list_id *string
     Vpc_id string
     State *string
     Auto_accept *bool
     Vpc_endpoint_type *string
     Service_name string
}


func Aws_vpc_endpointMapper(r *Aws_vpc_endpoint) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Prefix_list_id != nil {
    config["prefix_list_id"] = *r.Prefix_list_id
}
    config["vpc_id"] = r.Vpc_id
if r.Auto_accept != nil {
    config["auto_accept"] = *r.Auto_accept
}
if r.Vpc_endpoint_type != nil {
    config["vpc_endpoint_type"] = *r.Vpc_endpoint_type
}
    config["service_name"] = r.Service_name
if r.State != nil {
    config["state"] = *r.State
}
if r.Policy != nil {
    config["policy"] = *r.Policy
}
if r.Private_dns_enabled != nil {
    config["private_dns_enabled"] = *r.Private_dns_enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_endpointUnmapper(state map[string]interface{}) *Aws_vpc_endpoint {
	r := &Aws_vpc_endpoint{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_endpoint_id = &x
}

if x, ok := state["prefix_list_id"]; ok {
	x := x.(string)
	r.Prefix_list_id = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["auto_accept"]; ok {
	x := x.(bool)
	r.Auto_accept = &x
}

if x, ok := state["vpc_endpoint_type"]; ok {
	x := x.(string)
	r.Vpc_endpoint_type = &x
}

if x, ok := state["service_name"]; ok {
	r.Service_name = x.(string)
}

if x, ok := state["state"]; ok {
	x := x.(string)
	r.State = &x
}

if x, ok := state["policy"]; ok {
	x := x.(string)
	r.Policy = &x
}

if x, ok := state["private_dns_enabled"]; ok {
	x := x.(bool)
	r.Private_dns_enabled = &x
}
	return r
}


// Aws_vpc_endpointHandler ...
type Aws_vpc_endpointHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_endpointHandler) Create(desired *Aws_vpc_endpoint) (*Aws_vpc_endpoint, string, error) {
	rState := Aws_vpc_endpointMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_endpoint", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_endpointHandler) Read(externalID string) (*Aws_vpc_endpoint, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_endpoint", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_endpointUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_endpointHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_endpoint", externalID)
}

type Aws_vpn_connection_route struct {
     Aws_vpn_connection_route_id *string
     Destination_cidr_block string
     Vpn_connection_id string
}


func Aws_vpn_connection_routeMapper(r *Aws_vpn_connection_route) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["destination_cidr_block"] = r.Destination_cidr_block
    config["vpn_connection_id"] = r.Vpn_connection_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpn_connection_routeUnmapper(state map[string]interface{}) *Aws_vpn_connection_route {
	r := &Aws_vpn_connection_route{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpn_connection_route_id = &x
}

if x, ok := state["destination_cidr_block"]; ok {
	r.Destination_cidr_block = x.(string)
}

if x, ok := state["vpn_connection_id"]; ok {
	r.Vpn_connection_id = x.(string)
}
	return r
}


// Aws_vpn_connection_routeHandler ...
type Aws_vpn_connection_routeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpn_connection_routeHandler) Create(desired *Aws_vpn_connection_route) (*Aws_vpn_connection_route, string, error) {
	rState := Aws_vpn_connection_routeMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpn_connection_route", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpn_connection_routeHandler) Read(externalID string) (*Aws_vpn_connection_route, error) {
	actual, err := bridge.Read(h.provider, "aws_vpn_connection_route", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpn_connection_routeUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpn_connection_routeHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpn_connection_route", externalID)
}

type Aws_vpn_gateway_route_propagation struct {
     Aws_vpn_gateway_route_propagation_id *string
     Vpn_gateway_id string
     Route_table_id string
}


func Aws_vpn_gateway_route_propagationMapper(r *Aws_vpn_gateway_route_propagation) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpn_gateway_id"] = r.Vpn_gateway_id
    config["route_table_id"] = r.Route_table_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpn_gateway_route_propagationUnmapper(state map[string]interface{}) *Aws_vpn_gateway_route_propagation {
	r := &Aws_vpn_gateway_route_propagation{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpn_gateway_route_propagation_id = &x
}

if x, ok := state["vpn_gateway_id"]; ok {
	r.Vpn_gateway_id = x.(string)
}

if x, ok := state["route_table_id"]; ok {
	r.Route_table_id = x.(string)
}
	return r
}


// Aws_vpn_gateway_route_propagationHandler ...
type Aws_vpn_gateway_route_propagationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpn_gateway_route_propagationHandler) Create(desired *Aws_vpn_gateway_route_propagation) (*Aws_vpn_gateway_route_propagation, string, error) {
	rState := Aws_vpn_gateway_route_propagationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpn_gateway_route_propagation", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpn_gateway_route_propagationHandler) Read(externalID string) (*Aws_vpn_gateway_route_propagation, error) {
	actual, err := bridge.Read(h.provider, "aws_vpn_gateway_route_propagation", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpn_gateway_route_propagationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpn_gateway_route_propagationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpn_gateway_route_propagation", externalID)
}

type Aws_cloudhsm_v2_cluster struct {
     Aws_cloudhsm_v2_cluster_id *string
     Hsm_type string
     Cluster_id *string
     Security_group_id *string
     Cluster_state *string
     Tags *map[string]string
     Source_backup_identifier *string
     Vpc_id *string
}


func Aws_cloudhsm_v2_clusterMapper(r *Aws_cloudhsm_v2_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["hsm_type"] = r.Hsm_type
if r.Cluster_id != nil {
    config["cluster_id"] = *r.Cluster_id
}
if r.Security_group_id != nil {
    config["security_group_id"] = *r.Security_group_id
}
if r.Cluster_state != nil {
    config["cluster_state"] = *r.Cluster_state
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Source_backup_identifier != nil {
    config["source_backup_identifier"] = *r.Source_backup_identifier
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudhsm_v2_clusterUnmapper(state map[string]interface{}) *Aws_cloudhsm_v2_cluster {
	r := &Aws_cloudhsm_v2_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudhsm_v2_cluster_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["hsm_type"]; ok {
	r.Hsm_type = x.(string)
}

if x, ok := state["cluster_id"]; ok {
	x := x.(string)
	r.Cluster_id = &x
}

if x, ok := state["security_group_id"]; ok {
	x := x.(string)
	r.Security_group_id = &x
}

if x, ok := state["cluster_state"]; ok {
	x := x.(string)
	r.Cluster_state = &x
}

if x, ok := state["source_backup_identifier"]; ok {
	x := x.(string)
	r.Source_backup_identifier = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}
	return r
}


// Aws_cloudhsm_v2_clusterHandler ...
type Aws_cloudhsm_v2_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudhsm_v2_clusterHandler) Create(desired *Aws_cloudhsm_v2_cluster) (*Aws_cloudhsm_v2_cluster, string, error) {
	rState := Aws_cloudhsm_v2_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudhsm_v2_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudhsm_v2_clusterHandler) Read(externalID string) (*Aws_cloudhsm_v2_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudhsm_v2_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudhsm_v2_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudhsm_v2_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudhsm_v2_cluster", externalID)
}

type Aws_codepipeline struct {
     Aws_codepipeline_id *string
     Arn *string
     Name string
     Role_arn string
}


func Aws_codepipelineMapper(r *Aws_codepipeline) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
    config["role_arn"] = r.Role_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_codepipelineUnmapper(state map[string]interface{}) *Aws_codepipeline {
	r := &Aws_codepipeline{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_codepipeline_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}
	return r
}


// Aws_codepipelineHandler ...
type Aws_codepipelineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_codepipelineHandler) Create(desired *Aws_codepipeline) (*Aws_codepipeline, string, error) {
	rState := Aws_codepipelineMapper(desired)
	id, err := bridge.Create(h.provider, "aws_codepipeline", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_codepipelineHandler) Read(externalID string) (*Aws_codepipeline, error) {
	actual, err := bridge.Read(h.provider, "aws_codepipeline", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_codepipelineUnmapper(actual), nil
}

// Delete ...
func (h *Aws_codepipelineHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_codepipeline", externalID)
}

type Aws_pinpoint_apns_voip_sandbox_channel struct {
     Aws_pinpoint_apns_voip_sandbox_channel_id *string
     Token_key_id *string
     Bundle_id *string
     Certificate *string
     Default_authentication_method *string
     Enabled *bool
     Team_id *string
     Application_id string
     Private_key *string
     Token_key *string
}


func Aws_pinpoint_apns_voip_sandbox_channelMapper(r *Aws_pinpoint_apns_voip_sandbox_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["application_id"] = r.Application_id
if r.Private_key != nil {
    config["private_key"] = *r.Private_key
}
if r.Token_key != nil {
    config["token_key"] = *r.Token_key
}
if r.Team_id != nil {
    config["team_id"] = *r.Team_id
}
if r.Token_key_id != nil {
    config["token_key_id"] = *r.Token_key_id
}
if r.Bundle_id != nil {
    config["bundle_id"] = *r.Bundle_id
}
if r.Certificate != nil {
    config["certificate"] = *r.Certificate
}
if r.Default_authentication_method != nil {
    config["default_authentication_method"] = *r.Default_authentication_method
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_apns_voip_sandbox_channelUnmapper(state map[string]interface{}) *Aws_pinpoint_apns_voip_sandbox_channel {
	r := &Aws_pinpoint_apns_voip_sandbox_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_apns_voip_sandbox_channel_id = &x
}

if x, ok := state["bundle_id"]; ok {
	x := x.(string)
	r.Bundle_id = &x
}

if x, ok := state["certificate"]; ok {
	x := x.(string)
	r.Certificate = &x
}

if x, ok := state["default_authentication_method"]; ok {
	x := x.(string)
	r.Default_authentication_method = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["team_id"]; ok {
	x := x.(string)
	r.Team_id = &x
}

if x, ok := state["token_key_id"]; ok {
	x := x.(string)
	r.Token_key_id = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["private_key"]; ok {
	x := x.(string)
	r.Private_key = &x
}

if x, ok := state["token_key"]; ok {
	x := x.(string)
	r.Token_key = &x
}
	return r
}


// Aws_pinpoint_apns_voip_sandbox_channelHandler ...
type Aws_pinpoint_apns_voip_sandbox_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_apns_voip_sandbox_channelHandler) Create(desired *Aws_pinpoint_apns_voip_sandbox_channel) (*Aws_pinpoint_apns_voip_sandbox_channel, string, error) {
	rState := Aws_pinpoint_apns_voip_sandbox_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_apns_voip_sandbox_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_apns_voip_sandbox_channelHandler) Read(externalID string) (*Aws_pinpoint_apns_voip_sandbox_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_apns_voip_sandbox_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_apns_voip_sandbox_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_apns_voip_sandbox_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_apns_voip_sandbox_channel", externalID)
}

type Aws_dms_replication_subnet_group struct {
     Aws_dms_replication_subnet_group_id *string
     Replication_subnet_group_arn *string
     Replication_subnet_group_description string
     Replication_subnet_group_id string
     Tags *map[string]string
     Vpc_id *string
}


func Aws_dms_replication_subnet_groupMapper(r *Aws_dms_replication_subnet_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Replication_subnet_group_arn != nil {
    config["replication_subnet_group_arn"] = *r.Replication_subnet_group_arn
}
    config["replication_subnet_group_description"] = r.Replication_subnet_group_description
    config["replication_subnet_group_id"] = r.Replication_subnet_group_id
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dms_replication_subnet_groupUnmapper(state map[string]interface{}) *Aws_dms_replication_subnet_group {
	r := &Aws_dms_replication_subnet_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dms_replication_subnet_group_id = &x
}

if x, ok := state["replication_subnet_group_description"]; ok {
	r.Replication_subnet_group_description = x.(string)
}

if x, ok := state["replication_subnet_group_id"]; ok {
	r.Replication_subnet_group_id = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["replication_subnet_group_arn"]; ok {
	x := x.(string)
	r.Replication_subnet_group_arn = &x
}
	return r
}


// Aws_dms_replication_subnet_groupHandler ...
type Aws_dms_replication_subnet_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dms_replication_subnet_groupHandler) Create(desired *Aws_dms_replication_subnet_group) (*Aws_dms_replication_subnet_group, string, error) {
	rState := Aws_dms_replication_subnet_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dms_replication_subnet_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dms_replication_subnet_groupHandler) Read(externalID string) (*Aws_dms_replication_subnet_group, error) {
	actual, err := bridge.Read(h.provider, "aws_dms_replication_subnet_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dms_replication_subnet_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dms_replication_subnet_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dms_replication_subnet_group", externalID)
}

type Aws_ec2_transit_gateway_route_table struct {
     Aws_ec2_transit_gateway_route_table_id *string
     Default_propagation_route_table *bool
     Tags *map[string]string
     Transit_gateway_id string
     Default_association_route_table *bool
}


func Aws_ec2_transit_gateway_route_tableMapper(r *Aws_ec2_transit_gateway_route_table) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Default_propagation_route_table != nil {
    config["default_propagation_route_table"] = *r.Default_propagation_route_table
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["transit_gateway_id"] = r.Transit_gateway_id
if r.Default_association_route_table != nil {
    config["default_association_route_table"] = *r.Default_association_route_table
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ec2_transit_gateway_route_tableUnmapper(state map[string]interface{}) *Aws_ec2_transit_gateway_route_table {
	r := &Aws_ec2_transit_gateway_route_table{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ec2_transit_gateway_route_table_id = &x
}

if x, ok := state["default_association_route_table"]; ok {
	x := x.(bool)
	r.Default_association_route_table = &x
}

if x, ok := state["default_propagation_route_table"]; ok {
	x := x.(bool)
	r.Default_propagation_route_table = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["transit_gateway_id"]; ok {
	r.Transit_gateway_id = x.(string)
}
	return r
}


// Aws_ec2_transit_gateway_route_tableHandler ...
type Aws_ec2_transit_gateway_route_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ec2_transit_gateway_route_tableHandler) Create(desired *Aws_ec2_transit_gateway_route_table) (*Aws_ec2_transit_gateway_route_table, string, error) {
	rState := Aws_ec2_transit_gateway_route_tableMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ec2_transit_gateway_route_table", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ec2_transit_gateway_route_tableHandler) Read(externalID string) (*Aws_ec2_transit_gateway_route_table, error) {
	actual, err := bridge.Read(h.provider, "aws_ec2_transit_gateway_route_table", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ec2_transit_gateway_route_tableUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ec2_transit_gateway_route_tableHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ec2_transit_gateway_route_table", externalID)
}

type Aws_ses_identity_notification_topic struct {
     Aws_ses_identity_notification_topic_id *string
     Topic_arn *string
     Notification_type string
     Identity string
}


func Aws_ses_identity_notification_topicMapper(r *Aws_ses_identity_notification_topic) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Topic_arn != nil {
    config["topic_arn"] = *r.Topic_arn
}
    config["notification_type"] = r.Notification_type
    config["identity"] = r.Identity
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_identity_notification_topicUnmapper(state map[string]interface{}) *Aws_ses_identity_notification_topic {
	r := &Aws_ses_identity_notification_topic{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_identity_notification_topic_id = &x
}

if x, ok := state["identity"]; ok {
	r.Identity = x.(string)
}

if x, ok := state["topic_arn"]; ok {
	x := x.(string)
	r.Topic_arn = &x
}

if x, ok := state["notification_type"]; ok {
	r.Notification_type = x.(string)
}
	return r
}


// Aws_ses_identity_notification_topicHandler ...
type Aws_ses_identity_notification_topicHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_identity_notification_topicHandler) Create(desired *Aws_ses_identity_notification_topic) (*Aws_ses_identity_notification_topic, string, error) {
	rState := Aws_ses_identity_notification_topicMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_identity_notification_topic", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_identity_notification_topicHandler) Read(externalID string) (*Aws_ses_identity_notification_topic, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_identity_notification_topic", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_identity_notification_topicUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_identity_notification_topicHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_identity_notification_topic", externalID)
}

type Aws_cloudwatch_dashboard struct {
     Aws_cloudwatch_dashboard_id *string
     Dashboard_arn *string
     Dashboard_body string
     Dashboard_name string
}


func Aws_cloudwatch_dashboardMapper(r *Aws_cloudwatch_dashboard) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Dashboard_arn != nil {
    config["dashboard_arn"] = *r.Dashboard_arn
}
    config["dashboard_body"] = r.Dashboard_body
    config["dashboard_name"] = r.Dashboard_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_dashboardUnmapper(state map[string]interface{}) *Aws_cloudwatch_dashboard {
	r := &Aws_cloudwatch_dashboard{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_dashboard_id = &x
}

if x, ok := state["dashboard_arn"]; ok {
	x := x.(string)
	r.Dashboard_arn = &x
}

if x, ok := state["dashboard_body"]; ok {
	r.Dashboard_body = x.(string)
}

if x, ok := state["dashboard_name"]; ok {
	r.Dashboard_name = x.(string)
}
	return r
}


// Aws_cloudwatch_dashboardHandler ...
type Aws_cloudwatch_dashboardHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_dashboardHandler) Create(desired *Aws_cloudwatch_dashboard) (*Aws_cloudwatch_dashboard, string, error) {
	rState := Aws_cloudwatch_dashboardMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_dashboard", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_dashboardHandler) Read(externalID string) (*Aws_cloudwatch_dashboard, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_dashboard", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_dashboardUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_dashboardHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_dashboard", externalID)
}

type Aws_datasync_location_s3 struct {
     Aws_datasync_location_s3_id *string
     S3_bucket_arn string
     Subdirectory string
     Tags *map[string]string
     Uri *string
     Arn *string
}


func Aws_datasync_location_s3Mapper(r *Aws_datasync_location_s3) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["subdirectory"] = r.Subdirectory
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Uri != nil {
    config["uri"] = *r.Uri
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["s3_bucket_arn"] = r.S3_bucket_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_datasync_location_s3Unmapper(state map[string]interface{}) *Aws_datasync_location_s3 {
	r := &Aws_datasync_location_s3{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_datasync_location_s3_id = &x
}

if x, ok := state["s3_bucket_arn"]; ok {
	r.S3_bucket_arn = x.(string)
}

if x, ok := state["subdirectory"]; ok {
	r.Subdirectory = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["uri"]; ok {
	x := x.(string)
	r.Uri = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_datasync_location_s3Handler ...
type Aws_datasync_location_s3Handler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_datasync_location_s3Handler) Create(desired *Aws_datasync_location_s3) (*Aws_datasync_location_s3, string, error) {
	rState := Aws_datasync_location_s3Mapper(desired)
	id, err := bridge.Create(h.provider, "aws_datasync_location_s3", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_datasync_location_s3Handler) Read(externalID string) (*Aws_datasync_location_s3, error) {
	actual, err := bridge.Read(h.provider, "aws_datasync_location_s3", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_datasync_location_s3Unmapper(actual), nil
}

// Delete ...
func (h *Aws_datasync_location_s3Handler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_datasync_location_s3", externalID)
}

type Aws_neptune_cluster_snapshot struct {
     Aws_neptune_cluster_snapshot_id *string
     Kms_key_id *string
     License_model *string
     Vpc_id *string
     Engine *string
     Engine_version *string
     Db_cluster_snapshot_arn *string
     Source_db_cluster_snapshot_arn *string
     Snapshot_type *string
     Storage_encrypted *bool
     Db_cluster_snapshot_identifier string
     Db_cluster_identifier string
     Status *string
}


func Aws_neptune_cluster_snapshotMapper(r *Aws_neptune_cluster_snapshot) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Db_cluster_snapshot_arn != nil {
    config["db_cluster_snapshot_arn"] = *r.Db_cluster_snapshot_arn
}
if r.Source_db_cluster_snapshot_arn != nil {
    config["source_db_cluster_snapshot_arn"] = *r.Source_db_cluster_snapshot_arn
}
if r.Snapshot_type != nil {
    config["snapshot_type"] = *r.Snapshot_type
}
if r.Storage_encrypted != nil {
    config["storage_encrypted"] = *r.Storage_encrypted
}
    config["db_cluster_snapshot_identifier"] = r.Db_cluster_snapshot_identifier
    config["db_cluster_identifier"] = r.Db_cluster_identifier
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.License_model != nil {
    config["license_model"] = *r.License_model
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_neptune_cluster_snapshotUnmapper(state map[string]interface{}) *Aws_neptune_cluster_snapshot {
	r := &Aws_neptune_cluster_snapshot{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_neptune_cluster_snapshot_id = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["db_cluster_snapshot_arn"]; ok {
	x := x.(string)
	r.Db_cluster_snapshot_arn = &x
}

if x, ok := state["source_db_cluster_snapshot_arn"]; ok {
	x := x.(string)
	r.Source_db_cluster_snapshot_arn = &x
}

if x, ok := state["snapshot_type"]; ok {
	x := x.(string)
	r.Snapshot_type = &x
}

if x, ok := state["storage_encrypted"]; ok {
	x := x.(bool)
	r.Storage_encrypted = &x
}

if x, ok := state["db_cluster_snapshot_identifier"]; ok {
	r.Db_cluster_snapshot_identifier = x.(string)
}

if x, ok := state["db_cluster_identifier"]; ok {
	r.Db_cluster_identifier = x.(string)
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["license_model"]; ok {
	x := x.(string)
	r.License_model = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}
	return r
}


// Aws_neptune_cluster_snapshotHandler ...
type Aws_neptune_cluster_snapshotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_neptune_cluster_snapshotHandler) Create(desired *Aws_neptune_cluster_snapshot) (*Aws_neptune_cluster_snapshot, string, error) {
	rState := Aws_neptune_cluster_snapshotMapper(desired)
	id, err := bridge.Create(h.provider, "aws_neptune_cluster_snapshot", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_neptune_cluster_snapshotHandler) Read(externalID string) (*Aws_neptune_cluster_snapshot, error) {
	actual, err := bridge.Read(h.provider, "aws_neptune_cluster_snapshot", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_neptune_cluster_snapshotUnmapper(actual), nil
}

// Delete ...
func (h *Aws_neptune_cluster_snapshotHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_neptune_cluster_snapshot", externalID)
}

type Aws_waf_xss_match_set struct {
     Aws_waf_xss_match_set_id *string
     Name string
}


func Aws_waf_xss_match_setMapper(r *Aws_waf_xss_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_xss_match_setUnmapper(state map[string]interface{}) *Aws_waf_xss_match_set {
	r := &Aws_waf_xss_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_xss_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_waf_xss_match_setHandler ...
type Aws_waf_xss_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_xss_match_setHandler) Create(desired *Aws_waf_xss_match_set) (*Aws_waf_xss_match_set, string, error) {
	rState := Aws_waf_xss_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_xss_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_xss_match_setHandler) Read(externalID string) (*Aws_waf_xss_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_xss_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_xss_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_xss_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_xss_match_set", externalID)
}

type Aws_dx_connection_association struct {
     Aws_dx_connection_association_id *string
     Connection_id string
     Lag_id string
}


func Aws_dx_connection_associationMapper(r *Aws_dx_connection_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["connection_id"] = r.Connection_id
    config["lag_id"] = r.Lag_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_connection_associationUnmapper(state map[string]interface{}) *Aws_dx_connection_association {
	r := &Aws_dx_connection_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_connection_association_id = &x
}

if x, ok := state["connection_id"]; ok {
	r.Connection_id = x.(string)
}

if x, ok := state["lag_id"]; ok {
	r.Lag_id = x.(string)
}
	return r
}


// Aws_dx_connection_associationHandler ...
type Aws_dx_connection_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_connection_associationHandler) Create(desired *Aws_dx_connection_association) (*Aws_dx_connection_association, string, error) {
	rState := Aws_dx_connection_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_connection_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_connection_associationHandler) Read(externalID string) (*Aws_dx_connection_association, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_connection_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_connection_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_connection_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_connection_association", externalID)
}

type Aws_network_acl struct {
     Aws_network_acl_id *string
     Tags *map[string]string
     Owner_id *string
     Vpc_id string
     Subnet_id *string
}


func Aws_network_aclMapper(r *Aws_network_acl) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_id"] = r.Vpc_id
if r.Subnet_id != nil {
    config["subnet_id"] = *r.Subnet_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_network_aclUnmapper(state map[string]interface{}) *Aws_network_acl {
	r := &Aws_network_acl{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_network_acl_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["subnet_id"]; ok {
	x := x.(string)
	r.Subnet_id = &x
}
	return r
}


// Aws_network_aclHandler ...
type Aws_network_aclHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_network_aclHandler) Create(desired *Aws_network_acl) (*Aws_network_acl, string, error) {
	rState := Aws_network_aclMapper(desired)
	id, err := bridge.Create(h.provider, "aws_network_acl", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_network_aclHandler) Read(externalID string) (*Aws_network_acl, error) {
	actual, err := bridge.Read(h.provider, "aws_network_acl", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_network_aclUnmapper(actual), nil
}

// Delete ...
func (h *Aws_network_aclHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_network_acl", externalID)
}

type Aws_dx_hosted_private_virtual_interface_accepter struct {
     Aws_dx_hosted_private_virtual_interface_accepter_id *string
     Arn *string
     Virtual_interface_id string
     Vpn_gateway_id *string
     Dx_gateway_id *string
     Tags *map[string]string
}


func Aws_dx_hosted_private_virtual_interface_accepterMapper(r *Aws_dx_hosted_private_virtual_interface_accepter) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Vpn_gateway_id != nil {
    config["vpn_gateway_id"] = *r.Vpn_gateway_id
}
if r.Dx_gateway_id != nil {
    config["dx_gateway_id"] = *r.Dx_gateway_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["virtual_interface_id"] = r.Virtual_interface_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_hosted_private_virtual_interface_accepterUnmapper(state map[string]interface{}) *Aws_dx_hosted_private_virtual_interface_accepter {
	r := &Aws_dx_hosted_private_virtual_interface_accepter{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_hosted_private_virtual_interface_accepter_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["virtual_interface_id"]; ok {
	r.Virtual_interface_id = x.(string)
}

if x, ok := state["vpn_gateway_id"]; ok {
	x := x.(string)
	r.Vpn_gateway_id = &x
}

if x, ok := state["dx_gateway_id"]; ok {
	x := x.(string)
	r.Dx_gateway_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_dx_hosted_private_virtual_interface_accepterHandler ...
type Aws_dx_hosted_private_virtual_interface_accepterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_hosted_private_virtual_interface_accepterHandler) Create(desired *Aws_dx_hosted_private_virtual_interface_accepter) (*Aws_dx_hosted_private_virtual_interface_accepter, string, error) {
	rState := Aws_dx_hosted_private_virtual_interface_accepterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_hosted_private_virtual_interface_accepter", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_hosted_private_virtual_interface_accepterHandler) Read(externalID string) (*Aws_dx_hosted_private_virtual_interface_accepter, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_hosted_private_virtual_interface_accepter", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_hosted_private_virtual_interface_accepterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_hosted_private_virtual_interface_accepterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_hosted_private_virtual_interface_accepter", externalID)
}

type Aws_iam_role_policy_attachment struct {
     Aws_iam_role_policy_attachment_id *string
     Role string
     Policy_arn string
}


func Aws_iam_role_policy_attachmentMapper(r *Aws_iam_role_policy_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["role"] = r.Role
    config["policy_arn"] = r.Policy_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_role_policy_attachmentUnmapper(state map[string]interface{}) *Aws_iam_role_policy_attachment {
	r := &Aws_iam_role_policy_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_role_policy_attachment_id = &x
}

if x, ok := state["role"]; ok {
	r.Role = x.(string)
}

if x, ok := state["policy_arn"]; ok {
	r.Policy_arn = x.(string)
}
	return r
}


// Aws_iam_role_policy_attachmentHandler ...
type Aws_iam_role_policy_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_role_policy_attachmentHandler) Create(desired *Aws_iam_role_policy_attachment) (*Aws_iam_role_policy_attachment, string, error) {
	rState := Aws_iam_role_policy_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_role_policy_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_role_policy_attachmentHandler) Read(externalID string) (*Aws_iam_role_policy_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_role_policy_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_role_policy_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_role_policy_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_role_policy_attachment", externalID)
}

type Aws_lightsail_key_pair struct {
     Aws_lightsail_key_pair_id *string
     Arn *string
     Encrypted_fingerprint *string
     Encrypted_private_key *string
     Name *string
     Pgp_key *string
     Public_key *string
     Private_key *string
     Name_prefix *string
     Fingerprint *string
}


func Aws_lightsail_key_pairMapper(r *Aws_lightsail_key_pair) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name != nil {
    config["name"] = *r.Name
}
if r.Pgp_key != nil {
    config["pgp_key"] = *r.Pgp_key
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Encrypted_fingerprint != nil {
    config["encrypted_fingerprint"] = *r.Encrypted_fingerprint
}
if r.Encrypted_private_key != nil {
    config["encrypted_private_key"] = *r.Encrypted_private_key
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Fingerprint != nil {
    config["fingerprint"] = *r.Fingerprint
}
if r.Public_key != nil {
    config["public_key"] = *r.Public_key
}
if r.Private_key != nil {
    config["private_key"] = *r.Private_key
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lightsail_key_pairUnmapper(state map[string]interface{}) *Aws_lightsail_key_pair {
	r := &Aws_lightsail_key_pair{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lightsail_key_pair_id = &x
}

if x, ok := state["pgp_key"]; ok {
	x := x.(string)
	r.Pgp_key = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["encrypted_fingerprint"]; ok {
	x := x.(string)
	r.Encrypted_fingerprint = &x
}

if x, ok := state["encrypted_private_key"]; ok {
	x := x.(string)
	r.Encrypted_private_key = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["fingerprint"]; ok {
	x := x.(string)
	r.Fingerprint = &x
}

if x, ok := state["public_key"]; ok {
	x := x.(string)
	r.Public_key = &x
}

if x, ok := state["private_key"]; ok {
	x := x.(string)
	r.Private_key = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}
	return r
}


// Aws_lightsail_key_pairHandler ...
type Aws_lightsail_key_pairHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lightsail_key_pairHandler) Create(desired *Aws_lightsail_key_pair) (*Aws_lightsail_key_pair, string, error) {
	rState := Aws_lightsail_key_pairMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lightsail_key_pair", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lightsail_key_pairHandler) Read(externalID string) (*Aws_lightsail_key_pair, error) {
	actual, err := bridge.Read(h.provider, "aws_lightsail_key_pair", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lightsail_key_pairUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lightsail_key_pairHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lightsail_key_pair", externalID)
}

type Aws_opsworks_instance struct {
     Aws_opsworks_instance_id *string
     Created_at *string
     Infrastructure_class *string
     Instance_type *string
     Last_service_error_id *string
     Ami_id *string
     Auto_scaling_type *string
     Public_dns *string
     Root_device_type *string
     Agent_version *string
     Ebs_optimized *bool
     Ecs_cluster_arn *string
     Private_ip *string
     Reported_os_name *string
     Reported_os_version *string
     Availability_zone *string
     Delete_ebs *bool
     Ec2_instance_id *string
     Elastic_ip *string
     Hostname *string
     Instance_profile_arn *string
     Private_dns *string
     Reported_os_family *string
     Ssh_host_dsa_key_fingerprint *string
     Ssh_key_name *string
     Stack_id string
     Registered_by *string
     Tenancy *string
     Virtualization_type *string
     Install_updates_on_boot *bool
     Platform *string
     Public_ip *string
     Root_device_volume_id *string
     Subnet_id *string
     Os *string
     Reported_agent_version *string
     Ssh_host_rsa_key_fingerprint *string
     State *string
     Status *string
     Architecture *string
     Delete_eip *bool
}


func Aws_opsworks_instanceMapper(r *Aws_opsworks_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Delete_eip != nil {
    config["delete_eip"] = *r.Delete_eip
}
if r.Architecture != nil {
    config["architecture"] = *r.Architecture
}
if r.Infrastructure_class != nil {
    config["infrastructure_class"] = *r.Infrastructure_class
}
if r.Instance_type != nil {
    config["instance_type"] = *r.Instance_type
}
if r.Last_service_error_id != nil {
    config["last_service_error_id"] = *r.Last_service_error_id
}
if r.Created_at != nil {
    config["created_at"] = *r.Created_at
}
if r.Auto_scaling_type != nil {
    config["auto_scaling_type"] = *r.Auto_scaling_type
}
if r.Public_dns != nil {
    config["public_dns"] = *r.Public_dns
}
if r.Root_device_type != nil {
    config["root_device_type"] = *r.Root_device_type
}
if r.Ami_id != nil {
    config["ami_id"] = *r.Ami_id
}
if r.Ebs_optimized != nil {
    config["ebs_optimized"] = *r.Ebs_optimized
}
if r.Ecs_cluster_arn != nil {
    config["ecs_cluster_arn"] = *r.Ecs_cluster_arn
}
if r.Private_ip != nil {
    config["private_ip"] = *r.Private_ip
}
if r.Reported_os_name != nil {
    config["reported_os_name"] = *r.Reported_os_name
}
if r.Reported_os_version != nil {
    config["reported_os_version"] = *r.Reported_os_version
}
if r.Agent_version != nil {
    config["agent_version"] = *r.Agent_version
}
if r.Delete_ebs != nil {
    config["delete_ebs"] = *r.Delete_ebs
}
if r.Ec2_instance_id != nil {
    config["ec2_instance_id"] = *r.Ec2_instance_id
}
if r.Elastic_ip != nil {
    config["elastic_ip"] = *r.Elastic_ip
}
if r.Hostname != nil {
    config["hostname"] = *r.Hostname
}
if r.Instance_profile_arn != nil {
    config["instance_profile_arn"] = *r.Instance_profile_arn
}
if r.Private_dns != nil {
    config["private_dns"] = *r.Private_dns
}
if r.Reported_os_family != nil {
    config["reported_os_family"] = *r.Reported_os_family
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Ssh_key_name != nil {
    config["ssh_key_name"] = *r.Ssh_key_name
}
    config["stack_id"] = r.Stack_id
if r.Ssh_host_dsa_key_fingerprint != nil {
    config["ssh_host_dsa_key_fingerprint"] = *r.Ssh_host_dsa_key_fingerprint
}
if r.Tenancy != nil {
    config["tenancy"] = *r.Tenancy
}
if r.Virtualization_type != nil {
    config["virtualization_type"] = *r.Virtualization_type
}
if r.Registered_by != nil {
    config["registered_by"] = *r.Registered_by
}
if r.Platform != nil {
    config["platform"] = *r.Platform
}
if r.Public_ip != nil {
    config["public_ip"] = *r.Public_ip
}
if r.Root_device_volume_id != nil {
    config["root_device_volume_id"] = *r.Root_device_volume_id
}
if r.Subnet_id != nil {
    config["subnet_id"] = *r.Subnet_id
}
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
if r.Reported_agent_version != nil {
    config["reported_agent_version"] = *r.Reported_agent_version
}
if r.Ssh_host_rsa_key_fingerprint != nil {
    config["ssh_host_rsa_key_fingerprint"] = *r.Ssh_host_rsa_key_fingerprint
}
if r.State != nil {
    config["state"] = *r.State
}
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Os != nil {
    config["os"] = *r.Os
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_instanceUnmapper(state map[string]interface{}) *Aws_opsworks_instance {
	r := &Aws_opsworks_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_instance_id = &x
}

if x, ok := state["public_dns"]; ok {
	x := x.(string)
	r.Public_dns = &x
}

if x, ok := state["root_device_type"]; ok {
	x := x.(string)
	r.Root_device_type = &x
}

if x, ok := state["ami_id"]; ok {
	x := x.(string)
	r.Ami_id = &x
}

if x, ok := state["auto_scaling_type"]; ok {
	x := x.(string)
	r.Auto_scaling_type = &x
}

if x, ok := state["ecs_cluster_arn"]; ok {
	x := x.(string)
	r.Ecs_cluster_arn = &x
}

if x, ok := state["private_ip"]; ok {
	x := x.(string)
	r.Private_ip = &x
}

if x, ok := state["reported_os_name"]; ok {
	x := x.(string)
	r.Reported_os_name = &x
}

if x, ok := state["reported_os_version"]; ok {
	x := x.(string)
	r.Reported_os_version = &x
}

if x, ok := state["agent_version"]; ok {
	x := x.(string)
	r.Agent_version = &x
}

if x, ok := state["ebs_optimized"]; ok {
	x := x.(bool)
	r.Ebs_optimized = &x
}

if x, ok := state["ec2_instance_id"]; ok {
	x := x.(string)
	r.Ec2_instance_id = &x
}

if x, ok := state["elastic_ip"]; ok {
	x := x.(string)
	r.Elastic_ip = &x
}

if x, ok := state["hostname"]; ok {
	x := x.(string)
	r.Hostname = &x
}

if x, ok := state["instance_profile_arn"]; ok {
	x := x.(string)
	r.Instance_profile_arn = &x
}

if x, ok := state["private_dns"]; ok {
	x := x.(string)
	r.Private_dns = &x
}

if x, ok := state["reported_os_family"]; ok {
	x := x.(string)
	r.Reported_os_family = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["delete_ebs"]; ok {
	x := x.(bool)
	r.Delete_ebs = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["ssh_host_dsa_key_fingerprint"]; ok {
	x := x.(string)
	r.Ssh_host_dsa_key_fingerprint = &x
}

if x, ok := state["ssh_key_name"]; ok {
	x := x.(string)
	r.Ssh_key_name = &x
}

if x, ok := state["virtualization_type"]; ok {
	x := x.(string)
	r.Virtualization_type = &x
}

if x, ok := state["registered_by"]; ok {
	x := x.(string)
	r.Registered_by = &x
}

if x, ok := state["tenancy"]; ok {
	x := x.(string)
	r.Tenancy = &x
}

if x, ok := state["public_ip"]; ok {
	x := x.(string)
	r.Public_ip = &x
}

if x, ok := state["root_device_volume_id"]; ok {
	x := x.(string)
	r.Root_device_volume_id = &x
}

if x, ok := state["subnet_id"]; ok {
	x := x.(string)
	r.Subnet_id = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["platform"]; ok {
	x := x.(string)
	r.Platform = &x
}

if x, ok := state["ssh_host_rsa_key_fingerprint"]; ok {
	x := x.(string)
	r.Ssh_host_rsa_key_fingerprint = &x
}

if x, ok := state["state"]; ok {
	x := x.(string)
	r.State = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["os"]; ok {
	x := x.(string)
	r.Os = &x
}

if x, ok := state["reported_agent_version"]; ok {
	x := x.(string)
	r.Reported_agent_version = &x
}

if x, ok := state["architecture"]; ok {
	x := x.(string)
	r.Architecture = &x
}

if x, ok := state["delete_eip"]; ok {
	x := x.(bool)
	r.Delete_eip = &x
}

if x, ok := state["instance_type"]; ok {
	x := x.(string)
	r.Instance_type = &x
}

if x, ok := state["last_service_error_id"]; ok {
	x := x.(string)
	r.Last_service_error_id = &x
}

if x, ok := state["created_at"]; ok {
	x := x.(string)
	r.Created_at = &x
}

if x, ok := state["infrastructure_class"]; ok {
	x := x.(string)
	r.Infrastructure_class = &x
}
	return r
}


// Aws_opsworks_instanceHandler ...
type Aws_opsworks_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_instanceHandler) Create(desired *Aws_opsworks_instance) (*Aws_opsworks_instance, string, error) {
	rState := Aws_opsworks_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_instanceHandler) Read(externalID string) (*Aws_opsworks_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_instance", externalID)
}

type Aws_s3_account_public_access_block struct {
     Aws_s3_account_public_access_block_id *string
     Account_id *string
     Block_public_acls *bool
     Block_public_policy *bool
     Ignore_public_acls *bool
     Restrict_public_buckets *bool
}


func Aws_s3_account_public_access_blockMapper(r *Aws_s3_account_public_access_block) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Restrict_public_buckets != nil {
    config["restrict_public_buckets"] = *r.Restrict_public_buckets
}
if r.Account_id != nil {
    config["account_id"] = *r.Account_id
}
if r.Block_public_acls != nil {
    config["block_public_acls"] = *r.Block_public_acls
}
if r.Block_public_policy != nil {
    config["block_public_policy"] = *r.Block_public_policy
}
if r.Ignore_public_acls != nil {
    config["ignore_public_acls"] = *r.Ignore_public_acls
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_s3_account_public_access_blockUnmapper(state map[string]interface{}) *Aws_s3_account_public_access_block {
	r := &Aws_s3_account_public_access_block{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_s3_account_public_access_block_id = &x
}

if x, ok := state["ignore_public_acls"]; ok {
	x := x.(bool)
	r.Ignore_public_acls = &x
}

if x, ok := state["restrict_public_buckets"]; ok {
	x := x.(bool)
	r.Restrict_public_buckets = &x
}

if x, ok := state["account_id"]; ok {
	x := x.(string)
	r.Account_id = &x
}

if x, ok := state["block_public_acls"]; ok {
	x := x.(bool)
	r.Block_public_acls = &x
}

if x, ok := state["block_public_policy"]; ok {
	x := x.(bool)
	r.Block_public_policy = &x
}
	return r
}


// Aws_s3_account_public_access_blockHandler ...
type Aws_s3_account_public_access_blockHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_s3_account_public_access_blockHandler) Create(desired *Aws_s3_account_public_access_block) (*Aws_s3_account_public_access_block, string, error) {
	rState := Aws_s3_account_public_access_blockMapper(desired)
	id, err := bridge.Create(h.provider, "aws_s3_account_public_access_block", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_s3_account_public_access_blockHandler) Read(externalID string) (*Aws_s3_account_public_access_block, error) {
	actual, err := bridge.Read(h.provider, "aws_s3_account_public_access_block", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_s3_account_public_access_blockUnmapper(actual), nil
}

// Delete ...
func (h *Aws_s3_account_public_access_blockHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_s3_account_public_access_block", externalID)
}

type Aws_waf_byte_match_set struct {
     Aws_waf_byte_match_set_id *string
     Name string
}


func Aws_waf_byte_match_setMapper(r *Aws_waf_byte_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_byte_match_setUnmapper(state map[string]interface{}) *Aws_waf_byte_match_set {
	r := &Aws_waf_byte_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_byte_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_waf_byte_match_setHandler ...
type Aws_waf_byte_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_byte_match_setHandler) Create(desired *Aws_waf_byte_match_set) (*Aws_waf_byte_match_set, string, error) {
	rState := Aws_waf_byte_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_byte_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_byte_match_setHandler) Read(externalID string) (*Aws_waf_byte_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_byte_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_byte_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_byte_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_byte_match_set", externalID)
}

type Aws_wafregional_rule struct {
     Aws_wafregional_rule_id *string
     Name string
     Metric_name string
}


func Aws_wafregional_ruleMapper(r *Aws_wafregional_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["metric_name"] = r.Metric_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_ruleUnmapper(state map[string]interface{}) *Aws_wafregional_rule {
	r := &Aws_wafregional_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_rule_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["metric_name"]; ok {
	r.Metric_name = x.(string)
}
	return r
}


// Aws_wafregional_ruleHandler ...
type Aws_wafregional_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_ruleHandler) Create(desired *Aws_wafregional_rule) (*Aws_wafregional_rule, string, error) {
	rState := Aws_wafregional_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_ruleHandler) Read(externalID string) (*Aws_wafregional_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_rule", externalID)
}

type Aws_config_aggregate_authorization struct {
     Aws_config_aggregate_authorization_id *string
     Arn *string
     Account_id string
     Region string
}


func Aws_config_aggregate_authorizationMapper(r *Aws_config_aggregate_authorization) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["account_id"] = r.Account_id
    config["region"] = r.Region
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_config_aggregate_authorizationUnmapper(state map[string]interface{}) *Aws_config_aggregate_authorization {
	r := &Aws_config_aggregate_authorization{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_config_aggregate_authorization_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["account_id"]; ok {
	r.Account_id = x.(string)
}

if x, ok := state["region"]; ok {
	r.Region = x.(string)
}
	return r
}


// Aws_config_aggregate_authorizationHandler ...
type Aws_config_aggregate_authorizationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_config_aggregate_authorizationHandler) Create(desired *Aws_config_aggregate_authorization) (*Aws_config_aggregate_authorization, string, error) {
	rState := Aws_config_aggregate_authorizationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_config_aggregate_authorization", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_config_aggregate_authorizationHandler) Read(externalID string) (*Aws_config_aggregate_authorization, error) {
	actual, err := bridge.Read(h.provider, "aws_config_aggregate_authorization", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_config_aggregate_authorizationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_config_aggregate_authorizationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_config_aggregate_authorization", externalID)
}

type Aws_cloudhsm_v2_hsm struct {
     Aws_cloudhsm_v2_hsm_id *string
     Hsm_eni_id *string
     Cluster_id string
     Subnet_id *string
     Availability_zone *string
     Ip_address *string
     Hsm_id *string
     Hsm_state *string
}


func Aws_cloudhsm_v2_hsmMapper(r *Aws_cloudhsm_v2_hsm) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Ip_address != nil {
    config["ip_address"] = *r.Ip_address
}
if r.Hsm_id != nil {
    config["hsm_id"] = *r.Hsm_id
}
if r.Hsm_state != nil {
    config["hsm_state"] = *r.Hsm_state
}
if r.Hsm_eni_id != nil {
    config["hsm_eni_id"] = *r.Hsm_eni_id
}
    config["cluster_id"] = r.Cluster_id
if r.Subnet_id != nil {
    config["subnet_id"] = *r.Subnet_id
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudhsm_v2_hsmUnmapper(state map[string]interface{}) *Aws_cloudhsm_v2_hsm {
	r := &Aws_cloudhsm_v2_hsm{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudhsm_v2_hsm_id = &x
}

if x, ok := state["ip_address"]; ok {
	x := x.(string)
	r.Ip_address = &x
}

if x, ok := state["hsm_id"]; ok {
	x := x.(string)
	r.Hsm_id = &x
}

if x, ok := state["hsm_state"]; ok {
	x := x.(string)
	r.Hsm_state = &x
}

if x, ok := state["hsm_eni_id"]; ok {
	x := x.(string)
	r.Hsm_eni_id = &x
}

if x, ok := state["cluster_id"]; ok {
	r.Cluster_id = x.(string)
}

if x, ok := state["subnet_id"]; ok {
	x := x.(string)
	r.Subnet_id = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}
	return r
}


// Aws_cloudhsm_v2_hsmHandler ...
type Aws_cloudhsm_v2_hsmHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudhsm_v2_hsmHandler) Create(desired *Aws_cloudhsm_v2_hsm) (*Aws_cloudhsm_v2_hsm, string, error) {
	rState := Aws_cloudhsm_v2_hsmMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudhsm_v2_hsm", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudhsm_v2_hsmHandler) Read(externalID string) (*Aws_cloudhsm_v2_hsm, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudhsm_v2_hsm", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudhsm_v2_hsmUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudhsm_v2_hsmHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudhsm_v2_hsm", externalID)
}

type Aws_launch_configuration struct {
     Aws_launch_configuration_id *string
     User_data *string
     Enable_monitoring *bool
     Name *string
     Image_id string
     Iam_instance_profile *string
     Ebs_optimized *bool
     Placement_tenancy *string
     User_data_base64 *string
     Vpc_classic_link_id *string
     Spot_price *string
     Name_prefix *string
     Instance_type string
     Key_name *string
     Associate_public_ip_address *bool
}


func Aws_launch_configurationMapper(r *Aws_launch_configuration) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Placement_tenancy != nil {
    config["placement_tenancy"] = *r.Placement_tenancy
}
if r.Name != nil {
    config["name"] = *r.Name
}
    config["image_id"] = r.Image_id
if r.Iam_instance_profile != nil {
    config["iam_instance_profile"] = *r.Iam_instance_profile
}
if r.Ebs_optimized != nil {
    config["ebs_optimized"] = *r.Ebs_optimized
}
if r.User_data_base64 != nil {
    config["user_data_base64"] = *r.User_data_base64
}
if r.Vpc_classic_link_id != nil {
    config["vpc_classic_link_id"] = *r.Vpc_classic_link_id
}
if r.Spot_price != nil {
    config["spot_price"] = *r.Spot_price
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["instance_type"] = r.Instance_type
if r.Key_name != nil {
    config["key_name"] = *r.Key_name
}
if r.Associate_public_ip_address != nil {
    config["associate_public_ip_address"] = *r.Associate_public_ip_address
}
if r.User_data != nil {
    config["user_data"] = *r.User_data
}
if r.Enable_monitoring != nil {
    config["enable_monitoring"] = *r.Enable_monitoring
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_launch_configurationUnmapper(state map[string]interface{}) *Aws_launch_configuration {
	r := &Aws_launch_configuration{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_launch_configuration_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["image_id"]; ok {
	r.Image_id = x.(string)
}

if x, ok := state["iam_instance_profile"]; ok {
	x := x.(string)
	r.Iam_instance_profile = &x
}

if x, ok := state["ebs_optimized"]; ok {
	x := x.(bool)
	r.Ebs_optimized = &x
}

if x, ok := state["placement_tenancy"]; ok {
	x := x.(string)
	r.Placement_tenancy = &x
}

if x, ok := state["user_data_base64"]; ok {
	x := x.(string)
	r.User_data_base64 = &x
}

if x, ok := state["vpc_classic_link_id"]; ok {
	x := x.(string)
	r.Vpc_classic_link_id = &x
}

if x, ok := state["spot_price"]; ok {
	x := x.(string)
	r.Spot_price = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["instance_type"]; ok {
	r.Instance_type = x.(string)
}

if x, ok := state["key_name"]; ok {
	x := x.(string)
	r.Key_name = &x
}

if x, ok := state["associate_public_ip_address"]; ok {
	x := x.(bool)
	r.Associate_public_ip_address = &x
}

if x, ok := state["user_data"]; ok {
	x := x.(string)
	r.User_data = &x
}

if x, ok := state["enable_monitoring"]; ok {
	x := x.(bool)
	r.Enable_monitoring = &x
}
	return r
}


// Aws_launch_configurationHandler ...
type Aws_launch_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_launch_configurationHandler) Create(desired *Aws_launch_configuration) (*Aws_launch_configuration, string, error) {
	rState := Aws_launch_configurationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_launch_configuration", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_launch_configurationHandler) Read(externalID string) (*Aws_launch_configuration, error) {
	actual, err := bridge.Read(h.provider, "aws_launch_configuration", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_launch_configurationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_launch_configurationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_launch_configuration", externalID)
}

type Aws_ssm_maintenance_window_task struct {
     Aws_ssm_maintenance_window_task_id *string
     Window_id string
     Task_type string
     Task_arn string
     Max_concurrency string
     Max_errors string
     Service_role_arn string
     Name *string
     Description *string
}


func Aws_ssm_maintenance_window_taskMapper(r *Aws_ssm_maintenance_window_task) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["max_concurrency"] = r.Max_concurrency
    config["max_errors"] = r.Max_errors
    config["service_role_arn"] = r.Service_role_arn
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Description != nil {
    config["description"] = *r.Description
}
    config["window_id"] = r.Window_id
    config["task_type"] = r.Task_type
    config["task_arn"] = r.Task_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_maintenance_window_taskUnmapper(state map[string]interface{}) *Aws_ssm_maintenance_window_task {
	r := &Aws_ssm_maintenance_window_task{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_maintenance_window_task_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["max_concurrency"]; ok {
	r.Max_concurrency = x.(string)
}

if x, ok := state["max_errors"]; ok {
	r.Max_errors = x.(string)
}

if x, ok := state["service_role_arn"]; ok {
	r.Service_role_arn = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["window_id"]; ok {
	r.Window_id = x.(string)
}

if x, ok := state["task_type"]; ok {
	r.Task_type = x.(string)
}

if x, ok := state["task_arn"]; ok {
	r.Task_arn = x.(string)
}
	return r
}


// Aws_ssm_maintenance_window_taskHandler ...
type Aws_ssm_maintenance_window_taskHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_maintenance_window_taskHandler) Create(desired *Aws_ssm_maintenance_window_task) (*Aws_ssm_maintenance_window_task, string, error) {
	rState := Aws_ssm_maintenance_window_taskMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_maintenance_window_task", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_maintenance_window_taskHandler) Read(externalID string) (*Aws_ssm_maintenance_window_task, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_maintenance_window_task", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_maintenance_window_taskUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_maintenance_window_taskHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_maintenance_window_task", externalID)
}

type Aws_cloudfront_origin_access_identity struct {
     Aws_cloudfront_origin_access_identity_id *string
     Comment *string
     Caller_reference *string
     Cloudfront_access_identity_path *string
     Etag *string
     Iam_arn *string
     S3_canonical_user_id *string
}


func Aws_cloudfront_origin_access_identityMapper(r *Aws_cloudfront_origin_access_identity) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Comment != nil {
    config["comment"] = *r.Comment
}
if r.Caller_reference != nil {
    config["caller_reference"] = *r.Caller_reference
}
if r.Cloudfront_access_identity_path != nil {
    config["cloudfront_access_identity_path"] = *r.Cloudfront_access_identity_path
}
if r.Etag != nil {
    config["etag"] = *r.Etag
}
if r.Iam_arn != nil {
    config["iam_arn"] = *r.Iam_arn
}
if r.S3_canonical_user_id != nil {
    config["s3_canonical_user_id"] = *r.S3_canonical_user_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudfront_origin_access_identityUnmapper(state map[string]interface{}) *Aws_cloudfront_origin_access_identity {
	r := &Aws_cloudfront_origin_access_identity{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudfront_origin_access_identity_id = &x
}

if x, ok := state["comment"]; ok {
	x := x.(string)
	r.Comment = &x
}

if x, ok := state["caller_reference"]; ok {
	x := x.(string)
	r.Caller_reference = &x
}

if x, ok := state["cloudfront_access_identity_path"]; ok {
	x := x.(string)
	r.Cloudfront_access_identity_path = &x
}

if x, ok := state["etag"]; ok {
	x := x.(string)
	r.Etag = &x
}

if x, ok := state["iam_arn"]; ok {
	x := x.(string)
	r.Iam_arn = &x
}

if x, ok := state["s3_canonical_user_id"]; ok {
	x := x.(string)
	r.S3_canonical_user_id = &x
}
	return r
}


// Aws_cloudfront_origin_access_identityHandler ...
type Aws_cloudfront_origin_access_identityHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudfront_origin_access_identityHandler) Create(desired *Aws_cloudfront_origin_access_identity) (*Aws_cloudfront_origin_access_identity, string, error) {
	rState := Aws_cloudfront_origin_access_identityMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudfront_origin_access_identity", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudfront_origin_access_identityHandler) Read(externalID string) (*Aws_cloudfront_origin_access_identity, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudfront_origin_access_identity", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudfront_origin_access_identityUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudfront_origin_access_identityHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudfront_origin_access_identity", externalID)
}

type Aws_config_delivery_channel struct {
     Aws_config_delivery_channel_id *string
     S3_key_prefix *string
     Sns_topic_arn *string
     Name *string
     S3_bucket_name string
}


func Aws_config_delivery_channelMapper(r *Aws_config_delivery_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["s3_bucket_name"] = r.S3_bucket_name
if r.S3_key_prefix != nil {
    config["s3_key_prefix"] = *r.S3_key_prefix
}
if r.Sns_topic_arn != nil {
    config["sns_topic_arn"] = *r.Sns_topic_arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_config_delivery_channelUnmapper(state map[string]interface{}) *Aws_config_delivery_channel {
	r := &Aws_config_delivery_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_config_delivery_channel_id = &x
}

if x, ok := state["sns_topic_arn"]; ok {
	x := x.(string)
	r.Sns_topic_arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["s3_bucket_name"]; ok {
	r.S3_bucket_name = x.(string)
}

if x, ok := state["s3_key_prefix"]; ok {
	x := x.(string)
	r.S3_key_prefix = &x
}
	return r
}


// Aws_config_delivery_channelHandler ...
type Aws_config_delivery_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_config_delivery_channelHandler) Create(desired *Aws_config_delivery_channel) (*Aws_config_delivery_channel, string, error) {
	rState := Aws_config_delivery_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_config_delivery_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_config_delivery_channelHandler) Read(externalID string) (*Aws_config_delivery_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_config_delivery_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_config_delivery_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_config_delivery_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_config_delivery_channel", externalID)
}

type Aws_s3_bucket_notification struct {
     Aws_s3_bucket_notification_id *string
     Bucket string
}


func Aws_s3_bucket_notificationMapper(r *Aws_s3_bucket_notification) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["bucket"] = r.Bucket
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_s3_bucket_notificationUnmapper(state map[string]interface{}) *Aws_s3_bucket_notification {
	r := &Aws_s3_bucket_notification{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_s3_bucket_notification_id = &x
}

if x, ok := state["bucket"]; ok {
	r.Bucket = x.(string)
}
	return r
}


// Aws_s3_bucket_notificationHandler ...
type Aws_s3_bucket_notificationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_s3_bucket_notificationHandler) Create(desired *Aws_s3_bucket_notification) (*Aws_s3_bucket_notification, string, error) {
	rState := Aws_s3_bucket_notificationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_s3_bucket_notification", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_s3_bucket_notificationHandler) Read(externalID string) (*Aws_s3_bucket_notification, error) {
	actual, err := bridge.Read(h.provider, "aws_s3_bucket_notification", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_s3_bucket_notificationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_s3_bucket_notificationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_s3_bucket_notification", externalID)
}

type Aws_default_vpc_dhcp_options struct {
     Aws_default_vpc_dhcp_options_id *string
     Netbios_node_type *string
     Tags *map[string]string
     Owner_id *string
     Domain_name *string
     Domain_name_servers *string
     Ntp_servers *string
}


func Aws_default_vpc_dhcp_optionsMapper(r *Aws_default_vpc_dhcp_options) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
if r.Domain_name != nil {
    config["domain_name"] = *r.Domain_name
}
if r.Domain_name_servers != nil {
    config["domain_name_servers"] = *r.Domain_name_servers
}
if r.Ntp_servers != nil {
    config["ntp_servers"] = *r.Ntp_servers
}
if r.Netbios_node_type != nil {
    config["netbios_node_type"] = *r.Netbios_node_type
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_default_vpc_dhcp_optionsUnmapper(state map[string]interface{}) *Aws_default_vpc_dhcp_options {
	r := &Aws_default_vpc_dhcp_options{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_default_vpc_dhcp_options_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["domain_name"]; ok {
	x := x.(string)
	r.Domain_name = &x
}

if x, ok := state["domain_name_servers"]; ok {
	x := x.(string)
	r.Domain_name_servers = &x
}

if x, ok := state["ntp_servers"]; ok {
	x := x.(string)
	r.Ntp_servers = &x
}

if x, ok := state["netbios_node_type"]; ok {
	x := x.(string)
	r.Netbios_node_type = &x
}
	return r
}


// Aws_default_vpc_dhcp_optionsHandler ...
type Aws_default_vpc_dhcp_optionsHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_default_vpc_dhcp_optionsHandler) Create(desired *Aws_default_vpc_dhcp_options) (*Aws_default_vpc_dhcp_options, string, error) {
	rState := Aws_default_vpc_dhcp_optionsMapper(desired)
	id, err := bridge.Create(h.provider, "aws_default_vpc_dhcp_options", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_default_vpc_dhcp_optionsHandler) Read(externalID string) (*Aws_default_vpc_dhcp_options, error) {
	actual, err := bridge.Read(h.provider, "aws_default_vpc_dhcp_options", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_default_vpc_dhcp_optionsUnmapper(actual), nil
}

// Delete ...
func (h *Aws_default_vpc_dhcp_optionsHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_default_vpc_dhcp_options", externalID)
}

type Aws_macie_member_account_association struct {
     Aws_macie_member_account_association_id *string
     Member_account_id string
}


func Aws_macie_member_account_associationMapper(r *Aws_macie_member_account_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["member_account_id"] = r.Member_account_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_macie_member_account_associationUnmapper(state map[string]interface{}) *Aws_macie_member_account_association {
	r := &Aws_macie_member_account_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_macie_member_account_association_id = &x
}

if x, ok := state["member_account_id"]; ok {
	r.Member_account_id = x.(string)
}
	return r
}


// Aws_macie_member_account_associationHandler ...
type Aws_macie_member_account_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_macie_member_account_associationHandler) Create(desired *Aws_macie_member_account_association) (*Aws_macie_member_account_association, string, error) {
	rState := Aws_macie_member_account_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_macie_member_account_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_macie_member_account_associationHandler) Read(externalID string) (*Aws_macie_member_account_association, error) {
	actual, err := bridge.Read(h.provider, "aws_macie_member_account_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_macie_member_account_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_macie_member_account_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_macie_member_account_association", externalID)
}

type Aws_ses_domain_identity struct {
     Aws_ses_domain_identity_id *string
     Arn *string
     Domain string
     Verification_token *string
}


func Aws_ses_domain_identityMapper(r *Aws_ses_domain_identity) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["domain"] = r.Domain
if r.Verification_token != nil {
    config["verification_token"] = *r.Verification_token
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_domain_identityUnmapper(state map[string]interface{}) *Aws_ses_domain_identity {
	r := &Aws_ses_domain_identity{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_domain_identity_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["domain"]; ok {
	r.Domain = x.(string)
}

if x, ok := state["verification_token"]; ok {
	x := x.(string)
	r.Verification_token = &x
}
	return r
}


// Aws_ses_domain_identityHandler ...
type Aws_ses_domain_identityHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_domain_identityHandler) Create(desired *Aws_ses_domain_identity) (*Aws_ses_domain_identity, string, error) {
	rState := Aws_ses_domain_identityMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_domain_identity", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_domain_identityHandler) Read(externalID string) (*Aws_ses_domain_identity, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_domain_identity", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_domain_identityUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_domain_identityHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_domain_identity", externalID)
}

type Aws_waf_regex_match_set struct {
     Aws_waf_regex_match_set_id *string
     Name string
}


func Aws_waf_regex_match_setMapper(r *Aws_waf_regex_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_regex_match_setUnmapper(state map[string]interface{}) *Aws_waf_regex_match_set {
	r := &Aws_waf_regex_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_regex_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_waf_regex_match_setHandler ...
type Aws_waf_regex_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_regex_match_setHandler) Create(desired *Aws_waf_regex_match_set) (*Aws_waf_regex_match_set, string, error) {
	rState := Aws_waf_regex_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_regex_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_regex_match_setHandler) Read(externalID string) (*Aws_waf_regex_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_regex_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_regex_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_regex_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_regex_match_set", externalID)
}

type Aws_appautoscaling_target struct {
     Aws_appautoscaling_target_id *string
     Service_namespace string
     Resource_id string
     Role_arn *string
     Scalable_dimension string
}


func Aws_appautoscaling_targetMapper(r *Aws_appautoscaling_target) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["resource_id"] = r.Resource_id
if r.Role_arn != nil {
    config["role_arn"] = *r.Role_arn
}
    config["scalable_dimension"] = r.Scalable_dimension
    config["service_namespace"] = r.Service_namespace
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appautoscaling_targetUnmapper(state map[string]interface{}) *Aws_appautoscaling_target {
	r := &Aws_appautoscaling_target{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appautoscaling_target_id = &x
}

if x, ok := state["service_namespace"]; ok {
	r.Service_namespace = x.(string)
}

if x, ok := state["resource_id"]; ok {
	r.Resource_id = x.(string)
}

if x, ok := state["role_arn"]; ok {
	x := x.(string)
	r.Role_arn = &x
}

if x, ok := state["scalable_dimension"]; ok {
	r.Scalable_dimension = x.(string)
}
	return r
}


// Aws_appautoscaling_targetHandler ...
type Aws_appautoscaling_targetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appautoscaling_targetHandler) Create(desired *Aws_appautoscaling_target) (*Aws_appautoscaling_target, string, error) {
	rState := Aws_appautoscaling_targetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appautoscaling_target", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appautoscaling_targetHandler) Read(externalID string) (*Aws_appautoscaling_target, error) {
	actual, err := bridge.Read(h.provider, "aws_appautoscaling_target", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appautoscaling_targetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appautoscaling_targetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appautoscaling_target", externalID)
}

type Aws_licensemanager_license_configuration struct {
     Aws_licensemanager_license_configuration_id *string
     Name string
     Tags *map[string]string
     Description *string
     License_count_hard_limit *bool
     License_counting_type string
}


func Aws_licensemanager_license_configurationMapper(r *Aws_licensemanager_license_configuration) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.License_count_hard_limit != nil {
    config["license_count_hard_limit"] = *r.License_count_hard_limit
}
    config["license_counting_type"] = r.License_counting_type
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_licensemanager_license_configurationUnmapper(state map[string]interface{}) *Aws_licensemanager_license_configuration {
	r := &Aws_licensemanager_license_configuration{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_licensemanager_license_configuration_id = &x
}

if x, ok := state["license_count_hard_limit"]; ok {
	x := x.(bool)
	r.License_count_hard_limit = &x
}

if x, ok := state["license_counting_type"]; ok {
	r.License_counting_type = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_licensemanager_license_configurationHandler ...
type Aws_licensemanager_license_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_licensemanager_license_configurationHandler) Create(desired *Aws_licensemanager_license_configuration) (*Aws_licensemanager_license_configuration, string, error) {
	rState := Aws_licensemanager_license_configurationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_licensemanager_license_configuration", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_licensemanager_license_configurationHandler) Read(externalID string) (*Aws_licensemanager_license_configuration, error) {
	actual, err := bridge.Read(h.provider, "aws_licensemanager_license_configuration", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_licensemanager_license_configurationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_licensemanager_license_configurationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_licensemanager_license_configuration", externalID)
}

type Aws_api_gateway_resource struct {
     Aws_api_gateway_resource_id *string
     Rest_api_id string
     Parent_id string
     Path_part string
     Path *string
}


func Aws_api_gateway_resourceMapper(r *Aws_api_gateway_resource) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["rest_api_id"] = r.Rest_api_id
    config["parent_id"] = r.Parent_id
    config["path_part"] = r.Path_part
if r.Path != nil {
    config["path"] = *r.Path
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_resourceUnmapper(state map[string]interface{}) *Aws_api_gateway_resource {
	r := &Aws_api_gateway_resource{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_resource_id = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["parent_id"]; ok {
	r.Parent_id = x.(string)
}

if x, ok := state["path_part"]; ok {
	r.Path_part = x.(string)
}

if x, ok := state["path"]; ok {
	x := x.(string)
	r.Path = &x
}
	return r
}


// Aws_api_gateway_resourceHandler ...
type Aws_api_gateway_resourceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_resourceHandler) Create(desired *Aws_api_gateway_resource) (*Aws_api_gateway_resource, string, error) {
	rState := Aws_api_gateway_resourceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_resource", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_resourceHandler) Read(externalID string) (*Aws_api_gateway_resource, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_resource", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_resourceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_resourceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_resource", externalID)
}

type Aws_glue_security_configuration struct {
     Aws_glue_security_configuration_id *string
     Name string
}


func Aws_glue_security_configurationMapper(r *Aws_glue_security_configuration) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glue_security_configurationUnmapper(state map[string]interface{}) *Aws_glue_security_configuration {
	r := &Aws_glue_security_configuration{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glue_security_configuration_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_glue_security_configurationHandler ...
type Aws_glue_security_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glue_security_configurationHandler) Create(desired *Aws_glue_security_configuration) (*Aws_glue_security_configuration, string, error) {
	rState := Aws_glue_security_configurationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glue_security_configuration", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glue_security_configurationHandler) Read(externalID string) (*Aws_glue_security_configuration, error) {
	actual, err := bridge.Read(h.provider, "aws_glue_security_configuration", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glue_security_configurationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glue_security_configurationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glue_security_configuration", externalID)
}

type Aws_guardduty_ipset struct {
     Aws_guardduty_ipset_id *string
     Detector_id string
     Name string
     Format string
     Location string
     Activate bool
}


func Aws_guardduty_ipsetMapper(r *Aws_guardduty_ipset) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["format"] = r.Format
    config["location"] = r.Location
    config["activate"] = r.Activate
    config["detector_id"] = r.Detector_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_guardduty_ipsetUnmapper(state map[string]interface{}) *Aws_guardduty_ipset {
	r := &Aws_guardduty_ipset{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_guardduty_ipset_id = &x
}

if x, ok := state["detector_id"]; ok {
	r.Detector_id = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["format"]; ok {
	r.Format = x.(string)
}

if x, ok := state["location"]; ok {
	r.Location = x.(string)
}

if x, ok := state["activate"]; ok {
	r.Activate = x.(bool)
}
	return r
}


// Aws_guardduty_ipsetHandler ...
type Aws_guardduty_ipsetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_guardduty_ipsetHandler) Create(desired *Aws_guardduty_ipset) (*Aws_guardduty_ipset, string, error) {
	rState := Aws_guardduty_ipsetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_guardduty_ipset", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_guardduty_ipsetHandler) Read(externalID string) (*Aws_guardduty_ipset, error) {
	actual, err := bridge.Read(h.provider, "aws_guardduty_ipset", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_guardduty_ipsetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_guardduty_ipsetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_guardduty_ipset", externalID)
}

type Aws_lb_listener_certificate struct {
     Aws_lb_listener_certificate_id *string
     Listener_arn string
     Certificate_arn string
}


func Aws_lb_listener_certificateMapper(r *Aws_lb_listener_certificate) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["listener_arn"] = r.Listener_arn
    config["certificate_arn"] = r.Certificate_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lb_listener_certificateUnmapper(state map[string]interface{}) *Aws_lb_listener_certificate {
	r := &Aws_lb_listener_certificate{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lb_listener_certificate_id = &x
}

if x, ok := state["listener_arn"]; ok {
	r.Listener_arn = x.(string)
}

if x, ok := state["certificate_arn"]; ok {
	r.Certificate_arn = x.(string)
}
	return r
}


// Aws_lb_listener_certificateHandler ...
type Aws_lb_listener_certificateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lb_listener_certificateHandler) Create(desired *Aws_lb_listener_certificate) (*Aws_lb_listener_certificate, string, error) {
	rState := Aws_lb_listener_certificateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lb_listener_certificate", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lb_listener_certificateHandler) Read(externalID string) (*Aws_lb_listener_certificate, error) {
	actual, err := bridge.Read(h.provider, "aws_lb_listener_certificate", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lb_listener_certificateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lb_listener_certificateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lb_listener_certificate", externalID)
}

type Aws_acm_certificate_validation struct {
     Aws_acm_certificate_validation_id *string
     Certificate_arn string
}


func Aws_acm_certificate_validationMapper(r *Aws_acm_certificate_validation) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["certificate_arn"] = r.Certificate_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_acm_certificate_validationUnmapper(state map[string]interface{}) *Aws_acm_certificate_validation {
	r := &Aws_acm_certificate_validation{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_acm_certificate_validation_id = &x
}

if x, ok := state["certificate_arn"]; ok {
	r.Certificate_arn = x.(string)
}
	return r
}


// Aws_acm_certificate_validationHandler ...
type Aws_acm_certificate_validationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_acm_certificate_validationHandler) Create(desired *Aws_acm_certificate_validation) (*Aws_acm_certificate_validation, string, error) {
	rState := Aws_acm_certificate_validationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_acm_certificate_validation", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_acm_certificate_validationHandler) Read(externalID string) (*Aws_acm_certificate_validation, error) {
	actual, err := bridge.Read(h.provider, "aws_acm_certificate_validation", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_acm_certificate_validationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_acm_certificate_validationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_acm_certificate_validation", externalID)
}

type Aws_athena_database struct {
     Aws_athena_database_id *string
     Name string
     Bucket string
     Force_destroy *bool
}


func Aws_athena_databaseMapper(r *Aws_athena_database) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Force_destroy != nil {
    config["force_destroy"] = *r.Force_destroy
}
    config["name"] = r.Name
    config["bucket"] = r.Bucket
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_athena_databaseUnmapper(state map[string]interface{}) *Aws_athena_database {
	r := &Aws_athena_database{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_athena_database_id = &x
}

if x, ok := state["bucket"]; ok {
	r.Bucket = x.(string)
}

if x, ok := state["force_destroy"]; ok {
	x := x.(bool)
	r.Force_destroy = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_athena_databaseHandler ...
type Aws_athena_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_athena_databaseHandler) Create(desired *Aws_athena_database) (*Aws_athena_database, string, error) {
	rState := Aws_athena_databaseMapper(desired)
	id, err := bridge.Create(h.provider, "aws_athena_database", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_athena_databaseHandler) Read(externalID string) (*Aws_athena_database, error) {
	actual, err := bridge.Read(h.provider, "aws_athena_database", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_athena_databaseUnmapper(actual), nil
}

// Delete ...
func (h *Aws_athena_databaseHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_athena_database", externalID)
}

type Aws_vpc_endpoint_connection_notification struct {
     Aws_vpc_endpoint_connection_notification_id *string
     Vpc_endpoint_service_id *string
     Vpc_endpoint_id *string
     Connection_notification_arn string
     State *string
     Notification_type *string
}


func Aws_vpc_endpoint_connection_notificationMapper(r *Aws_vpc_endpoint_connection_notification) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.State != nil {
    config["state"] = *r.State
}
if r.Notification_type != nil {
    config["notification_type"] = *r.Notification_type
}
if r.Vpc_endpoint_service_id != nil {
    config["vpc_endpoint_service_id"] = *r.Vpc_endpoint_service_id
}
if r.Vpc_endpoint_id != nil {
    config["vpc_endpoint_id"] = *r.Vpc_endpoint_id
}
    config["connection_notification_arn"] = r.Connection_notification_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_endpoint_connection_notificationUnmapper(state map[string]interface{}) *Aws_vpc_endpoint_connection_notification {
	r := &Aws_vpc_endpoint_connection_notification{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_endpoint_connection_notification_id = &x
}

if x, ok := state["state"]; ok {
	x := x.(string)
	r.State = &x
}

if x, ok := state["notification_type"]; ok {
	x := x.(string)
	r.Notification_type = &x
}

if x, ok := state["vpc_endpoint_service_id"]; ok {
	x := x.(string)
	r.Vpc_endpoint_service_id = &x
}

if x, ok := state["vpc_endpoint_id"]; ok {
	x := x.(string)
	r.Vpc_endpoint_id = &x
}

if x, ok := state["connection_notification_arn"]; ok {
	r.Connection_notification_arn = x.(string)
}
	return r
}


// Aws_vpc_endpoint_connection_notificationHandler ...
type Aws_vpc_endpoint_connection_notificationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_endpoint_connection_notificationHandler) Create(desired *Aws_vpc_endpoint_connection_notification) (*Aws_vpc_endpoint_connection_notification, string, error) {
	rState := Aws_vpc_endpoint_connection_notificationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_endpoint_connection_notification", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_endpoint_connection_notificationHandler) Read(externalID string) (*Aws_vpc_endpoint_connection_notification, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_endpoint_connection_notification", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_endpoint_connection_notificationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_endpoint_connection_notificationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_endpoint_connection_notification", externalID)
}

type Aws_dx_gateway_association struct {
     Aws_dx_gateway_association_id *string
     Dx_gateway_id string
     Vpn_gateway_id string
}


func Aws_dx_gateway_associationMapper(r *Aws_dx_gateway_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["dx_gateway_id"] = r.Dx_gateway_id
    config["vpn_gateway_id"] = r.Vpn_gateway_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_gateway_associationUnmapper(state map[string]interface{}) *Aws_dx_gateway_association {
	r := &Aws_dx_gateway_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_gateway_association_id = &x
}

if x, ok := state["dx_gateway_id"]; ok {
	r.Dx_gateway_id = x.(string)
}

if x, ok := state["vpn_gateway_id"]; ok {
	r.Vpn_gateway_id = x.(string)
}
	return r
}


// Aws_dx_gateway_associationHandler ...
type Aws_dx_gateway_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_gateway_associationHandler) Create(desired *Aws_dx_gateway_association) (*Aws_dx_gateway_association, string, error) {
	rState := Aws_dx_gateway_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_gateway_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_gateway_associationHandler) Read(externalID string) (*Aws_dx_gateway_association, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_gateway_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_gateway_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_gateway_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_gateway_association", externalID)
}

type Aws_elb struct {
     Aws_elb_id *string
     Connection_draining *bool
     Zone_id *string
     Name *string
     Name_prefix *string
     Arn *string
     Internal *bool
     Dns_name *string
     Cross_zone_load_balancing *bool
     Source_security_group *string
     Source_security_group_id *string
     Tags *map[string]string
}


func Aws_elbMapper(r *Aws_elb) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Cross_zone_load_balancing != nil {
    config["cross_zone_load_balancing"] = *r.Cross_zone_load_balancing
}
if r.Dns_name != nil {
    config["dns_name"] = *r.Dns_name
}
if r.Source_security_group != nil {
    config["source_security_group"] = *r.Source_security_group
}
if r.Source_security_group_id != nil {
    config["source_security_group_id"] = *r.Source_security_group_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Connection_draining != nil {
    config["connection_draining"] = *r.Connection_draining
}
if r.Zone_id != nil {
    config["zone_id"] = *r.Zone_id
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Internal != nil {
    config["internal"] = *r.Internal
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elbUnmapper(state map[string]interface{}) *Aws_elb {
	r := &Aws_elb{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elb_id = &x
}

if x, ok := state["connection_draining"]; ok {
	x := x.(bool)
	r.Connection_draining = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["internal"]; ok {
	x := x.(bool)
	r.Internal = &x
}

if x, ok := state["zone_id"]; ok {
	x := x.(string)
	r.Zone_id = &x
}

if x, ok := state["cross_zone_load_balancing"]; ok {
	x := x.(bool)
	r.Cross_zone_load_balancing = &x
}

if x, ok := state["dns_name"]; ok {
	x := x.(string)
	r.Dns_name = &x
}

if x, ok := state["source_security_group"]; ok {
	x := x.(string)
	r.Source_security_group = &x
}

if x, ok := state["source_security_group_id"]; ok {
	x := x.(string)
	r.Source_security_group_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_elbHandler ...
type Aws_elbHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elbHandler) Create(desired *Aws_elb) (*Aws_elb, string, error) {
	rState := Aws_elbMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elb", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elbHandler) Read(externalID string) (*Aws_elb, error) {
	actual, err := bridge.Read(h.provider, "aws_elb", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elbUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elbHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elb", externalID)
}

type Aws_security_group struct {
     Aws_security_group_id *string
     Description *string
     Vpc_id *string
     Owner_id *string
     Name *string
     Arn *string
     Tags *map[string]string
     Revoke_rules_on_delete *bool
     Name_prefix *string
}


func Aws_security_groupMapper(r *Aws_security_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Revoke_rules_on_delete != nil {
    config["revoke_rules_on_delete"] = *r.Revoke_rules_on_delete
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_security_groupUnmapper(state map[string]interface{}) *Aws_security_group {
	r := &Aws_security_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_security_group_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["revoke_rules_on_delete"]; ok {
	x := x.(bool)
	r.Revoke_rules_on_delete = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}
	return r
}


// Aws_security_groupHandler ...
type Aws_security_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_security_groupHandler) Create(desired *Aws_security_group) (*Aws_security_group, string, error) {
	rState := Aws_security_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_security_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_security_groupHandler) Read(externalID string) (*Aws_security_group, error) {
	actual, err := bridge.Read(h.provider, "aws_security_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_security_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_security_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_security_group", externalID)
}

type Aws_spot_fleet_request struct {
     Aws_spot_fleet_request_id *string
     Replace_unhealthy_instances *bool
     Wait_for_fulfillment *bool
     Instance_interruption_behaviour *string
     Spot_request_state *string
     Valid_from *string
     Fleet_type *string
     Client_token *string
     Iam_fleet_role string
     Allocation_strategy *string
     Excess_capacity_termination_policy *string
     Spot_price *string
     Terminate_instances_with_expiration *bool
     Valid_until *string
}


func Aws_spot_fleet_requestMapper(r *Aws_spot_fleet_request) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Spot_request_state != nil {
    config["spot_request_state"] = *r.Spot_request_state
}
if r.Valid_from != nil {
    config["valid_from"] = *r.Valid_from
}
if r.Allocation_strategy != nil {
    config["allocation_strategy"] = *r.Allocation_strategy
}
if r.Excess_capacity_termination_policy != nil {
    config["excess_capacity_termination_policy"] = *r.Excess_capacity_termination_policy
}
if r.Spot_price != nil {
    config["spot_price"] = *r.Spot_price
}
if r.Terminate_instances_with_expiration != nil {
    config["terminate_instances_with_expiration"] = *r.Terminate_instances_with_expiration
}
if r.Valid_until != nil {
    config["valid_until"] = *r.Valid_until
}
if r.Fleet_type != nil {
    config["fleet_type"] = *r.Fleet_type
}
if r.Client_token != nil {
    config["client_token"] = *r.Client_token
}
    config["iam_fleet_role"] = r.Iam_fleet_role
if r.Wait_for_fulfillment != nil {
    config["wait_for_fulfillment"] = *r.Wait_for_fulfillment
}
if r.Instance_interruption_behaviour != nil {
    config["instance_interruption_behaviour"] = *r.Instance_interruption_behaviour
}
if r.Replace_unhealthy_instances != nil {
    config["replace_unhealthy_instances"] = *r.Replace_unhealthy_instances
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_spot_fleet_requestUnmapper(state map[string]interface{}) *Aws_spot_fleet_request {
	r := &Aws_spot_fleet_request{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_spot_fleet_request_id = &x
}

if x, ok := state["valid_from"]; ok {
	x := x.(string)
	r.Valid_from = &x
}

if x, ok := state["iam_fleet_role"]; ok {
	r.Iam_fleet_role = x.(string)
}

if x, ok := state["allocation_strategy"]; ok {
	x := x.(string)
	r.Allocation_strategy = &x
}

if x, ok := state["excess_capacity_termination_policy"]; ok {
	x := x.(string)
	r.Excess_capacity_termination_policy = &x
}

if x, ok := state["spot_price"]; ok {
	x := x.(string)
	r.Spot_price = &x
}

if x, ok := state["terminate_instances_with_expiration"]; ok {
	x := x.(bool)
	r.Terminate_instances_with_expiration = &x
}

if x, ok := state["valid_until"]; ok {
	x := x.(string)
	r.Valid_until = &x
}

if x, ok := state["fleet_type"]; ok {
	x := x.(string)
	r.Fleet_type = &x
}

if x, ok := state["client_token"]; ok {
	x := x.(string)
	r.Client_token = &x
}

if x, ok := state["replace_unhealthy_instances"]; ok {
	x := x.(bool)
	r.Replace_unhealthy_instances = &x
}

if x, ok := state["wait_for_fulfillment"]; ok {
	x := x.(bool)
	r.Wait_for_fulfillment = &x
}

if x, ok := state["instance_interruption_behaviour"]; ok {
	x := x.(string)
	r.Instance_interruption_behaviour = &x
}

if x, ok := state["spot_request_state"]; ok {
	x := x.(string)
	r.Spot_request_state = &x
}
	return r
}


// Aws_spot_fleet_requestHandler ...
type Aws_spot_fleet_requestHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_spot_fleet_requestHandler) Create(desired *Aws_spot_fleet_request) (*Aws_spot_fleet_request, string, error) {
	rState := Aws_spot_fleet_requestMapper(desired)
	id, err := bridge.Create(h.provider, "aws_spot_fleet_request", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_spot_fleet_requestHandler) Read(externalID string) (*Aws_spot_fleet_request, error) {
	actual, err := bridge.Read(h.provider, "aws_spot_fleet_request", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_spot_fleet_requestUnmapper(actual), nil
}

// Delete ...
func (h *Aws_spot_fleet_requestHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_spot_fleet_request", externalID)
}

type Aws_dx_public_virtual_interface struct {
     Aws_dx_public_virtual_interface_id *string
     Arn *string
     Bgp_auth_key *string
     Amazon_address *string
     Tags *map[string]string
     Connection_id string
     Name string
     Address_family string
     Customer_address *string
}


func Aws_dx_public_virtual_interfaceMapper(r *Aws_dx_public_virtual_interface) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["connection_id"] = r.Connection_id
    config["name"] = r.Name
    config["address_family"] = r.Address_family
if r.Customer_address != nil {
    config["customer_address"] = *r.Customer_address
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Bgp_auth_key != nil {
    config["bgp_auth_key"] = *r.Bgp_auth_key
}
if r.Amazon_address != nil {
    config["amazon_address"] = *r.Amazon_address
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_public_virtual_interfaceUnmapper(state map[string]interface{}) *Aws_dx_public_virtual_interface {
	r := &Aws_dx_public_virtual_interface{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_public_virtual_interface_id = &x
}

if x, ok := state["bgp_auth_key"]; ok {
	x := x.(string)
	r.Bgp_auth_key = &x
}

if x, ok := state["amazon_address"]; ok {
	x := x.(string)
	r.Amazon_address = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["address_family"]; ok {
	r.Address_family = x.(string)
}

if x, ok := state["customer_address"]; ok {
	x := x.(string)
	r.Customer_address = &x
}

if x, ok := state["connection_id"]; ok {
	r.Connection_id = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_dx_public_virtual_interfaceHandler ...
type Aws_dx_public_virtual_interfaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_public_virtual_interfaceHandler) Create(desired *Aws_dx_public_virtual_interface) (*Aws_dx_public_virtual_interface, string, error) {
	rState := Aws_dx_public_virtual_interfaceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_public_virtual_interface", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_public_virtual_interfaceHandler) Read(externalID string) (*Aws_dx_public_virtual_interface, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_public_virtual_interface", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_public_virtual_interfaceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_public_virtual_interfaceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_public_virtual_interface", externalID)
}

type Aws_route_table struct {
     Aws_route_table_id *string
     Vpc_id string
     Tags *map[string]string
     Owner_id *string
}


func Aws_route_tableMapper(r *Aws_route_table) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_id"] = r.Vpc_id
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_route_tableUnmapper(state map[string]interface{}) *Aws_route_table {
	r := &Aws_route_table{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_route_table_id = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}
	return r
}


// Aws_route_tableHandler ...
type Aws_route_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_route_tableHandler) Create(desired *Aws_route_table) (*Aws_route_table, string, error) {
	rState := Aws_route_tableMapper(desired)
	id, err := bridge.Create(h.provider, "aws_route_table", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_route_tableHandler) Read(externalID string) (*Aws_route_table, error) {
	actual, err := bridge.Read(h.provider, "aws_route_table", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_route_tableUnmapper(actual), nil
}

// Delete ...
func (h *Aws_route_tableHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_route_table", externalID)
}

type Aws_iot_thing_type struct {
     Aws_iot_thing_type_id *string
     Deprecated *bool
     Arn *string
     Name string
}


func Aws_iot_thing_typeMapper(r *Aws_iot_thing_type) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
if r.Deprecated != nil {
    config["deprecated"] = *r.Deprecated
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iot_thing_typeUnmapper(state map[string]interface{}) *Aws_iot_thing_type {
	r := &Aws_iot_thing_type{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iot_thing_type_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["deprecated"]; ok {
	x := x.(bool)
	r.Deprecated = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_iot_thing_typeHandler ...
type Aws_iot_thing_typeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iot_thing_typeHandler) Create(desired *Aws_iot_thing_type) (*Aws_iot_thing_type, string, error) {
	rState := Aws_iot_thing_typeMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iot_thing_type", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iot_thing_typeHandler) Read(externalID string) (*Aws_iot_thing_type, error) {
	actual, err := bridge.Read(h.provider, "aws_iot_thing_type", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iot_thing_typeUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iot_thing_typeHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iot_thing_type", externalID)
}

type Aws_cloudwatch_log_resource_policy struct {
     Aws_cloudwatch_log_resource_policy_id *string
     Policy_name string
     Policy_document string
}


func Aws_cloudwatch_log_resource_policyMapper(r *Aws_cloudwatch_log_resource_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["policy_name"] = r.Policy_name
    config["policy_document"] = r.Policy_document
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_log_resource_policyUnmapper(state map[string]interface{}) *Aws_cloudwatch_log_resource_policy {
	r := &Aws_cloudwatch_log_resource_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_log_resource_policy_id = &x
}

if x, ok := state["policy_name"]; ok {
	r.Policy_name = x.(string)
}

if x, ok := state["policy_document"]; ok {
	r.Policy_document = x.(string)
}
	return r
}


// Aws_cloudwatch_log_resource_policyHandler ...
type Aws_cloudwatch_log_resource_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_log_resource_policyHandler) Create(desired *Aws_cloudwatch_log_resource_policy) (*Aws_cloudwatch_log_resource_policy, string, error) {
	rState := Aws_cloudwatch_log_resource_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_log_resource_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_log_resource_policyHandler) Read(externalID string) (*Aws_cloudwatch_log_resource_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_log_resource_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_log_resource_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_log_resource_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_log_resource_policy", externalID)
}

type Aws_opsworks_rails_app_layer struct {
     Aws_opsworks_rails_app_layer_id *string
     Ruby_version *string
     Passenger_version *string
     Rubygems_version *string
     Auto_assign_public_ips *bool
     Custom_json *string
     Name *string
     Install_updates_on_boot *bool
     Stack_id string
     Drain_elb_on_shutdown *bool
     Use_ebs_optimized_instances *bool
     Bundler_version *string
     Auto_assign_elastic_ips *bool
     Custom_instance_profile_arn *string
     Elastic_load_balancer *string
     Manage_bundler *bool
     Auto_healing *bool
     App_server *string
}


func Aws_opsworks_rails_app_layerMapper(r *Aws_opsworks_rails_app_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name != nil {
    config["name"] = *r.Name
}
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
    config["stack_id"] = r.Stack_id
if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
if r.Bundler_version != nil {
    config["bundler_version"] = *r.Bundler_version
}
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
if r.App_server != nil {
    config["app_server"] = *r.App_server
}
if r.Manage_bundler != nil {
    config["manage_bundler"] = *r.Manage_bundler
}
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Ruby_version != nil {
    config["ruby_version"] = *r.Ruby_version
}
if r.Passenger_version != nil {
    config["passenger_version"] = *r.Passenger_version
}
if r.Rubygems_version != nil {
    config["rubygems_version"] = *r.Rubygems_version
}
if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_rails_app_layerUnmapper(state map[string]interface{}) *Aws_opsworks_rails_app_layer {
	r := &Aws_opsworks_rails_app_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_rails_app_layer_id = &x
}

if x, ok := state["rubygems_version"]; ok {
	x := x.(string)
	r.Rubygems_version = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["ruby_version"]; ok {
	x := x.(string)
	r.Ruby_version = &x
}

if x, ok := state["passenger_version"]; ok {
	x := x.(string)
	r.Passenger_version = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["bundler_version"]; ok {
	x := x.(string)
	r.Bundler_version = &x
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}

if x, ok := state["app_server"]; ok {
	x := x.(string)
	r.App_server = &x
}

if x, ok := state["manage_bundler"]; ok {
	x := x.(bool)
	r.Manage_bundler = &x
}
	return r
}


// Aws_opsworks_rails_app_layerHandler ...
type Aws_opsworks_rails_app_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_rails_app_layerHandler) Create(desired *Aws_opsworks_rails_app_layer) (*Aws_opsworks_rails_app_layer, string, error) {
	rState := Aws_opsworks_rails_app_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_rails_app_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_rails_app_layerHandler) Read(externalID string) (*Aws_opsworks_rails_app_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_rails_app_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_rails_app_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_rails_app_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_rails_app_layer", externalID)
}

type Aws_transfer_ssh_key struct {
     Aws_transfer_ssh_key_id *string
     Body string
     Server_id string
     User_name string
}


func Aws_transfer_ssh_keyMapper(r *Aws_transfer_ssh_key) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["body"] = r.Body
    config["server_id"] = r.Server_id
    config["user_name"] = r.User_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_transfer_ssh_keyUnmapper(state map[string]interface{}) *Aws_transfer_ssh_key {
	r := &Aws_transfer_ssh_key{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_transfer_ssh_key_id = &x
}

if x, ok := state["body"]; ok {
	r.Body = x.(string)
}

if x, ok := state["server_id"]; ok {
	r.Server_id = x.(string)
}

if x, ok := state["user_name"]; ok {
	r.User_name = x.(string)
}
	return r
}


// Aws_transfer_ssh_keyHandler ...
type Aws_transfer_ssh_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_transfer_ssh_keyHandler) Create(desired *Aws_transfer_ssh_key) (*Aws_transfer_ssh_key, string, error) {
	rState := Aws_transfer_ssh_keyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_transfer_ssh_key", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_transfer_ssh_keyHandler) Read(externalID string) (*Aws_transfer_ssh_key, error) {
	actual, err := bridge.Read(h.provider, "aws_transfer_ssh_key", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_transfer_ssh_keyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_transfer_ssh_keyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_transfer_ssh_key", externalID)
}

type Aws_network_acl_rule struct {
     Aws_network_acl_rule_id *string
     Egress *bool
     Rule_action string
     Icmp_type *string
     Icmp_code *string
     Network_acl_id string
     Ipv6_cidr_block *string
     Protocol string
     Cidr_block *string
}


func Aws_network_acl_ruleMapper(r *Aws_network_acl_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["protocol"] = r.Protocol
if r.Cidr_block != nil {
    config["cidr_block"] = *r.Cidr_block
}
if r.Ipv6_cidr_block != nil {
    config["ipv6_cidr_block"] = *r.Ipv6_cidr_block
}
if r.Icmp_type != nil {
    config["icmp_type"] = *r.Icmp_type
}
if r.Icmp_code != nil {
    config["icmp_code"] = *r.Icmp_code
}
    config["network_acl_id"] = r.Network_acl_id
if r.Egress != nil {
    config["egress"] = *r.Egress
}
    config["rule_action"] = r.Rule_action
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_network_acl_ruleUnmapper(state map[string]interface{}) *Aws_network_acl_rule {
	r := &Aws_network_acl_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_network_acl_rule_id = &x
}

if x, ok := state["protocol"]; ok {
	r.Protocol = x.(string)
}

if x, ok := state["cidr_block"]; ok {
	x := x.(string)
	r.Cidr_block = &x
}

if x, ok := state["ipv6_cidr_block"]; ok {
	x := x.(string)
	r.Ipv6_cidr_block = &x
}

if x, ok := state["icmp_code"]; ok {
	x := x.(string)
	r.Icmp_code = &x
}

if x, ok := state["network_acl_id"]; ok {
	r.Network_acl_id = x.(string)
}

if x, ok := state["egress"]; ok {
	x := x.(bool)
	r.Egress = &x
}

if x, ok := state["rule_action"]; ok {
	r.Rule_action = x.(string)
}

if x, ok := state["icmp_type"]; ok {
	x := x.(string)
	r.Icmp_type = &x
}
	return r
}


// Aws_network_acl_ruleHandler ...
type Aws_network_acl_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_network_acl_ruleHandler) Create(desired *Aws_network_acl_rule) (*Aws_network_acl_rule, string, error) {
	rState := Aws_network_acl_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_network_acl_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_network_acl_ruleHandler) Read(externalID string) (*Aws_network_acl_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_network_acl_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_network_acl_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_network_acl_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_network_acl_rule", externalID)
}

type Aws_opsworks_permission struct {
     Aws_opsworks_permission_id *string
     Allow_ssh *bool
     Allow_sudo *bool
     User_arn string
     Level *string
     Stack_id *string
}


func Aws_opsworks_permissionMapper(r *Aws_opsworks_permission) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Level != nil {
    config["level"] = *r.Level
}
if r.Stack_id != nil {
    config["stack_id"] = *r.Stack_id
}
if r.Allow_ssh != nil {
    config["allow_ssh"] = *r.Allow_ssh
}
if r.Allow_sudo != nil {
    config["allow_sudo"] = *r.Allow_sudo
}
    config["user_arn"] = r.User_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_permissionUnmapper(state map[string]interface{}) *Aws_opsworks_permission {
	r := &Aws_opsworks_permission{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_permission_id = &x
}

if x, ok := state["allow_ssh"]; ok {
	x := x.(bool)
	r.Allow_ssh = &x
}

if x, ok := state["allow_sudo"]; ok {
	x := x.(bool)
	r.Allow_sudo = &x
}

if x, ok := state["user_arn"]; ok {
	r.User_arn = x.(string)
}

if x, ok := state["level"]; ok {
	x := x.(string)
	r.Level = &x
}

if x, ok := state["stack_id"]; ok {
	x := x.(string)
	r.Stack_id = &x
}
	return r
}


// Aws_opsworks_permissionHandler ...
type Aws_opsworks_permissionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_permissionHandler) Create(desired *Aws_opsworks_permission) (*Aws_opsworks_permission, string, error) {
	rState := Aws_opsworks_permissionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_permission", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_permissionHandler) Read(externalID string) (*Aws_opsworks_permission, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_permission", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_permissionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_permissionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_permission", externalID)
}

type Aws_pinpoint_apns_voip_channel struct {
     Aws_pinpoint_apns_voip_channel_id *string
     Private_key *string
     Team_id *string
     Application_id string
     Certificate *string
     Default_authentication_method *string
     Enabled *bool
     Token_key *string
     Token_key_id *string
     Bundle_id *string
}


func Aws_pinpoint_apns_voip_channelMapper(r *Aws_pinpoint_apns_voip_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Team_id != nil {
    config["team_id"] = *r.Team_id
}
    config["application_id"] = r.Application_id
if r.Private_key != nil {
    config["private_key"] = *r.Private_key
}
if r.Default_authentication_method != nil {
    config["default_authentication_method"] = *r.Default_authentication_method
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.Token_key != nil {
    config["token_key"] = *r.Token_key
}
if r.Token_key_id != nil {
    config["token_key_id"] = *r.Token_key_id
}
if r.Bundle_id != nil {
    config["bundle_id"] = *r.Bundle_id
}
if r.Certificate != nil {
    config["certificate"] = *r.Certificate
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_apns_voip_channelUnmapper(state map[string]interface{}) *Aws_pinpoint_apns_voip_channel {
	r := &Aws_pinpoint_apns_voip_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_apns_voip_channel_id = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["token_key"]; ok {
	x := x.(string)
	r.Token_key = &x
}

if x, ok := state["token_key_id"]; ok {
	x := x.(string)
	r.Token_key_id = &x
}

if x, ok := state["bundle_id"]; ok {
	x := x.(string)
	r.Bundle_id = &x
}

if x, ok := state["certificate"]; ok {
	x := x.(string)
	r.Certificate = &x
}

if x, ok := state["default_authentication_method"]; ok {
	x := x.(string)
	r.Default_authentication_method = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["private_key"]; ok {
	x := x.(string)
	r.Private_key = &x
}

if x, ok := state["team_id"]; ok {
	x := x.(string)
	r.Team_id = &x
}
	return r
}


// Aws_pinpoint_apns_voip_channelHandler ...
type Aws_pinpoint_apns_voip_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_apns_voip_channelHandler) Create(desired *Aws_pinpoint_apns_voip_channel) (*Aws_pinpoint_apns_voip_channel, string, error) {
	rState := Aws_pinpoint_apns_voip_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_apns_voip_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_apns_voip_channelHandler) Read(externalID string) (*Aws_pinpoint_apns_voip_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_apns_voip_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_apns_voip_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_apns_voip_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_apns_voip_channel", externalID)
}

type Aws_codepipeline_webhook struct {
     Aws_codepipeline_webhook_id *string
     Url *string
     Target_action string
     Target_pipeline string
     Authentication string
     Name string
}


func Aws_codepipeline_webhookMapper(r *Aws_codepipeline_webhook) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Url != nil {
    config["url"] = *r.Url
}
    config["target_action"] = r.Target_action
    config["target_pipeline"] = r.Target_pipeline
    config["authentication"] = r.Authentication
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_codepipeline_webhookUnmapper(state map[string]interface{}) *Aws_codepipeline_webhook {
	r := &Aws_codepipeline_webhook{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_codepipeline_webhook_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["url"]; ok {
	x := x.(string)
	r.Url = &x
}

if x, ok := state["target_action"]; ok {
	r.Target_action = x.(string)
}

if x, ok := state["target_pipeline"]; ok {
	r.Target_pipeline = x.(string)
}

if x, ok := state["authentication"]; ok {
	r.Authentication = x.(string)
}
	return r
}


// Aws_codepipeline_webhookHandler ...
type Aws_codepipeline_webhookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_codepipeline_webhookHandler) Create(desired *Aws_codepipeline_webhook) (*Aws_codepipeline_webhook, string, error) {
	rState := Aws_codepipeline_webhookMapper(desired)
	id, err := bridge.Create(h.provider, "aws_codepipeline_webhook", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_codepipeline_webhookHandler) Read(externalID string) (*Aws_codepipeline_webhook, error) {
	actual, err := bridge.Read(h.provider, "aws_codepipeline_webhook", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_codepipeline_webhookUnmapper(actual), nil
}

// Delete ...
func (h *Aws_codepipeline_webhookHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_codepipeline_webhook", externalID)
}

type Aws_elastic_beanstalk_application_version struct {
     Aws_elastic_beanstalk_application_version_id *string
     Name string
     Force_delete *bool
     Application string
     Description *string
     Bucket string
     Key string
}


func Aws_elastic_beanstalk_application_versionMapper(r *Aws_elastic_beanstalk_application_version) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["application"] = r.Application
if r.Description != nil {
    config["description"] = *r.Description
}
    config["bucket"] = r.Bucket
    config["key"] = r.Key
    config["name"] = r.Name
if r.Force_delete != nil {
    config["force_delete"] = *r.Force_delete
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elastic_beanstalk_application_versionUnmapper(state map[string]interface{}) *Aws_elastic_beanstalk_application_version {
	r := &Aws_elastic_beanstalk_application_version{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elastic_beanstalk_application_version_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["bucket"]; ok {
	r.Bucket = x.(string)
}

if x, ok := state["key"]; ok {
	r.Key = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["force_delete"]; ok {
	x := x.(bool)
	r.Force_delete = &x
}

if x, ok := state["application"]; ok {
	r.Application = x.(string)
}
	return r
}


// Aws_elastic_beanstalk_application_versionHandler ...
type Aws_elastic_beanstalk_application_versionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elastic_beanstalk_application_versionHandler) Create(desired *Aws_elastic_beanstalk_application_version) (*Aws_elastic_beanstalk_application_version, string, error) {
	rState := Aws_elastic_beanstalk_application_versionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elastic_beanstalk_application_version", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elastic_beanstalk_application_versionHandler) Read(externalID string) (*Aws_elastic_beanstalk_application_version, error) {
	actual, err := bridge.Read(h.provider, "aws_elastic_beanstalk_application_version", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elastic_beanstalk_application_versionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elastic_beanstalk_application_versionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elastic_beanstalk_application_version", externalID)
}

type Aws_emr_security_configuration struct {
     Aws_emr_security_configuration_id *string
     Name *string
     Name_prefix *string
     Configuration string
     Creation_date *string
}


func Aws_emr_security_configurationMapper(r *Aws_emr_security_configuration) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["configuration"] = r.Configuration
if r.Creation_date != nil {
    config["creation_date"] = *r.Creation_date
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_emr_security_configurationUnmapper(state map[string]interface{}) *Aws_emr_security_configuration {
	r := &Aws_emr_security_configuration{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_emr_security_configuration_id = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["configuration"]; ok {
	r.Configuration = x.(string)
}

if x, ok := state["creation_date"]; ok {
	x := x.(string)
	r.Creation_date = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}
	return r
}


// Aws_emr_security_configurationHandler ...
type Aws_emr_security_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_emr_security_configurationHandler) Create(desired *Aws_emr_security_configuration) (*Aws_emr_security_configuration, string, error) {
	rState := Aws_emr_security_configurationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_emr_security_configuration", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_emr_security_configurationHandler) Read(externalID string) (*Aws_emr_security_configuration, error) {
	actual, err := bridge.Read(h.provider, "aws_emr_security_configuration", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_emr_security_configurationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_emr_security_configurationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_emr_security_configuration", externalID)
}

type Aws_iot_policy struct {
     Aws_iot_policy_id *string
     Name string
     Policy string
     Arn *string
     Default_version_id *string
}


func Aws_iot_policyMapper(r *Aws_iot_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["policy"] = r.Policy
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Default_version_id != nil {
    config["default_version_id"] = *r.Default_version_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iot_policyUnmapper(state map[string]interface{}) *Aws_iot_policy {
	r := &Aws_iot_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iot_policy_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["default_version_id"]; ok {
	x := x.(string)
	r.Default_version_id = &x
}
	return r
}


// Aws_iot_policyHandler ...
type Aws_iot_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iot_policyHandler) Create(desired *Aws_iot_policy) (*Aws_iot_policy, string, error) {
	rState := Aws_iot_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iot_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iot_policyHandler) Read(externalID string) (*Aws_iot_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_iot_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iot_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iot_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iot_policy", externalID)
}

type Aws_dms_replication_instance struct {
     Aws_dms_replication_instance_id *string
     Engine_version *string
     Kms_key_arn *string
     Auto_minor_version_upgrade *bool
     Replication_subnet_group_id *string
     Tags *map[string]string
     Multi_az *bool
     Publicly_accessible *bool
     Replication_instance_arn *string
     Replication_instance_class string
     Replication_instance_id string
     Apply_immediately *bool
     Availability_zone *string
     Preferred_maintenance_window *string
}


func Aws_dms_replication_instanceMapper(r *Aws_dms_replication_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Kms_key_arn != nil {
    config["kms_key_arn"] = *r.Kms_key_arn
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Replication_subnet_group_id != nil {
    config["replication_subnet_group_id"] = *r.Replication_subnet_group_id
}
if r.Auto_minor_version_upgrade != nil {
    config["auto_minor_version_upgrade"] = *r.Auto_minor_version_upgrade
}
if r.Publicly_accessible != nil {
    config["publicly_accessible"] = *r.Publicly_accessible
}
if r.Replication_instance_arn != nil {
    config["replication_instance_arn"] = *r.Replication_instance_arn
}
    config["replication_instance_class"] = r.Replication_instance_class
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Multi_az != nil {
    config["multi_az"] = *r.Multi_az
}
if r.Apply_immediately != nil {
    config["apply_immediately"] = *r.Apply_immediately
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Preferred_maintenance_window != nil {
    config["preferred_maintenance_window"] = *r.Preferred_maintenance_window
}
    config["replication_instance_id"] = r.Replication_instance_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dms_replication_instanceUnmapper(state map[string]interface{}) *Aws_dms_replication_instance {
	r := &Aws_dms_replication_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dms_replication_instance_id = &x
}

if x, ok := state["replication_subnet_group_id"]; ok {
	x := x.(string)
	r.Replication_subnet_group_id = &x
}

if x, ok := state["auto_minor_version_upgrade"]; ok {
	x := x.(bool)
	r.Auto_minor_version_upgrade = &x
}

if x, ok := state["replication_instance_arn"]; ok {
	x := x.(string)
	r.Replication_instance_arn = &x
}

if x, ok := state["replication_instance_class"]; ok {
	r.Replication_instance_class = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["multi_az"]; ok {
	x := x.(bool)
	r.Multi_az = &x
}

if x, ok := state["publicly_accessible"]; ok {
	x := x.(bool)
	r.Publicly_accessible = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["preferred_maintenance_window"]; ok {
	x := x.(string)
	r.Preferred_maintenance_window = &x
}

if x, ok := state["replication_instance_id"]; ok {
	r.Replication_instance_id = x.(string)
}

if x, ok := state["apply_immediately"]; ok {
	x := x.(bool)
	r.Apply_immediately = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["kms_key_arn"]; ok {
	x := x.(string)
	r.Kms_key_arn = &x
}
	return r
}


// Aws_dms_replication_instanceHandler ...
type Aws_dms_replication_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dms_replication_instanceHandler) Create(desired *Aws_dms_replication_instance) (*Aws_dms_replication_instance, string, error) {
	rState := Aws_dms_replication_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dms_replication_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dms_replication_instanceHandler) Read(externalID string) (*Aws_dms_replication_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_dms_replication_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dms_replication_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dms_replication_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dms_replication_instance", externalID)
}

type Aws_dx_hosted_private_virtual_interface struct {
     Aws_dx_hosted_private_virtual_interface_id *string
     Arn *string
     Connection_id string
     Customer_address *string
     Owner_account_id string
     Name string
     Bgp_auth_key *string
     Address_family string
     Amazon_address *string
     Jumbo_frame_capable *bool
}


func Aws_dx_hosted_private_virtual_interfaceMapper(r *Aws_dx_hosted_private_virtual_interface) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["connection_id"] = r.Connection_id
if r.Customer_address != nil {
    config["customer_address"] = *r.Customer_address
}
    config["owner_account_id"] = r.Owner_account_id
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Bgp_auth_key != nil {
    config["bgp_auth_key"] = *r.Bgp_auth_key
}
    config["address_family"] = r.Address_family
if r.Amazon_address != nil {
    config["amazon_address"] = *r.Amazon_address
}
if r.Jumbo_frame_capable != nil {
    config["jumbo_frame_capable"] = *r.Jumbo_frame_capable
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_hosted_private_virtual_interfaceUnmapper(state map[string]interface{}) *Aws_dx_hosted_private_virtual_interface {
	r := &Aws_dx_hosted_private_virtual_interface{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_hosted_private_virtual_interface_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["connection_id"]; ok {
	r.Connection_id = x.(string)
}

if x, ok := state["customer_address"]; ok {
	x := x.(string)
	r.Customer_address = &x
}

if x, ok := state["owner_account_id"]; ok {
	r.Owner_account_id = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["bgp_auth_key"]; ok {
	x := x.(string)
	r.Bgp_auth_key = &x
}

if x, ok := state["address_family"]; ok {
	r.Address_family = x.(string)
}

if x, ok := state["amazon_address"]; ok {
	x := x.(string)
	r.Amazon_address = &x
}

if x, ok := state["jumbo_frame_capable"]; ok {
	x := x.(bool)
	r.Jumbo_frame_capable = &x
}
	return r
}


// Aws_dx_hosted_private_virtual_interfaceHandler ...
type Aws_dx_hosted_private_virtual_interfaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_hosted_private_virtual_interfaceHandler) Create(desired *Aws_dx_hosted_private_virtual_interface) (*Aws_dx_hosted_private_virtual_interface, string, error) {
	rState := Aws_dx_hosted_private_virtual_interfaceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_hosted_private_virtual_interface", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_hosted_private_virtual_interfaceHandler) Read(externalID string) (*Aws_dx_hosted_private_virtual_interface, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_hosted_private_virtual_interface", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_hosted_private_virtual_interfaceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_hosted_private_virtual_interfaceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_hosted_private_virtual_interface", externalID)
}

type Aws_pinpoint_baidu_channel struct {
     Aws_pinpoint_baidu_channel_id *string
     Api_key string
     Secret_key string
     Application_id string
     Enabled *bool
}


func Aws_pinpoint_baidu_channelMapper(r *Aws_pinpoint_baidu_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["application_id"] = r.Application_id
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
    config["api_key"] = r.Api_key
    config["secret_key"] = r.Secret_key
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_baidu_channelUnmapper(state map[string]interface{}) *Aws_pinpoint_baidu_channel {
	r := &Aws_pinpoint_baidu_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_baidu_channel_id = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["api_key"]; ok {
	r.Api_key = x.(string)
}

if x, ok := state["secret_key"]; ok {
	r.Secret_key = x.(string)
}
	return r
}


// Aws_pinpoint_baidu_channelHandler ...
type Aws_pinpoint_baidu_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_baidu_channelHandler) Create(desired *Aws_pinpoint_baidu_channel) (*Aws_pinpoint_baidu_channel, string, error) {
	rState := Aws_pinpoint_baidu_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_baidu_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_baidu_channelHandler) Read(externalID string) (*Aws_pinpoint_baidu_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_baidu_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_baidu_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_baidu_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_baidu_channel", externalID)
}

type Aws_api_gateway_integration_response struct {
     Aws_api_gateway_integration_response_id *string
     Resource_id string
     Status_code string
     Selection_pattern *string
     Content_handling *string
     Rest_api_id string
     Response_templates *map[string]string
     Response_parameters *map[string]string
     Response_parameters_in_json *string
     Http_method string
}


func Aws_api_gateway_integration_responseMapper(r *Aws_api_gateway_integration_response) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["rest_api_id"] = r.Rest_api_id
    config["resource_id"] = r.Resource_id
    config["status_code"] = r.Status_code
if r.Selection_pattern != nil {
    config["selection_pattern"] = *r.Selection_pattern
}
if r.Content_handling != nil {
    config["content_handling"] = *r.Content_handling
}
    config["http_method"] = r.Http_method
if r.Response_templates != nil {
    config["response_templates"] = *r.Response_templates
}
if r.Response_parameters != nil {
    config["response_parameters"] = *r.Response_parameters
}
if r.Response_parameters_in_json != nil {
    config["response_parameters_in_json"] = *r.Response_parameters_in_json
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_integration_responseUnmapper(state map[string]interface{}) *Aws_api_gateway_integration_response {
	r := &Aws_api_gateway_integration_response{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_integration_response_id = &x
}

if x, ok := state["content_handling"]; ok {
	x := x.(string)
	r.Content_handling = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["resource_id"]; ok {
	r.Resource_id = x.(string)
}

if x, ok := state["status_code"]; ok {
	r.Status_code = x.(string)
}

if x, ok := state["selection_pattern"]; ok {
	x := x.(string)
	r.Selection_pattern = &x
}

if x, ok := state["http_method"]; ok {
	r.Http_method = x.(string)
}

if x, ok := state["response_templates"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Response_templates = &x
}

if x, ok := state["response_parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Response_parameters = &x
}

if x, ok := state["response_parameters_in_json"]; ok {
	x := x.(string)
	r.Response_parameters_in_json = &x
}
	return r
}


// Aws_api_gateway_integration_responseHandler ...
type Aws_api_gateway_integration_responseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_integration_responseHandler) Create(desired *Aws_api_gateway_integration_response) (*Aws_api_gateway_integration_response, string, error) {
	rState := Aws_api_gateway_integration_responseMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_integration_response", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_integration_responseHandler) Read(externalID string) (*Aws_api_gateway_integration_response, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_integration_response", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_integration_responseUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_integration_responseHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_integration_response", externalID)
}

type Aws_vpc_peering_connection_options struct {
     Aws_vpc_peering_connection_options_id *string
     Vpc_peering_connection_id string
}


func Aws_vpc_peering_connection_optionsMapper(r *Aws_vpc_peering_connection_options) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_peering_connection_id"] = r.Vpc_peering_connection_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_peering_connection_optionsUnmapper(state map[string]interface{}) *Aws_vpc_peering_connection_options {
	r := &Aws_vpc_peering_connection_options{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_peering_connection_options_id = &x
}

if x, ok := state["vpc_peering_connection_id"]; ok {
	r.Vpc_peering_connection_id = x.(string)
}
	return r
}


// Aws_vpc_peering_connection_optionsHandler ...
type Aws_vpc_peering_connection_optionsHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_peering_connection_optionsHandler) Create(desired *Aws_vpc_peering_connection_options) (*Aws_vpc_peering_connection_options, string, error) {
	rState := Aws_vpc_peering_connection_optionsMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_peering_connection_options", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_peering_connection_optionsHandler) Read(externalID string) (*Aws_vpc_peering_connection_options, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_peering_connection_options", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_peering_connection_optionsUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_peering_connection_optionsHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_peering_connection_options", externalID)
}

type Aws_ec2_transit_gateway_route struct {
     Aws_ec2_transit_gateway_route_id *string
     Destination_cidr_block string
     Transit_gateway_attachment_id string
     Transit_gateway_route_table_id string
}


func Aws_ec2_transit_gateway_routeMapper(r *Aws_ec2_transit_gateway_route) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["transit_gateway_route_table_id"] = r.Transit_gateway_route_table_id
    config["destination_cidr_block"] = r.Destination_cidr_block
    config["transit_gateway_attachment_id"] = r.Transit_gateway_attachment_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ec2_transit_gateway_routeUnmapper(state map[string]interface{}) *Aws_ec2_transit_gateway_route {
	r := &Aws_ec2_transit_gateway_route{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ec2_transit_gateway_route_id = &x
}

if x, ok := state["destination_cidr_block"]; ok {
	r.Destination_cidr_block = x.(string)
}

if x, ok := state["transit_gateway_attachment_id"]; ok {
	r.Transit_gateway_attachment_id = x.(string)
}

if x, ok := state["transit_gateway_route_table_id"]; ok {
	r.Transit_gateway_route_table_id = x.(string)
}
	return r
}


// Aws_ec2_transit_gateway_routeHandler ...
type Aws_ec2_transit_gateway_routeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ec2_transit_gateway_routeHandler) Create(desired *Aws_ec2_transit_gateway_route) (*Aws_ec2_transit_gateway_route, string, error) {
	rState := Aws_ec2_transit_gateway_routeMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ec2_transit_gateway_route", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ec2_transit_gateway_routeHandler) Read(externalID string) (*Aws_ec2_transit_gateway_route, error) {
	actual, err := bridge.Read(h.provider, "aws_ec2_transit_gateway_route", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ec2_transit_gateway_routeUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ec2_transit_gateway_routeHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ec2_transit_gateway_route", externalID)
}

type Aws_iam_role struct {
     Aws_iam_role_id *string
     Arn *string
     Unique_id *string
     Name *string
     Path *string
     Permissions_boundary *string
     Force_detach_policies *bool
     Create_date *string
     Name_prefix *string
     Description *string
     Assume_role_policy string
     Tags *map[string]string
}


func Aws_iam_roleMapper(r *Aws_iam_role) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["assume_role_policy"] = r.Assume_role_policy
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Path != nil {
    config["path"] = *r.Path
}
if r.Permissions_boundary != nil {
    config["permissions_boundary"] = *r.Permissions_boundary
}
if r.Force_detach_policies != nil {
    config["force_detach_policies"] = *r.Force_detach_policies
}
if r.Create_date != nil {
    config["create_date"] = *r.Create_date
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Unique_id != nil {
    config["unique_id"] = *r.Unique_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_roleUnmapper(state map[string]interface{}) *Aws_iam_role {
	r := &Aws_iam_role{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_role_id = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["assume_role_policy"]; ok {
	r.Assume_role_policy = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["unique_id"]; ok {
	x := x.(string)
	r.Unique_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["path"]; ok {
	x := x.(string)
	r.Path = &x
}

if x, ok := state["permissions_boundary"]; ok {
	x := x.(string)
	r.Permissions_boundary = &x
}

if x, ok := state["force_detach_policies"]; ok {
	x := x.(bool)
	r.Force_detach_policies = &x
}

if x, ok := state["create_date"]; ok {
	x := x.(string)
	r.Create_date = &x
}
	return r
}


// Aws_iam_roleHandler ...
type Aws_iam_roleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_roleHandler) Create(desired *Aws_iam_role) (*Aws_iam_role, string, error) {
	rState := Aws_iam_roleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_role", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_roleHandler) Read(externalID string) (*Aws_iam_role, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_role", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_roleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_roleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_role", externalID)
}

type Aws_opsworks_php_app_layer struct {
     Aws_opsworks_php_app_layer_id *string
     Use_ebs_optimized_instances *bool
     Auto_assign_elastic_ips *bool
     Install_updates_on_boot *bool
     Stack_id string
     Drain_elb_on_shutdown *bool
     Name *string
     Auto_assign_public_ips *bool
     Elastic_load_balancer *string
     Custom_instance_profile_arn *string
     Custom_json *string
     Auto_healing *bool
}


func Aws_opsworks_php_app_layerMapper(r *Aws_opsworks_php_app_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
    config["stack_id"] = r.Stack_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_php_app_layerUnmapper(state map[string]interface{}) *Aws_opsworks_php_app_layer {
	r := &Aws_opsworks_php_app_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_php_app_layer_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}
	return r
}


// Aws_opsworks_php_app_layerHandler ...
type Aws_opsworks_php_app_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_php_app_layerHandler) Create(desired *Aws_opsworks_php_app_layer) (*Aws_opsworks_php_app_layer, string, error) {
	rState := Aws_opsworks_php_app_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_php_app_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_php_app_layerHandler) Read(externalID string) (*Aws_opsworks_php_app_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_php_app_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_php_app_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_php_app_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_php_app_layer", externalID)
}

type Aws_ses_receipt_rule_set struct {
     Aws_ses_receipt_rule_set_id *string
     Rule_set_name string
}


func Aws_ses_receipt_rule_setMapper(r *Aws_ses_receipt_rule_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["rule_set_name"] = r.Rule_set_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_receipt_rule_setUnmapper(state map[string]interface{}) *Aws_ses_receipt_rule_set {
	r := &Aws_ses_receipt_rule_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_receipt_rule_set_id = &x
}

if x, ok := state["rule_set_name"]; ok {
	r.Rule_set_name = x.(string)
}
	return r
}


// Aws_ses_receipt_rule_setHandler ...
type Aws_ses_receipt_rule_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_receipt_rule_setHandler) Create(desired *Aws_ses_receipt_rule_set) (*Aws_ses_receipt_rule_set, string, error) {
	rState := Aws_ses_receipt_rule_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_receipt_rule_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_receipt_rule_setHandler) Read(externalID string) (*Aws_ses_receipt_rule_set, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_receipt_rule_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_receipt_rule_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_receipt_rule_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_receipt_rule_set", externalID)
}

type Aws_s3_bucket_public_access_block struct {
     Aws_s3_bucket_public_access_block_id *string
     Block_public_acls *bool
     Block_public_policy *bool
     Ignore_public_acls *bool
     Restrict_public_buckets *bool
     Bucket string
}


func Aws_s3_bucket_public_access_blockMapper(r *Aws_s3_bucket_public_access_block) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Ignore_public_acls != nil {
    config["ignore_public_acls"] = *r.Ignore_public_acls
}
if r.Restrict_public_buckets != nil {
    config["restrict_public_buckets"] = *r.Restrict_public_buckets
}
    config["bucket"] = r.Bucket
if r.Block_public_acls != nil {
    config["block_public_acls"] = *r.Block_public_acls
}
if r.Block_public_policy != nil {
    config["block_public_policy"] = *r.Block_public_policy
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_s3_bucket_public_access_blockUnmapper(state map[string]interface{}) *Aws_s3_bucket_public_access_block {
	r := &Aws_s3_bucket_public_access_block{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_s3_bucket_public_access_block_id = &x
}

if x, ok := state["block_public_acls"]; ok {
	x := x.(bool)
	r.Block_public_acls = &x
}

if x, ok := state["block_public_policy"]; ok {
	x := x.(bool)
	r.Block_public_policy = &x
}

if x, ok := state["ignore_public_acls"]; ok {
	x := x.(bool)
	r.Ignore_public_acls = &x
}

if x, ok := state["restrict_public_buckets"]; ok {
	x := x.(bool)
	r.Restrict_public_buckets = &x
}

if x, ok := state["bucket"]; ok {
	r.Bucket = x.(string)
}
	return r
}


// Aws_s3_bucket_public_access_blockHandler ...
type Aws_s3_bucket_public_access_blockHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_s3_bucket_public_access_blockHandler) Create(desired *Aws_s3_bucket_public_access_block) (*Aws_s3_bucket_public_access_block, string, error) {
	rState := Aws_s3_bucket_public_access_blockMapper(desired)
	id, err := bridge.Create(h.provider, "aws_s3_bucket_public_access_block", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_s3_bucket_public_access_blockHandler) Read(externalID string) (*Aws_s3_bucket_public_access_block, error) {
	actual, err := bridge.Read(h.provider, "aws_s3_bucket_public_access_block", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_s3_bucket_public_access_blockUnmapper(actual), nil
}

// Delete ...
func (h *Aws_s3_bucket_public_access_blockHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_s3_bucket_public_access_block", externalID)
}

type Aws_sqs_queue_policy struct {
     Aws_sqs_queue_policy_id *string
     Queue_url string
     Policy string
}


func Aws_sqs_queue_policyMapper(r *Aws_sqs_queue_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["queue_url"] = r.Queue_url
    config["policy"] = r.Policy
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sqs_queue_policyUnmapper(state map[string]interface{}) *Aws_sqs_queue_policy {
	r := &Aws_sqs_queue_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sqs_queue_policy_id = &x
}

if x, ok := state["queue_url"]; ok {
	r.Queue_url = x.(string)
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}
	return r
}


// Aws_sqs_queue_policyHandler ...
type Aws_sqs_queue_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sqs_queue_policyHandler) Create(desired *Aws_sqs_queue_policy) (*Aws_sqs_queue_policy, string, error) {
	rState := Aws_sqs_queue_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sqs_queue_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sqs_queue_policyHandler) Read(externalID string) (*Aws_sqs_queue_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_sqs_queue_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sqs_queue_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sqs_queue_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sqs_queue_policy", externalID)
}

type Aws_api_gateway_account struct {
     Aws_api_gateway_account_id *string
     Cloudwatch_role_arn *string
}


func Aws_api_gateway_accountMapper(r *Aws_api_gateway_account) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Cloudwatch_role_arn != nil {
    config["cloudwatch_role_arn"] = *r.Cloudwatch_role_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_accountUnmapper(state map[string]interface{}) *Aws_api_gateway_account {
	r := &Aws_api_gateway_account{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_account_id = &x
}

if x, ok := state["cloudwatch_role_arn"]; ok {
	x := x.(string)
	r.Cloudwatch_role_arn = &x
}
	return r
}


// Aws_api_gateway_accountHandler ...
type Aws_api_gateway_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_accountHandler) Create(desired *Aws_api_gateway_account) (*Aws_api_gateway_account, string, error) {
	rState := Aws_api_gateway_accountMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_account", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_accountHandler) Read(externalID string) (*Aws_api_gateway_account, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_account", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_accountUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_accountHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_account", externalID)
}

type Aws_datasync_task struct {
     Aws_datasync_task_id *string
     Destination_location_arn string
     Name *string
     Source_location_arn string
     Tags *map[string]string
     Arn *string
     Cloudwatch_log_group_arn *string
}


func Aws_datasync_taskMapper(r *Aws_datasync_task) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["source_location_arn"] = r.Source_location_arn
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Cloudwatch_log_group_arn != nil {
    config["cloudwatch_log_group_arn"] = *r.Cloudwatch_log_group_arn
}
    config["destination_location_arn"] = r.Destination_location_arn
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_datasync_taskUnmapper(state map[string]interface{}) *Aws_datasync_task {
	r := &Aws_datasync_task{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_datasync_task_id = &x
}

if x, ok := state["cloudwatch_log_group_arn"]; ok {
	x := x.(string)
	r.Cloudwatch_log_group_arn = &x
}

if x, ok := state["destination_location_arn"]; ok {
	r.Destination_location_arn = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["source_location_arn"]; ok {
	r.Source_location_arn = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_datasync_taskHandler ...
type Aws_datasync_taskHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_datasync_taskHandler) Create(desired *Aws_datasync_task) (*Aws_datasync_task, string, error) {
	rState := Aws_datasync_taskMapper(desired)
	id, err := bridge.Create(h.provider, "aws_datasync_task", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_datasync_taskHandler) Read(externalID string) (*Aws_datasync_task, error) {
	actual, err := bridge.Read(h.provider, "aws_datasync_task", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_datasync_taskUnmapper(actual), nil
}

// Delete ...
func (h *Aws_datasync_taskHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_datasync_task", externalID)
}

type Aws_vpc_peering_connection_accepter struct {
     Aws_vpc_peering_connection_accepter_id *string
     Peer_region *string
     Vpc_peering_connection_id string
     Peer_owner_id *string
     Vpc_id *string
     Peer_vpc_id *string
     Tags *map[string]string
     Auto_accept *bool
     Accept_status *string
}


func Aws_vpc_peering_connection_accepterMapper(r *Aws_vpc_peering_connection_accepter) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_peering_connection_id"] = r.Vpc_peering_connection_id
if r.Peer_owner_id != nil {
    config["peer_owner_id"] = *r.Peer_owner_id
}
if r.Peer_region != nil {
    config["peer_region"] = *r.Peer_region
}
if r.Auto_accept != nil {
    config["auto_accept"] = *r.Auto_accept
}
if r.Accept_status != nil {
    config["accept_status"] = *r.Accept_status
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Peer_vpc_id != nil {
    config["peer_vpc_id"] = *r.Peer_vpc_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_peering_connection_accepterUnmapper(state map[string]interface{}) *Aws_vpc_peering_connection_accepter {
	r := &Aws_vpc_peering_connection_accepter{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_peering_connection_accepter_id = &x
}

if x, ok := state["vpc_peering_connection_id"]; ok {
	r.Vpc_peering_connection_id = x.(string)
}

if x, ok := state["peer_owner_id"]; ok {
	x := x.(string)
	r.Peer_owner_id = &x
}

if x, ok := state["peer_region"]; ok {
	x := x.(string)
	r.Peer_region = &x
}

if x, ok := state["auto_accept"]; ok {
	x := x.(bool)
	r.Auto_accept = &x
}

if x, ok := state["accept_status"]; ok {
	x := x.(string)
	r.Accept_status = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["peer_vpc_id"]; ok {
	x := x.(string)
	r.Peer_vpc_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_vpc_peering_connection_accepterHandler ...
type Aws_vpc_peering_connection_accepterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_peering_connection_accepterHandler) Create(desired *Aws_vpc_peering_connection_accepter) (*Aws_vpc_peering_connection_accepter, string, error) {
	rState := Aws_vpc_peering_connection_accepterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_peering_connection_accepter", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_peering_connection_accepterHandler) Read(externalID string) (*Aws_vpc_peering_connection_accepter, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_peering_connection_accepter", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_peering_connection_accepterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_peering_connection_accepterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_peering_connection_accepter", externalID)
}

type Aws_alb_listener struct {
     Aws_alb_listener_id *string
     Protocol *string
     Ssl_policy *string
     Certificate_arn *string
     Arn *string
     Load_balancer_arn string
}


func Aws_alb_listenerMapper(r *Aws_alb_listener) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["load_balancer_arn"] = r.Load_balancer_arn
if r.Protocol != nil {
    config["protocol"] = *r.Protocol
}
if r.Ssl_policy != nil {
    config["ssl_policy"] = *r.Ssl_policy
}
if r.Certificate_arn != nil {
    config["certificate_arn"] = *r.Certificate_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_alb_listenerUnmapper(state map[string]interface{}) *Aws_alb_listener {
	r := &Aws_alb_listener{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_alb_listener_id = &x
}

if x, ok := state["protocol"]; ok {
	x := x.(string)
	r.Protocol = &x
}

if x, ok := state["ssl_policy"]; ok {
	x := x.(string)
	r.Ssl_policy = &x
}

if x, ok := state["certificate_arn"]; ok {
	x := x.(string)
	r.Certificate_arn = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["load_balancer_arn"]; ok {
	r.Load_balancer_arn = x.(string)
}
	return r
}


// Aws_alb_listenerHandler ...
type Aws_alb_listenerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_alb_listenerHandler) Create(desired *Aws_alb_listener) (*Aws_alb_listener, string, error) {
	rState := Aws_alb_listenerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_alb_listener", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_alb_listenerHandler) Read(externalID string) (*Aws_alb_listener, error) {
	actual, err := bridge.Read(h.provider, "aws_alb_listener", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_alb_listenerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_alb_listenerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_alb_listener", externalID)
}

type Aws_macie_s3_bucket_association struct {
     Aws_macie_s3_bucket_association_id *string
     Bucket_name string
     Prefix *string
     Member_account_id *string
}


func Aws_macie_s3_bucket_associationMapper(r *Aws_macie_s3_bucket_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["bucket_name"] = r.Bucket_name
if r.Prefix != nil {
    config["prefix"] = *r.Prefix
}
if r.Member_account_id != nil {
    config["member_account_id"] = *r.Member_account_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_macie_s3_bucket_associationUnmapper(state map[string]interface{}) *Aws_macie_s3_bucket_association {
	r := &Aws_macie_s3_bucket_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_macie_s3_bucket_association_id = &x
}

if x, ok := state["bucket_name"]; ok {
	r.Bucket_name = x.(string)
}

if x, ok := state["prefix"]; ok {
	x := x.(string)
	r.Prefix = &x
}

if x, ok := state["member_account_id"]; ok {
	x := x.(string)
	r.Member_account_id = &x
}
	return r
}


// Aws_macie_s3_bucket_associationHandler ...
type Aws_macie_s3_bucket_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_macie_s3_bucket_associationHandler) Create(desired *Aws_macie_s3_bucket_association) (*Aws_macie_s3_bucket_association, string, error) {
	rState := Aws_macie_s3_bucket_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_macie_s3_bucket_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_macie_s3_bucket_associationHandler) Read(externalID string) (*Aws_macie_s3_bucket_association, error) {
	actual, err := bridge.Read(h.provider, "aws_macie_s3_bucket_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_macie_s3_bucket_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_macie_s3_bucket_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_macie_s3_bucket_association", externalID)
}

type Aws_sns_sms_preferences struct {
     Aws_sns_sms_preferences_id *string
     Default_sender_id *string
     Default_sms_type *string
     Usage_report_s3_bucket *string
     Monthly_spend_limit *string
     Delivery_status_iam_role_arn *string
     Delivery_status_success_sampling_rate *string
}


func Aws_sns_sms_preferencesMapper(r *Aws_sns_sms_preferences) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Delivery_status_success_sampling_rate != nil {
    config["delivery_status_success_sampling_rate"] = *r.Delivery_status_success_sampling_rate
}
if r.Default_sender_id != nil {
    config["default_sender_id"] = *r.Default_sender_id
}
if r.Default_sms_type != nil {
    config["default_sms_type"] = *r.Default_sms_type
}
if r.Usage_report_s3_bucket != nil {
    config["usage_report_s3_bucket"] = *r.Usage_report_s3_bucket
}
if r.Monthly_spend_limit != nil {
    config["monthly_spend_limit"] = *r.Monthly_spend_limit
}
if r.Delivery_status_iam_role_arn != nil {
    config["delivery_status_iam_role_arn"] = *r.Delivery_status_iam_role_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sns_sms_preferencesUnmapper(state map[string]interface{}) *Aws_sns_sms_preferences {
	r := &Aws_sns_sms_preferences{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sns_sms_preferences_id = &x
}

if x, ok := state["monthly_spend_limit"]; ok {
	x := x.(string)
	r.Monthly_spend_limit = &x
}

if x, ok := state["delivery_status_iam_role_arn"]; ok {
	x := x.(string)
	r.Delivery_status_iam_role_arn = &x
}

if x, ok := state["delivery_status_success_sampling_rate"]; ok {
	x := x.(string)
	r.Delivery_status_success_sampling_rate = &x
}

if x, ok := state["default_sender_id"]; ok {
	x := x.(string)
	r.Default_sender_id = &x
}

if x, ok := state["default_sms_type"]; ok {
	x := x.(string)
	r.Default_sms_type = &x
}

if x, ok := state["usage_report_s3_bucket"]; ok {
	x := x.(string)
	r.Usage_report_s3_bucket = &x
}
	return r
}


// Aws_sns_sms_preferencesHandler ...
type Aws_sns_sms_preferencesHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sns_sms_preferencesHandler) Create(desired *Aws_sns_sms_preferences) (*Aws_sns_sms_preferences, string, error) {
	rState := Aws_sns_sms_preferencesMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sns_sms_preferences", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sns_sms_preferencesHandler) Read(externalID string) (*Aws_sns_sms_preferences, error) {
	actual, err := bridge.Read(h.provider, "aws_sns_sms_preferences", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sns_sms_preferencesUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sns_sms_preferencesHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sns_sms_preferences", externalID)
}

type Aws_dx_bgp_peer struct {
     Aws_dx_bgp_peer_id *string
     Address_family string
     Virtual_interface_id string
     Amazon_address *string
     Bgp_auth_key *string
     Customer_address *string
     Bgp_status *string
}


func Aws_dx_bgp_peerMapper(r *Aws_dx_bgp_peer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Bgp_auth_key != nil {
    config["bgp_auth_key"] = *r.Bgp_auth_key
}
if r.Customer_address != nil {
    config["customer_address"] = *r.Customer_address
}
if r.Bgp_status != nil {
    config["bgp_status"] = *r.Bgp_status
}
    config["address_family"] = r.Address_family
    config["virtual_interface_id"] = r.Virtual_interface_id
if r.Amazon_address != nil {
    config["amazon_address"] = *r.Amazon_address
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_bgp_peerUnmapper(state map[string]interface{}) *Aws_dx_bgp_peer {
	r := &Aws_dx_bgp_peer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_bgp_peer_id = &x
}

if x, ok := state["bgp_auth_key"]; ok {
	x := x.(string)
	r.Bgp_auth_key = &x
}

if x, ok := state["customer_address"]; ok {
	x := x.(string)
	r.Customer_address = &x
}

if x, ok := state["bgp_status"]; ok {
	x := x.(string)
	r.Bgp_status = &x
}

if x, ok := state["address_family"]; ok {
	r.Address_family = x.(string)
}

if x, ok := state["virtual_interface_id"]; ok {
	r.Virtual_interface_id = x.(string)
}

if x, ok := state["amazon_address"]; ok {
	x := x.(string)
	r.Amazon_address = &x
}
	return r
}


// Aws_dx_bgp_peerHandler ...
type Aws_dx_bgp_peerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_bgp_peerHandler) Create(desired *Aws_dx_bgp_peer) (*Aws_dx_bgp_peer, string, error) {
	rState := Aws_dx_bgp_peerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_bgp_peer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_bgp_peerHandler) Read(externalID string) (*Aws_dx_bgp_peer, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_bgp_peer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_bgp_peerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_bgp_peerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_bgp_peer", externalID)
}

type Aws_iam_user_login_profile struct {
     Aws_iam_user_login_profile_id *string
     Key_fingerprint *string
     Encrypted_password *string
     User string
     Pgp_key string
     Password_reset_required *bool
}


func Aws_iam_user_login_profileMapper(r *Aws_iam_user_login_profile) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Key_fingerprint != nil {
    config["key_fingerprint"] = *r.Key_fingerprint
}
if r.Encrypted_password != nil {
    config["encrypted_password"] = *r.Encrypted_password
}
    config["user"] = r.User
    config["pgp_key"] = r.Pgp_key
if r.Password_reset_required != nil {
    config["password_reset_required"] = *r.Password_reset_required
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_user_login_profileUnmapper(state map[string]interface{}) *Aws_iam_user_login_profile {
	r := &Aws_iam_user_login_profile{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_user_login_profile_id = &x
}

if x, ok := state["user"]; ok {
	r.User = x.(string)
}

if x, ok := state["pgp_key"]; ok {
	r.Pgp_key = x.(string)
}

if x, ok := state["password_reset_required"]; ok {
	x := x.(bool)
	r.Password_reset_required = &x
}

if x, ok := state["key_fingerprint"]; ok {
	x := x.(string)
	r.Key_fingerprint = &x
}

if x, ok := state["encrypted_password"]; ok {
	x := x.(string)
	r.Encrypted_password = &x
}
	return r
}


// Aws_iam_user_login_profileHandler ...
type Aws_iam_user_login_profileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_user_login_profileHandler) Create(desired *Aws_iam_user_login_profile) (*Aws_iam_user_login_profile, string, error) {
	rState := Aws_iam_user_login_profileMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_user_login_profile", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_user_login_profileHandler) Read(externalID string) (*Aws_iam_user_login_profile, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_user_login_profile", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_user_login_profileUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_user_login_profileHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_user_login_profile", externalID)
}

type Aws_iot_certificate struct {
     Aws_iot_certificate_id *string
     Csr string
     Active bool
     Arn *string
}


func Aws_iot_certificateMapper(r *Aws_iot_certificate) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["csr"] = r.Csr
    config["active"] = r.Active
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iot_certificateUnmapper(state map[string]interface{}) *Aws_iot_certificate {
	r := &Aws_iot_certificate{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iot_certificate_id = &x
}

if x, ok := state["csr"]; ok {
	r.Csr = x.(string)
}

if x, ok := state["active"]; ok {
	r.Active = x.(bool)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_iot_certificateHandler ...
type Aws_iot_certificateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iot_certificateHandler) Create(desired *Aws_iot_certificate) (*Aws_iot_certificate, string, error) {
	rState := Aws_iot_certificateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iot_certificate", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iot_certificateHandler) Read(externalID string) (*Aws_iot_certificate, error) {
	actual, err := bridge.Read(h.provider, "aws_iot_certificate", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iot_certificateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iot_certificateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iot_certificate", externalID)
}

type Aws_opsworks_java_app_layer struct {
     Aws_opsworks_java_app_layer_id *string
     Name *string
     Jvm_options *string
     Custom_instance_profile_arn *string
     Auto_healing *bool
     Install_updates_on_boot *bool
     Stack_id string
     App_server *string
     Elastic_load_balancer *string
     Custom_json *string
     Jvm_type *string
     Auto_assign_public_ips *bool
     Jvm_version *string
     App_server_version *string
     Auto_assign_elastic_ips *bool
     Drain_elb_on_shutdown *bool
     Use_ebs_optimized_instances *bool
}


func Aws_opsworks_java_app_layerMapper(r *Aws_opsworks_java_app_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Jvm_version != nil {
    config["jvm_version"] = *r.Jvm_version
}
if r.App_server_version != nil {
    config["app_server_version"] = *r.App_server_version
}
if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
    config["stack_id"] = r.Stack_id
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Jvm_options != nil {
    config["jvm_options"] = *r.Jvm_options
}
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Jvm_type != nil {
    config["jvm_type"] = *r.Jvm_type
}
if r.App_server != nil {
    config["app_server"] = *r.App_server
}
if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_java_app_layerUnmapper(state map[string]interface{}) *Aws_opsworks_java_app_layer {
	r := &Aws_opsworks_java_app_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_java_app_layer_id = &x
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["jvm_options"]; ok {
	x := x.(string)
	r.Jvm_options = &x
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["jvm_type"]; ok {
	x := x.(string)
	r.Jvm_type = &x
}

if x, ok := state["app_server"]; ok {
	x := x.(string)
	r.App_server = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["jvm_version"]; ok {
	x := x.(string)
	r.Jvm_version = &x
}

if x, ok := state["app_server_version"]; ok {
	x := x.(string)
	r.App_server_version = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}
	return r
}


// Aws_opsworks_java_app_layerHandler ...
type Aws_opsworks_java_app_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_java_app_layerHandler) Create(desired *Aws_opsworks_java_app_layer) (*Aws_opsworks_java_app_layer, string, error) {
	rState := Aws_opsworks_java_app_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_java_app_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_java_app_layerHandler) Read(externalID string) (*Aws_opsworks_java_app_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_java_app_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_java_app_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_java_app_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_java_app_layer", externalID)
}

type Aws_service_discovery_public_dns_namespace struct {
     Aws_service_discovery_public_dns_namespace_id *string
     Name string
     Description *string
     Arn *string
     Hosted_zone *string
}


func Aws_service_discovery_public_dns_namespaceMapper(r *Aws_service_discovery_public_dns_namespace) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Hosted_zone != nil {
    config["hosted_zone"] = *r.Hosted_zone
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_service_discovery_public_dns_namespaceUnmapper(state map[string]interface{}) *Aws_service_discovery_public_dns_namespace {
	r := &Aws_service_discovery_public_dns_namespace{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_service_discovery_public_dns_namespace_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["hosted_zone"]; ok {
	x := x.(string)
	r.Hosted_zone = &x
}
	return r
}


// Aws_service_discovery_public_dns_namespaceHandler ...
type Aws_service_discovery_public_dns_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_service_discovery_public_dns_namespaceHandler) Create(desired *Aws_service_discovery_public_dns_namespace) (*Aws_service_discovery_public_dns_namespace, string, error) {
	rState := Aws_service_discovery_public_dns_namespaceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_service_discovery_public_dns_namespace", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_service_discovery_public_dns_namespaceHandler) Read(externalID string) (*Aws_service_discovery_public_dns_namespace, error) {
	actual, err := bridge.Read(h.provider, "aws_service_discovery_public_dns_namespace", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_service_discovery_public_dns_namespaceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_service_discovery_public_dns_namespaceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_service_discovery_public_dns_namespace", externalID)
}

type Aws_wafregional_ipset struct {
     Aws_wafregional_ipset_id *string
     Name string
     Arn *string
}


func Aws_wafregional_ipsetMapper(r *Aws_wafregional_ipset) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_ipsetUnmapper(state map[string]interface{}) *Aws_wafregional_ipset {
	r := &Aws_wafregional_ipset{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_ipset_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_wafregional_ipsetHandler ...
type Aws_wafregional_ipsetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_ipsetHandler) Create(desired *Aws_wafregional_ipset) (*Aws_wafregional_ipset, string, error) {
	rState := Aws_wafregional_ipsetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_ipset", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_ipsetHandler) Read(externalID string) (*Aws_wafregional_ipset, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_ipset", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_ipsetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_ipsetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_ipset", externalID)
}

type Aws_budgets_budget struct {
     Aws_budgets_budget_id *string
     Limit_unit string
     Time_period_start string
     Time_period_end *string
     Cost_filters *map[string]string
     Account_id *string
     Name *string
     Name_prefix *string
     Budget_type string
     Limit_amount string
     Time_unit string
}


func Aws_budgets_budgetMapper(r *Aws_budgets_budget) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Cost_filters != nil {
    config["cost_filters"] = *r.Cost_filters
}
    config["limit_unit"] = r.Limit_unit
    config["time_period_start"] = r.Time_period_start
if r.Time_period_end != nil {
    config["time_period_end"] = *r.Time_period_end
}
    config["budget_type"] = r.Budget_type
    config["limit_amount"] = r.Limit_amount
    config["time_unit"] = r.Time_unit
if r.Account_id != nil {
    config["account_id"] = *r.Account_id
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_budgets_budgetUnmapper(state map[string]interface{}) *Aws_budgets_budget {
	r := &Aws_budgets_budget{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_budgets_budget_id = &x
}

if x, ok := state["budget_type"]; ok {
	r.Budget_type = x.(string)
}

if x, ok := state["limit_amount"]; ok {
	r.Limit_amount = x.(string)
}

if x, ok := state["time_unit"]; ok {
	r.Time_unit = x.(string)
}

if x, ok := state["account_id"]; ok {
	x := x.(string)
	r.Account_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["cost_filters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Cost_filters = &x
}

if x, ok := state["limit_unit"]; ok {
	r.Limit_unit = x.(string)
}

if x, ok := state["time_period_start"]; ok {
	r.Time_period_start = x.(string)
}

if x, ok := state["time_period_end"]; ok {
	x := x.(string)
	r.Time_period_end = &x
}
	return r
}


// Aws_budgets_budgetHandler ...
type Aws_budgets_budgetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_budgets_budgetHandler) Create(desired *Aws_budgets_budget) (*Aws_budgets_budget, string, error) {
	rState := Aws_budgets_budgetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_budgets_budget", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_budgets_budgetHandler) Read(externalID string) (*Aws_budgets_budget, error) {
	actual, err := bridge.Read(h.provider, "aws_budgets_budget", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_budgets_budgetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_budgets_budgetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_budgets_budget", externalID)
}

type Aws_cognito_user_pool_domain struct {
     Aws_cognito_user_pool_domain_id *string
     Domain string
     Certificate_arn *string
     User_pool_id string
     Aws_account_id *string
     Cloudfront_distribution_arn *string
     S3_bucket *string
     Version *string
}


func Aws_cognito_user_pool_domainMapper(r *Aws_cognito_user_pool_domain) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["user_pool_id"] = r.User_pool_id
if r.Aws_account_id != nil {
    config["aws_account_id"] = *r.Aws_account_id
}
if r.Cloudfront_distribution_arn != nil {
    config["cloudfront_distribution_arn"] = *r.Cloudfront_distribution_arn
}
if r.S3_bucket != nil {
    config["s3_bucket"] = *r.S3_bucket
}
if r.Version != nil {
    config["version"] = *r.Version
}
    config["domain"] = r.Domain
if r.Certificate_arn != nil {
    config["certificate_arn"] = *r.Certificate_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cognito_user_pool_domainUnmapper(state map[string]interface{}) *Aws_cognito_user_pool_domain {
	r := &Aws_cognito_user_pool_domain{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cognito_user_pool_domain_id = &x
}

if x, ok := state["domain"]; ok {
	r.Domain = x.(string)
}

if x, ok := state["certificate_arn"]; ok {
	x := x.(string)
	r.Certificate_arn = &x
}

if x, ok := state["user_pool_id"]; ok {
	r.User_pool_id = x.(string)
}

if x, ok := state["aws_account_id"]; ok {
	x := x.(string)
	r.Aws_account_id = &x
}

if x, ok := state["cloudfront_distribution_arn"]; ok {
	x := x.(string)
	r.Cloudfront_distribution_arn = &x
}

if x, ok := state["s3_bucket"]; ok {
	x := x.(string)
	r.S3_bucket = &x
}

if x, ok := state["version"]; ok {
	x := x.(string)
	r.Version = &x
}
	return r
}


// Aws_cognito_user_pool_domainHandler ...
type Aws_cognito_user_pool_domainHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cognito_user_pool_domainHandler) Create(desired *Aws_cognito_user_pool_domain) (*Aws_cognito_user_pool_domain, string, error) {
	rState := Aws_cognito_user_pool_domainMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cognito_user_pool_domain", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cognito_user_pool_domainHandler) Read(externalID string) (*Aws_cognito_user_pool_domain, error) {
	actual, err := bridge.Read(h.provider, "aws_cognito_user_pool_domain", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cognito_user_pool_domainUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cognito_user_pool_domainHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cognito_user_pool_domain", externalID)
}

type Aws_main_route_table_association struct {
     Aws_main_route_table_association_id *string
     Vpc_id string
     Route_table_id string
     Original_route_table_id *string
}


func Aws_main_route_table_associationMapper(r *Aws_main_route_table_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["route_table_id"] = r.Route_table_id
if r.Original_route_table_id != nil {
    config["original_route_table_id"] = *r.Original_route_table_id
}
    config["vpc_id"] = r.Vpc_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_main_route_table_associationUnmapper(state map[string]interface{}) *Aws_main_route_table_association {
	r := &Aws_main_route_table_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_main_route_table_association_id = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["route_table_id"]; ok {
	r.Route_table_id = x.(string)
}

if x, ok := state["original_route_table_id"]; ok {
	x := x.(string)
	r.Original_route_table_id = &x
}
	return r
}


// Aws_main_route_table_associationHandler ...
type Aws_main_route_table_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_main_route_table_associationHandler) Create(desired *Aws_main_route_table_association) (*Aws_main_route_table_association, string, error) {
	rState := Aws_main_route_table_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_main_route_table_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_main_route_table_associationHandler) Read(externalID string) (*Aws_main_route_table_association, error) {
	actual, err := bridge.Read(h.provider, "aws_main_route_table_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_main_route_table_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_main_route_table_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_main_route_table_association", externalID)
}

type Aws_sagemaker_notebook_instance struct {
     Aws_sagemaker_notebook_instance_id *string
     Tags *map[string]string
     Arn *string
     Name string
     Role_arn string
     Instance_type string
     Subnet_id *string
     Kms_key_id *string
}


func Aws_sagemaker_notebook_instanceMapper(r *Aws_sagemaker_notebook_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["role_arn"] = r.Role_arn
    config["instance_type"] = r.Instance_type
if r.Subnet_id != nil {
    config["subnet_id"] = *r.Subnet_id
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sagemaker_notebook_instanceUnmapper(state map[string]interface{}) *Aws_sagemaker_notebook_instance {
	r := &Aws_sagemaker_notebook_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sagemaker_notebook_instance_id = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}

if x, ok := state["instance_type"]; ok {
	r.Instance_type = x.(string)
}

if x, ok := state["subnet_id"]; ok {
	x := x.(string)
	r.Subnet_id = &x
}
	return r
}


// Aws_sagemaker_notebook_instanceHandler ...
type Aws_sagemaker_notebook_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sagemaker_notebook_instanceHandler) Create(desired *Aws_sagemaker_notebook_instance) (*Aws_sagemaker_notebook_instance, string, error) {
	rState := Aws_sagemaker_notebook_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sagemaker_notebook_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sagemaker_notebook_instanceHandler) Read(externalID string) (*Aws_sagemaker_notebook_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_sagemaker_notebook_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sagemaker_notebook_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sagemaker_notebook_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sagemaker_notebook_instance", externalID)
}

type Aws_storagegateway_cache struct {
     Aws_storagegateway_cache_id *string
     Gateway_arn string
     Disk_id string
}


func Aws_storagegateway_cacheMapper(r *Aws_storagegateway_cache) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["disk_id"] = r.Disk_id
    config["gateway_arn"] = r.Gateway_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_storagegateway_cacheUnmapper(state map[string]interface{}) *Aws_storagegateway_cache {
	r := &Aws_storagegateway_cache{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_storagegateway_cache_id = &x
}

if x, ok := state["disk_id"]; ok {
	r.Disk_id = x.(string)
}

if x, ok := state["gateway_arn"]; ok {
	r.Gateway_arn = x.(string)
}
	return r
}


// Aws_storagegateway_cacheHandler ...
type Aws_storagegateway_cacheHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_storagegateway_cacheHandler) Create(desired *Aws_storagegateway_cache) (*Aws_storagegateway_cache, string, error) {
	rState := Aws_storagegateway_cacheMapper(desired)
	id, err := bridge.Create(h.provider, "aws_storagegateway_cache", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_storagegateway_cacheHandler) Read(externalID string) (*Aws_storagegateway_cache, error) {
	actual, err := bridge.Read(h.provider, "aws_storagegateway_cache", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_storagegateway_cacheUnmapper(actual), nil
}

// Delete ...
func (h *Aws_storagegateway_cacheHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_storagegateway_cache", externalID)
}

type Aws_dax_subnet_group struct {
     Aws_dax_subnet_group_id *string
     Name string
     Description *string
     Vpc_id *string
}


func Aws_dax_subnet_groupMapper(r *Aws_dax_subnet_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dax_subnet_groupUnmapper(state map[string]interface{}) *Aws_dax_subnet_group {
	r := &Aws_dax_subnet_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dax_subnet_group_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}
	return r
}


// Aws_dax_subnet_groupHandler ...
type Aws_dax_subnet_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dax_subnet_groupHandler) Create(desired *Aws_dax_subnet_group) (*Aws_dax_subnet_group, string, error) {
	rState := Aws_dax_subnet_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dax_subnet_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dax_subnet_groupHandler) Read(externalID string) (*Aws_dax_subnet_group, error) {
	actual, err := bridge.Read(h.provider, "aws_dax_subnet_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dax_subnet_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dax_subnet_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dax_subnet_group", externalID)
}

type Aws_efs_mount_target struct {
     Aws_efs_mount_target_id *string
     File_system_arn *string
     File_system_id string
     Ip_address *string
     Subnet_id string
     Network_interface_id *string
     Dns_name *string
}


func Aws_efs_mount_targetMapper(r *Aws_efs_mount_target) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.File_system_arn != nil {
    config["file_system_arn"] = *r.File_system_arn
}
    config["file_system_id"] = r.File_system_id
if r.Ip_address != nil {
    config["ip_address"] = *r.Ip_address
}
    config["subnet_id"] = r.Subnet_id
if r.Network_interface_id != nil {
    config["network_interface_id"] = *r.Network_interface_id
}
if r.Dns_name != nil {
    config["dns_name"] = *r.Dns_name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_efs_mount_targetUnmapper(state map[string]interface{}) *Aws_efs_mount_target {
	r := &Aws_efs_mount_target{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_efs_mount_target_id = &x
}

if x, ok := state["ip_address"]; ok {
	x := x.(string)
	r.Ip_address = &x
}

if x, ok := state["subnet_id"]; ok {
	r.Subnet_id = x.(string)
}

if x, ok := state["network_interface_id"]; ok {
	x := x.(string)
	r.Network_interface_id = &x
}

if x, ok := state["dns_name"]; ok {
	x := x.(string)
	r.Dns_name = &x
}

if x, ok := state["file_system_arn"]; ok {
	x := x.(string)
	r.File_system_arn = &x
}

if x, ok := state["file_system_id"]; ok {
	r.File_system_id = x.(string)
}
	return r
}


// Aws_efs_mount_targetHandler ...
type Aws_efs_mount_targetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_efs_mount_targetHandler) Create(desired *Aws_efs_mount_target) (*Aws_efs_mount_target, string, error) {
	rState := Aws_efs_mount_targetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_efs_mount_target", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_efs_mount_targetHandler) Read(externalID string) (*Aws_efs_mount_target, error) {
	actual, err := bridge.Read(h.provider, "aws_efs_mount_target", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_efs_mount_targetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_efs_mount_targetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_efs_mount_target", externalID)
}

type Aws_cognito_identity_pool struct {
     Aws_cognito_identity_pool_id *string
     Developer_provider_name *string
     Allow_unauthenticated_identities *bool
     Supported_login_providers *map[string]string
     Identity_pool_name string
     Arn *string
}


func Aws_cognito_identity_poolMapper(r *Aws_cognito_identity_pool) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Supported_login_providers != nil {
    config["supported_login_providers"] = *r.Supported_login_providers
}
    config["identity_pool_name"] = r.Identity_pool_name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Developer_provider_name != nil {
    config["developer_provider_name"] = *r.Developer_provider_name
}
if r.Allow_unauthenticated_identities != nil {
    config["allow_unauthenticated_identities"] = *r.Allow_unauthenticated_identities
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cognito_identity_poolUnmapper(state map[string]interface{}) *Aws_cognito_identity_pool {
	r := &Aws_cognito_identity_pool{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cognito_identity_pool_id = &x
}

if x, ok := state["developer_provider_name"]; ok {
	x := x.(string)
	r.Developer_provider_name = &x
}

if x, ok := state["allow_unauthenticated_identities"]; ok {
	x := x.(bool)
	r.Allow_unauthenticated_identities = &x
}

if x, ok := state["supported_login_providers"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Supported_login_providers = &x
}

if x, ok := state["identity_pool_name"]; ok {
	r.Identity_pool_name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_cognito_identity_poolHandler ...
type Aws_cognito_identity_poolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cognito_identity_poolHandler) Create(desired *Aws_cognito_identity_pool) (*Aws_cognito_identity_pool, string, error) {
	rState := Aws_cognito_identity_poolMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cognito_identity_pool", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cognito_identity_poolHandler) Read(externalID string) (*Aws_cognito_identity_pool, error) {
	actual, err := bridge.Read(h.provider, "aws_cognito_identity_pool", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cognito_identity_poolUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cognito_identity_poolHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cognito_identity_pool", externalID)
}

type Aws_neptune_event_subscription struct {
     Aws_neptune_event_subscription_id *string
     Tags *map[string]string
     Arn *string
     Name_prefix *string
     Sns_topic_arn string
     Source_type *string
     Customer_aws_id *string
     Name *string
     Enabled *bool
}


func Aws_neptune_event_subscriptionMapper(r *Aws_neptune_event_subscription) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["sns_topic_arn"] = r.Sns_topic_arn
if r.Source_type != nil {
    config["source_type"] = *r.Source_type
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.Customer_aws_id != nil {
    config["customer_aws_id"] = *r.Customer_aws_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_neptune_event_subscriptionUnmapper(state map[string]interface{}) *Aws_neptune_event_subscription {
	r := &Aws_neptune_event_subscription{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_neptune_event_subscription_id = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["customer_aws_id"]; ok {
	x := x.(string)
	r.Customer_aws_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["sns_topic_arn"]; ok {
	r.Sns_topic_arn = x.(string)
}

if x, ok := state["source_type"]; ok {
	x := x.(string)
	r.Source_type = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_neptune_event_subscriptionHandler ...
type Aws_neptune_event_subscriptionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_neptune_event_subscriptionHandler) Create(desired *Aws_neptune_event_subscription) (*Aws_neptune_event_subscription, string, error) {
	rState := Aws_neptune_event_subscriptionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_neptune_event_subscription", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_neptune_event_subscriptionHandler) Read(externalID string) (*Aws_neptune_event_subscription, error) {
	actual, err := bridge.Read(h.provider, "aws_neptune_event_subscription", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_neptune_event_subscriptionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_neptune_event_subscriptionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_neptune_event_subscription", externalID)
}

type Aws_pinpoint_email_channel struct {
     Aws_pinpoint_email_channel_id *string
     Application_id string
     Enabled *bool
     From_address string
     Identity string
     Role_arn string
}


func Aws_pinpoint_email_channelMapper(r *Aws_pinpoint_email_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["application_id"] = r.Application_id
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
    config["from_address"] = r.From_address
    config["identity"] = r.Identity
    config["role_arn"] = r.Role_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_email_channelUnmapper(state map[string]interface{}) *Aws_pinpoint_email_channel {
	r := &Aws_pinpoint_email_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_email_channel_id = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["from_address"]; ok {
	r.From_address = x.(string)
}

if x, ok := state["identity"]; ok {
	r.Identity = x.(string)
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}
	return r
}


// Aws_pinpoint_email_channelHandler ...
type Aws_pinpoint_email_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_email_channelHandler) Create(desired *Aws_pinpoint_email_channel) (*Aws_pinpoint_email_channel, string, error) {
	rState := Aws_pinpoint_email_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_email_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_email_channelHandler) Read(externalID string) (*Aws_pinpoint_email_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_email_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_email_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_email_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_email_channel", externalID)
}

type Aws_ami_launch_permission struct {
     Aws_ami_launch_permission_id *string
     Image_id string
     Account_id string
}


func Aws_ami_launch_permissionMapper(r *Aws_ami_launch_permission) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["account_id"] = r.Account_id
    config["image_id"] = r.Image_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ami_launch_permissionUnmapper(state map[string]interface{}) *Aws_ami_launch_permission {
	r := &Aws_ami_launch_permission{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ami_launch_permission_id = &x
}

if x, ok := state["image_id"]; ok {
	r.Image_id = x.(string)
}

if x, ok := state["account_id"]; ok {
	r.Account_id = x.(string)
}
	return r
}


// Aws_ami_launch_permissionHandler ...
type Aws_ami_launch_permissionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ami_launch_permissionHandler) Create(desired *Aws_ami_launch_permission) (*Aws_ami_launch_permission, string, error) {
	rState := Aws_ami_launch_permissionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ami_launch_permission", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ami_launch_permissionHandler) Read(externalID string) (*Aws_ami_launch_permission, error) {
	actual, err := bridge.Read(h.provider, "aws_ami_launch_permission", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ami_launch_permissionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ami_launch_permissionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ami_launch_permission", externalID)
}

type Aws_appsync_api_key struct {
     Aws_appsync_api_key_id *string
     Description *string
     Api_id string
     Expires *string
     Key *string
}


func Aws_appsync_api_keyMapper(r *Aws_appsync_api_key) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
    config["api_id"] = r.Api_id
if r.Expires != nil {
    config["expires"] = *r.Expires
}
if r.Key != nil {
    config["key"] = *r.Key
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appsync_api_keyUnmapper(state map[string]interface{}) *Aws_appsync_api_key {
	r := &Aws_appsync_api_key{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appsync_api_key_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["api_id"]; ok {
	r.Api_id = x.(string)
}

if x, ok := state["expires"]; ok {
	x := x.(string)
	r.Expires = &x
}

if x, ok := state["key"]; ok {
	x := x.(string)
	r.Key = &x
}
	return r
}


// Aws_appsync_api_keyHandler ...
type Aws_appsync_api_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appsync_api_keyHandler) Create(desired *Aws_appsync_api_key) (*Aws_appsync_api_key, string, error) {
	rState := Aws_appsync_api_keyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appsync_api_key", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appsync_api_keyHandler) Read(externalID string) (*Aws_appsync_api_key, error) {
	actual, err := bridge.Read(h.provider, "aws_appsync_api_key", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appsync_api_keyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appsync_api_keyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appsync_api_key", externalID)
}

type Aws_iam_user_group_membership struct {
     Aws_iam_user_group_membership_id *string
     User string
}


func Aws_iam_user_group_membershipMapper(r *Aws_iam_user_group_membership) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["user"] = r.User
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_user_group_membershipUnmapper(state map[string]interface{}) *Aws_iam_user_group_membership {
	r := &Aws_iam_user_group_membership{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_user_group_membership_id = &x
}

if x, ok := state["user"]; ok {
	r.User = x.(string)
}
	return r
}


// Aws_iam_user_group_membershipHandler ...
type Aws_iam_user_group_membershipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_user_group_membershipHandler) Create(desired *Aws_iam_user_group_membership) (*Aws_iam_user_group_membership, string, error) {
	rState := Aws_iam_user_group_membershipMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_user_group_membership", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_user_group_membershipHandler) Read(externalID string) (*Aws_iam_user_group_membership, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_user_group_membership", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_user_group_membershipUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_user_group_membershipHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_user_group_membership", externalID)
}

type Aws_storagegateway_gateway struct {
     Aws_storagegateway_gateway_id *string
     Arn *string
     Gateway_ip_address *string
     Gateway_type *string
     Medium_changer_type *string
     Smb_guest_password *string
     Tape_drive_type *string
     Activation_key *string
     Gateway_id *string
     Gateway_name string
     Gateway_timezone string
}


func Aws_storagegateway_gatewayMapper(r *Aws_storagegateway_gateway) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Activation_key != nil {
    config["activation_key"] = *r.Activation_key
}
if r.Gateway_id != nil {
    config["gateway_id"] = *r.Gateway_id
}
    config["gateway_name"] = r.Gateway_name
    config["gateway_timezone"] = r.Gateway_timezone
if r.Tape_drive_type != nil {
    config["tape_drive_type"] = *r.Tape_drive_type
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Gateway_ip_address != nil {
    config["gateway_ip_address"] = *r.Gateway_ip_address
}
if r.Gateway_type != nil {
    config["gateway_type"] = *r.Gateway_type
}
if r.Medium_changer_type != nil {
    config["medium_changer_type"] = *r.Medium_changer_type
}
if r.Smb_guest_password != nil {
    config["smb_guest_password"] = *r.Smb_guest_password
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_storagegateway_gatewayUnmapper(state map[string]interface{}) *Aws_storagegateway_gateway {
	r := &Aws_storagegateway_gateway{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_storagegateway_gateway_id = &x
}

if x, ok := state["gateway_name"]; ok {
	r.Gateway_name = x.(string)
}

if x, ok := state["gateway_timezone"]; ok {
	r.Gateway_timezone = x.(string)
}

if x, ok := state["tape_drive_type"]; ok {
	x := x.(string)
	r.Tape_drive_type = &x
}

if x, ok := state["activation_key"]; ok {
	x := x.(string)
	r.Activation_key = &x
}

if x, ok := state["gateway_id"]; ok {
	x := x.(string)
	r.Gateway_id = &x
}

if x, ok := state["gateway_type"]; ok {
	x := x.(string)
	r.Gateway_type = &x
}

if x, ok := state["medium_changer_type"]; ok {
	x := x.(string)
	r.Medium_changer_type = &x
}

if x, ok := state["smb_guest_password"]; ok {
	x := x.(string)
	r.Smb_guest_password = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["gateway_ip_address"]; ok {
	x := x.(string)
	r.Gateway_ip_address = &x
}
	return r
}


// Aws_storagegateway_gatewayHandler ...
type Aws_storagegateway_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_storagegateway_gatewayHandler) Create(desired *Aws_storagegateway_gateway) (*Aws_storagegateway_gateway, string, error) {
	rState := Aws_storagegateway_gatewayMapper(desired)
	id, err := bridge.Create(h.provider, "aws_storagegateway_gateway", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_storagegateway_gatewayHandler) Read(externalID string) (*Aws_storagegateway_gateway, error) {
	actual, err := bridge.Read(h.provider, "aws_storagegateway_gateway", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_storagegateway_gatewayUnmapper(actual), nil
}

// Delete ...
func (h *Aws_storagegateway_gatewayHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_storagegateway_gateway", externalID)
}

type Aws_emr_cluster struct {
     Aws_emr_cluster_id *string
     Autoscaling_role *string
     Custom_ami_id *string
     Visible_to_all_users *bool
     Service_role string
     Core_instance_type *string
     Keep_job_flow_alive_when_no_steps *bool
     Configurations *string
     Scale_down_behavior *string
     Name string
     Tags *map[string]string
     Configurations_json *string
     Termination_protection *bool
     Security_configuration *string
     Additional_info *string
     Cluster_state *string
     Log_uri *string
     Master_public_dns *string
     Release_label string
     Master_instance_type *string
}


func Aws_emr_clusterMapper(r *Aws_emr_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Autoscaling_role != nil {
    config["autoscaling_role"] = *r.Autoscaling_role
}
if r.Custom_ami_id != nil {
    config["custom_ami_id"] = *r.Custom_ami_id
}
if r.Visible_to_all_users != nil {
    config["visible_to_all_users"] = *r.Visible_to_all_users
}
if r.Core_instance_type != nil {
    config["core_instance_type"] = *r.Core_instance_type
}
if r.Keep_job_flow_alive_when_no_steps != nil {
    config["keep_job_flow_alive_when_no_steps"] = *r.Keep_job_flow_alive_when_no_steps
}
    config["service_role"] = r.Service_role
    config["name"] = r.Name
if r.Configurations != nil {
    config["configurations"] = *r.Configurations
}
if r.Scale_down_behavior != nil {
    config["scale_down_behavior"] = *r.Scale_down_behavior
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Configurations_json != nil {
    config["configurations_json"] = *r.Configurations_json
}
if r.Termination_protection != nil {
    config["termination_protection"] = *r.Termination_protection
}
if r.Additional_info != nil {
    config["additional_info"] = *r.Additional_info
}
if r.Security_configuration != nil {
    config["security_configuration"] = *r.Security_configuration
}
    config["release_label"] = r.Release_label
if r.Master_instance_type != nil {
    config["master_instance_type"] = *r.Master_instance_type
}
if r.Cluster_state != nil {
    config["cluster_state"] = *r.Cluster_state
}
if r.Log_uri != nil {
    config["log_uri"] = *r.Log_uri
}
if r.Master_public_dns != nil {
    config["master_public_dns"] = *r.Master_public_dns
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_emr_clusterUnmapper(state map[string]interface{}) *Aws_emr_cluster {
	r := &Aws_emr_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_emr_cluster_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["configurations_json"]; ok {
	x := x.(string)
	r.Configurations_json = &x
}

if x, ok := state["termination_protection"]; ok {
	x := x.(bool)
	r.Termination_protection = &x
}

if x, ok := state["additional_info"]; ok {
	x := x.(string)
	r.Additional_info = &x
}

if x, ok := state["security_configuration"]; ok {
	x := x.(string)
	r.Security_configuration = &x
}

if x, ok := state["release_label"]; ok {
	r.Release_label = x.(string)
}

if x, ok := state["master_instance_type"]; ok {
	x := x.(string)
	r.Master_instance_type = &x
}

if x, ok := state["cluster_state"]; ok {
	x := x.(string)
	r.Cluster_state = &x
}

if x, ok := state["log_uri"]; ok {
	x := x.(string)
	r.Log_uri = &x
}

if x, ok := state["master_public_dns"]; ok {
	x := x.(string)
	r.Master_public_dns = &x
}

if x, ok := state["autoscaling_role"]; ok {
	x := x.(string)
	r.Autoscaling_role = &x
}

if x, ok := state["custom_ami_id"]; ok {
	x := x.(string)
	r.Custom_ami_id = &x
}

if x, ok := state["visible_to_all_users"]; ok {
	x := x.(bool)
	r.Visible_to_all_users = &x
}

if x, ok := state["core_instance_type"]; ok {
	x := x.(string)
	r.Core_instance_type = &x
}

if x, ok := state["keep_job_flow_alive_when_no_steps"]; ok {
	x := x.(bool)
	r.Keep_job_flow_alive_when_no_steps = &x
}

if x, ok := state["service_role"]; ok {
	r.Service_role = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["configurations"]; ok {
	x := x.(string)
	r.Configurations = &x
}

if x, ok := state["scale_down_behavior"]; ok {
	x := x.(string)
	r.Scale_down_behavior = &x
}
	return r
}


// Aws_emr_clusterHandler ...
type Aws_emr_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_emr_clusterHandler) Create(desired *Aws_emr_cluster) (*Aws_emr_cluster, string, error) {
	rState := Aws_emr_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_emr_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_emr_clusterHandler) Read(externalID string) (*Aws_emr_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_emr_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_emr_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_emr_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_emr_cluster", externalID)
}

type Aws_iam_account_alias struct {
     Aws_iam_account_alias_id *string
     Account_alias string
}


func Aws_iam_account_aliasMapper(r *Aws_iam_account_alias) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["account_alias"] = r.Account_alias
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_account_aliasUnmapper(state map[string]interface{}) *Aws_iam_account_alias {
	r := &Aws_iam_account_alias{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_account_alias_id = &x
}

if x, ok := state["account_alias"]; ok {
	r.Account_alias = x.(string)
}
	return r
}


// Aws_iam_account_aliasHandler ...
type Aws_iam_account_aliasHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_account_aliasHandler) Create(desired *Aws_iam_account_alias) (*Aws_iam_account_alias, string, error) {
	rState := Aws_iam_account_aliasMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_account_alias", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_account_aliasHandler) Read(externalID string) (*Aws_iam_account_alias, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_account_alias", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_account_aliasUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_account_aliasHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_account_alias", externalID)
}

type Aws_dx_private_virtual_interface struct {
     Aws_dx_private_virtual_interface_id *string
     Address_family string
     Connection_id string
     Vpn_gateway_id *string
     Name string
     Bgp_auth_key *string
     Customer_address *string
     Amazon_address *string
     Jumbo_frame_capable *bool
     Tags *map[string]string
     Arn *string
     Dx_gateway_id *string
}


func Aws_dx_private_virtual_interfaceMapper(r *Aws_dx_private_virtual_interface) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Bgp_auth_key != nil {
    config["bgp_auth_key"] = *r.Bgp_auth_key
}
if r.Customer_address != nil {
    config["customer_address"] = *r.Customer_address
}
if r.Amazon_address != nil {
    config["amazon_address"] = *r.Amazon_address
}
if r.Jumbo_frame_capable != nil {
    config["jumbo_frame_capable"] = *r.Jumbo_frame_capable
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Dx_gateway_id != nil {
    config["dx_gateway_id"] = *r.Dx_gateway_id
}
    config["connection_id"] = r.Connection_id
if r.Vpn_gateway_id != nil {
    config["vpn_gateway_id"] = *r.Vpn_gateway_id
}
    config["address_family"] = r.Address_family
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_private_virtual_interfaceUnmapper(state map[string]interface{}) *Aws_dx_private_virtual_interface {
	r := &Aws_dx_private_virtual_interface{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_private_virtual_interface_id = &x
}

if x, ok := state["customer_address"]; ok {
	x := x.(string)
	r.Customer_address = &x
}

if x, ok := state["amazon_address"]; ok {
	x := x.(string)
	r.Amazon_address = &x
}

if x, ok := state["jumbo_frame_capable"]; ok {
	x := x.(bool)
	r.Jumbo_frame_capable = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["dx_gateway_id"]; ok {
	x := x.(string)
	r.Dx_gateway_id = &x
}

if x, ok := state["address_family"]; ok {
	r.Address_family = x.(string)
}

if x, ok := state["connection_id"]; ok {
	r.Connection_id = x.(string)
}

if x, ok := state["vpn_gateway_id"]; ok {
	x := x.(string)
	r.Vpn_gateway_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["bgp_auth_key"]; ok {
	x := x.(string)
	r.Bgp_auth_key = &x
}
	return r
}


// Aws_dx_private_virtual_interfaceHandler ...
type Aws_dx_private_virtual_interfaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_private_virtual_interfaceHandler) Create(desired *Aws_dx_private_virtual_interface) (*Aws_dx_private_virtual_interface, string, error) {
	rState := Aws_dx_private_virtual_interfaceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_private_virtual_interface", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_private_virtual_interfaceHandler) Read(externalID string) (*Aws_dx_private_virtual_interface, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_private_virtual_interface", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_private_virtual_interfaceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_private_virtual_interfaceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_private_virtual_interface", externalID)
}

type Aws_ebs_volume struct {
     Aws_ebs_volume_id *string
     Encrypted *bool
     Snapshot_id *string
     Tags *map[string]string
     Arn *string
     Availability_zone string
     Kms_key_id *string
     Resource_type *string
}


func Aws_ebs_volumeMapper(r *Aws_ebs_volume) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Encrypted != nil {
    config["encrypted"] = *r.Encrypted
}
if r.Snapshot_id != nil {
    config["snapshot_id"] = *r.Snapshot_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["availability_zone"] = r.Availability_zone
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ebs_volumeUnmapper(state map[string]interface{}) *Aws_ebs_volume {
	r := &Aws_ebs_volume{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ebs_volume_id = &x
}

if x, ok := state["encrypted"]; ok {
	x := x.(bool)
	r.Encrypted = &x
}

if x, ok := state["snapshot_id"]; ok {
	x := x.(string)
	r.Snapshot_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["availability_zone"]; ok {
	r.Availability_zone = x.(string)
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}
	return r
}


// Aws_ebs_volumeHandler ...
type Aws_ebs_volumeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ebs_volumeHandler) Create(desired *Aws_ebs_volume) (*Aws_ebs_volume, string, error) {
	rState := Aws_ebs_volumeMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ebs_volume", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ebs_volumeHandler) Read(externalID string) (*Aws_ebs_volume, error) {
	actual, err := bridge.Read(h.provider, "aws_ebs_volume", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ebs_volumeUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ebs_volumeHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ebs_volume", externalID)
}

type Aws_api_gateway_method_response struct {
     Aws_api_gateway_method_response_id *string
     Status_code string
     Response_models *map[string]string
     Response_parameters *map[string]string
     Response_parameters_in_json *string
     Rest_api_id string
     Resource_id string
     Http_method string
}


func Aws_api_gateway_method_responseMapper(r *Aws_api_gateway_method_response) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Response_parameters != nil {
    config["response_parameters"] = *r.Response_parameters
}
if r.Response_parameters_in_json != nil {
    config["response_parameters_in_json"] = *r.Response_parameters_in_json
}
    config["rest_api_id"] = r.Rest_api_id
    config["resource_id"] = r.Resource_id
    config["http_method"] = r.Http_method
    config["status_code"] = r.Status_code
if r.Response_models != nil {
    config["response_models"] = *r.Response_models
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_method_responseUnmapper(state map[string]interface{}) *Aws_api_gateway_method_response {
	r := &Aws_api_gateway_method_response{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_method_response_id = &x
}

if x, ok := state["response_models"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Response_models = &x
}

if x, ok := state["response_parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Response_parameters = &x
}

if x, ok := state["response_parameters_in_json"]; ok {
	x := x.(string)
	r.Response_parameters_in_json = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["resource_id"]; ok {
	r.Resource_id = x.(string)
}

if x, ok := state["http_method"]; ok {
	r.Http_method = x.(string)
}

if x, ok := state["status_code"]; ok {
	r.Status_code = x.(string)
}
	return r
}


// Aws_api_gateway_method_responseHandler ...
type Aws_api_gateway_method_responseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_method_responseHandler) Create(desired *Aws_api_gateway_method_response) (*Aws_api_gateway_method_response, string, error) {
	rState := Aws_api_gateway_method_responseMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_method_response", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_method_responseHandler) Read(externalID string) (*Aws_api_gateway_method_response, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_method_response", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_method_responseUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_method_responseHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_method_response", externalID)
}

type Aws_codebuild_project struct {
     Aws_codebuild_project_id *string
     Description *string
     Service_role string
     Name string
     Tags *map[string]string
     Badge_url *string
     Arn *string
     Encryption_key *string
     Badge_enabled *bool
}


func Aws_codebuild_projectMapper(r *Aws_codebuild_project) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Badge_url != nil {
    config["badge_url"] = *r.Badge_url
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Encryption_key != nil {
    config["encryption_key"] = *r.Encryption_key
}
if r.Badge_enabled != nil {
    config["badge_enabled"] = *r.Badge_enabled
}
if r.Description != nil {
    config["description"] = *r.Description
}
    config["service_role"] = r.Service_role
    config["name"] = r.Name
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_codebuild_projectUnmapper(state map[string]interface{}) *Aws_codebuild_project {
	r := &Aws_codebuild_project{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_codebuild_project_id = &x
}

if x, ok := state["badge_enabled"]; ok {
	x := x.(bool)
	r.Badge_enabled = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["service_role"]; ok {
	r.Service_role = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["encryption_key"]; ok {
	x := x.(string)
	r.Encryption_key = &x
}

if x, ok := state["badge_url"]; ok {
	x := x.(string)
	r.Badge_url = &x
}
	return r
}


// Aws_codebuild_projectHandler ...
type Aws_codebuild_projectHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_codebuild_projectHandler) Create(desired *Aws_codebuild_project) (*Aws_codebuild_project, string, error) {
	rState := Aws_codebuild_projectMapper(desired)
	id, err := bridge.Create(h.provider, "aws_codebuild_project", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_codebuild_projectHandler) Read(externalID string) (*Aws_codebuild_project, error) {
	actual, err := bridge.Read(h.provider, "aws_codebuild_project", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_codebuild_projectUnmapper(actual), nil
}

// Delete ...
func (h *Aws_codebuild_projectHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_codebuild_project", externalID)
}

type Aws_redshift_security_group struct {
     Aws_redshift_security_group_id *string
     Name string
     Description *string
}


func Aws_redshift_security_groupMapper(r *Aws_redshift_security_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_redshift_security_groupUnmapper(state map[string]interface{}) *Aws_redshift_security_group {
	r := &Aws_redshift_security_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_redshift_security_group_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_redshift_security_groupHandler ...
type Aws_redshift_security_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_redshift_security_groupHandler) Create(desired *Aws_redshift_security_group) (*Aws_redshift_security_group, string, error) {
	rState := Aws_redshift_security_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_redshift_security_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_redshift_security_groupHandler) Read(externalID string) (*Aws_redshift_security_group, error) {
	actual, err := bridge.Read(h.provider, "aws_redshift_security_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_redshift_security_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_redshift_security_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_redshift_security_group", externalID)
}

type Aws_pinpoint_apns_sandbox_channel struct {
     Aws_pinpoint_apns_sandbox_channel_id *string
     Bundle_id *string
     Default_authentication_method *string
     Team_id *string
     Private_key *string
     Token_key *string
     Token_key_id *string
     Application_id string
     Certificate *string
     Enabled *bool
}


func Aws_pinpoint_apns_sandbox_channelMapper(r *Aws_pinpoint_apns_sandbox_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Default_authentication_method != nil {
    config["default_authentication_method"] = *r.Default_authentication_method
}
if r.Team_id != nil {
    config["team_id"] = *r.Team_id
}
if r.Bundle_id != nil {
    config["bundle_id"] = *r.Bundle_id
}
if r.Certificate != nil {
    config["certificate"] = *r.Certificate
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.Private_key != nil {
    config["private_key"] = *r.Private_key
}
if r.Token_key != nil {
    config["token_key"] = *r.Token_key
}
if r.Token_key_id != nil {
    config["token_key_id"] = *r.Token_key_id
}
    config["application_id"] = r.Application_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_apns_sandbox_channelUnmapper(state map[string]interface{}) *Aws_pinpoint_apns_sandbox_channel {
	r := &Aws_pinpoint_apns_sandbox_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_apns_sandbox_channel_id = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["private_key"]; ok {
	x := x.(string)
	r.Private_key = &x
}

if x, ok := state["token_key"]; ok {
	x := x.(string)
	r.Token_key = &x
}

if x, ok := state["token_key_id"]; ok {
	x := x.(string)
	r.Token_key_id = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["certificate"]; ok {
	x := x.(string)
	r.Certificate = &x
}

if x, ok := state["team_id"]; ok {
	x := x.(string)
	r.Team_id = &x
}

if x, ok := state["bundle_id"]; ok {
	x := x.(string)
	r.Bundle_id = &x
}

if x, ok := state["default_authentication_method"]; ok {
	x := x.(string)
	r.Default_authentication_method = &x
}
	return r
}


// Aws_pinpoint_apns_sandbox_channelHandler ...
type Aws_pinpoint_apns_sandbox_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_apns_sandbox_channelHandler) Create(desired *Aws_pinpoint_apns_sandbox_channel) (*Aws_pinpoint_apns_sandbox_channel, string, error) {
	rState := Aws_pinpoint_apns_sandbox_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_apns_sandbox_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_apns_sandbox_channelHandler) Read(externalID string) (*Aws_pinpoint_apns_sandbox_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_apns_sandbox_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_apns_sandbox_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_apns_sandbox_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_apns_sandbox_channel", externalID)
}

type Aws_autoscaling_group struct {
     Aws_autoscaling_group_id *string
     Name_prefix *string
     Service_linked_role_arn *string
     Force_delete *bool
     Placement_group *string
     Metrics_granularity *string
     Name *string
     Arn *string
     Wait_for_capacity_timeout *string
     Health_check_type *string
     Protect_from_scale_in *bool
     Launch_configuration *string
}


func Aws_autoscaling_groupMapper(r *Aws_autoscaling_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Wait_for_capacity_timeout != nil {
    config["wait_for_capacity_timeout"] = *r.Wait_for_capacity_timeout
}
if r.Health_check_type != nil {
    config["health_check_type"] = *r.Health_check_type
}
if r.Protect_from_scale_in != nil {
    config["protect_from_scale_in"] = *r.Protect_from_scale_in
}
if r.Launch_configuration != nil {
    config["launch_configuration"] = *r.Launch_configuration
}
if r.Service_linked_role_arn != nil {
    config["service_linked_role_arn"] = *r.Service_linked_role_arn
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Force_delete != nil {
    config["force_delete"] = *r.Force_delete
}
if r.Placement_group != nil {
    config["placement_group"] = *r.Placement_group
}
if r.Metrics_granularity != nil {
    config["metrics_granularity"] = *r.Metrics_granularity
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_autoscaling_groupUnmapper(state map[string]interface{}) *Aws_autoscaling_group {
	r := &Aws_autoscaling_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_autoscaling_group_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["wait_for_capacity_timeout"]; ok {
	x := x.(string)
	r.Wait_for_capacity_timeout = &x
}

if x, ok := state["protect_from_scale_in"]; ok {
	x := x.(bool)
	r.Protect_from_scale_in = &x
}

if x, ok := state["health_check_type"]; ok {
	x := x.(string)
	r.Health_check_type = &x
}

if x, ok := state["launch_configuration"]; ok {
	x := x.(string)
	r.Launch_configuration = &x
}

if x, ok := state["service_linked_role_arn"]; ok {
	x := x.(string)
	r.Service_linked_role_arn = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["placement_group"]; ok {
	x := x.(string)
	r.Placement_group = &x
}

if x, ok := state["force_delete"]; ok {
	x := x.(bool)
	r.Force_delete = &x
}

if x, ok := state["metrics_granularity"]; ok {
	x := x.(string)
	r.Metrics_granularity = &x
}
	return r
}


// Aws_autoscaling_groupHandler ...
type Aws_autoscaling_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_autoscaling_groupHandler) Create(desired *Aws_autoscaling_group) (*Aws_autoscaling_group, string, error) {
	rState := Aws_autoscaling_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_autoscaling_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_autoscaling_groupHandler) Read(externalID string) (*Aws_autoscaling_group, error) {
	actual, err := bridge.Read(h.provider, "aws_autoscaling_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_autoscaling_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_autoscaling_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_autoscaling_group", externalID)
}

type Aws_dynamodb_table_item struct {
     Aws_dynamodb_table_item_id *string
     Table_name string
     Hash_key string
     Range_key *string
     Item string
}


func Aws_dynamodb_table_itemMapper(r *Aws_dynamodb_table_item) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["item"] = r.Item
    config["table_name"] = r.Table_name
    config["hash_key"] = r.Hash_key
if r.Range_key != nil {
    config["range_key"] = *r.Range_key
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dynamodb_table_itemUnmapper(state map[string]interface{}) *Aws_dynamodb_table_item {
	r := &Aws_dynamodb_table_item{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dynamodb_table_item_id = &x
}

if x, ok := state["table_name"]; ok {
	r.Table_name = x.(string)
}

if x, ok := state["hash_key"]; ok {
	r.Hash_key = x.(string)
}

if x, ok := state["range_key"]; ok {
	x := x.(string)
	r.Range_key = &x
}

if x, ok := state["item"]; ok {
	r.Item = x.(string)
}
	return r
}


// Aws_dynamodb_table_itemHandler ...
type Aws_dynamodb_table_itemHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dynamodb_table_itemHandler) Create(desired *Aws_dynamodb_table_item) (*Aws_dynamodb_table_item, string, error) {
	rState := Aws_dynamodb_table_itemMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dynamodb_table_item", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dynamodb_table_itemHandler) Read(externalID string) (*Aws_dynamodb_table_item, error) {
	actual, err := bridge.Read(h.provider, "aws_dynamodb_table_item", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dynamodb_table_itemUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dynamodb_table_itemHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dynamodb_table_item", externalID)
}

type Aws_redshift_cluster struct {
     Aws_redshift_cluster_id *string
     Allow_version_upgrade *bool
     Enhanced_vpc_routing *bool
     Cluster_parameter_group_name *string
     Publicly_accessible *bool
     Kms_key_id *string
     Enable_logging *bool
     Tags *map[string]string
     Node_type string
     S3_key_prefix *string
     Database_name *string
     Cluster_subnet_group_name *string
     Owner_account *string
     Preferred_maintenance_window *string
     Elastic_ip *string
     Encrypted *bool
     Skip_final_snapshot *bool
     Dns_name *string
     Snapshot_identifier *string
     Master_username *string
     Master_password *string
     Final_snapshot_identifier *string
     Endpoint *string
     Snapshot_cluster_identifier *string
     Cluster_type *string
     Availability_zone *string
     Cluster_public_key *string
     Bucket_name *string
     Cluster_identifier string
     Cluster_version *string
     Cluster_revision_number *string
}


func Aws_redshift_clusterMapper(r *Aws_redshift_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Final_snapshot_identifier != nil {
    config["final_snapshot_identifier"] = *r.Final_snapshot_identifier
}
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
if r.Snapshot_cluster_identifier != nil {
    config["snapshot_cluster_identifier"] = *r.Snapshot_cluster_identifier
}
if r.Cluster_type != nil {
    config["cluster_type"] = *r.Cluster_type
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Bucket_name != nil {
    config["bucket_name"] = *r.Bucket_name
}
    config["cluster_identifier"] = r.Cluster_identifier
if r.Cluster_version != nil {
    config["cluster_version"] = *r.Cluster_version
}
if r.Cluster_public_key != nil {
    config["cluster_public_key"] = *r.Cluster_public_key
}
if r.Cluster_revision_number != nil {
    config["cluster_revision_number"] = *r.Cluster_revision_number
}
if r.Enhanced_vpc_routing != nil {
    config["enhanced_vpc_routing"] = *r.Enhanced_vpc_routing
}
if r.Cluster_parameter_group_name != nil {
    config["cluster_parameter_group_name"] = *r.Cluster_parameter_group_name
}
if r.Allow_version_upgrade != nil {
    config["allow_version_upgrade"] = *r.Allow_version_upgrade
}
if r.Publicly_accessible != nil {
    config["publicly_accessible"] = *r.Publicly_accessible
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Enable_logging != nil {
    config["enable_logging"] = *r.Enable_logging
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["node_type"] = r.Node_type
if r.Database_name != nil {
    config["database_name"] = *r.Database_name
}
if r.Cluster_subnet_group_name != nil {
    config["cluster_subnet_group_name"] = *r.Cluster_subnet_group_name
}
if r.S3_key_prefix != nil {
    config["s3_key_prefix"] = *r.S3_key_prefix
}
if r.Owner_account != nil {
    config["owner_account"] = *r.Owner_account
}
if r.Preferred_maintenance_window != nil {
    config["preferred_maintenance_window"] = *r.Preferred_maintenance_window
}
if r.Elastic_ip != nil {
    config["elastic_ip"] = *r.Elastic_ip
}
if r.Encrypted != nil {
    config["encrypted"] = *r.Encrypted
}
if r.Skip_final_snapshot != nil {
    config["skip_final_snapshot"] = *r.Skip_final_snapshot
}
if r.Dns_name != nil {
    config["dns_name"] = *r.Dns_name
}
if r.Snapshot_identifier != nil {
    config["snapshot_identifier"] = *r.Snapshot_identifier
}
if r.Master_username != nil {
    config["master_username"] = *r.Master_username
}
if r.Master_password != nil {
    config["master_password"] = *r.Master_password
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_redshift_clusterUnmapper(state map[string]interface{}) *Aws_redshift_cluster {
	r := &Aws_redshift_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_redshift_cluster_id = &x
}

if x, ok := state["cluster_type"]; ok {
	x := x.(string)
	r.Cluster_type = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["final_snapshot_identifier"]; ok {
	x := x.(string)
	r.Final_snapshot_identifier = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["snapshot_cluster_identifier"]; ok {
	x := x.(string)
	r.Snapshot_cluster_identifier = &x
}

if x, ok := state["cluster_identifier"]; ok {
	r.Cluster_identifier = x.(string)
}

if x, ok := state["cluster_version"]; ok {
	x := x.(string)
	r.Cluster_version = &x
}

if x, ok := state["cluster_public_key"]; ok {
	x := x.(string)
	r.Cluster_public_key = &x
}

if x, ok := state["bucket_name"]; ok {
	x := x.(string)
	r.Bucket_name = &x
}

if x, ok := state["cluster_revision_number"]; ok {
	x := x.(string)
	r.Cluster_revision_number = &x
}

if x, ok := state["cluster_parameter_group_name"]; ok {
	x := x.(string)
	r.Cluster_parameter_group_name = &x
}

if x, ok := state["allow_version_upgrade"]; ok {
	x := x.(bool)
	r.Allow_version_upgrade = &x
}

if x, ok := state["enhanced_vpc_routing"]; ok {
	x := x.(bool)
	r.Enhanced_vpc_routing = &x
}

if x, ok := state["node_type"]; ok {
	r.Node_type = x.(string)
}

if x, ok := state["publicly_accessible"]; ok {
	x := x.(bool)
	r.Publicly_accessible = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["enable_logging"]; ok {
	x := x.(bool)
	r.Enable_logging = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["database_name"]; ok {
	x := x.(string)
	r.Database_name = &x
}

if x, ok := state["cluster_subnet_group_name"]; ok {
	x := x.(string)
	r.Cluster_subnet_group_name = &x
}

if x, ok := state["s3_key_prefix"]; ok {
	x := x.(string)
	r.S3_key_prefix = &x
}

if x, ok := state["preferred_maintenance_window"]; ok {
	x := x.(string)
	r.Preferred_maintenance_window = &x
}

if x, ok := state["elastic_ip"]; ok {
	x := x.(string)
	r.Elastic_ip = &x
}

if x, ok := state["owner_account"]; ok {
	x := x.(string)
	r.Owner_account = &x
}

if x, ok := state["master_username"]; ok {
	x := x.(string)
	r.Master_username = &x
}

if x, ok := state["master_password"]; ok {
	x := x.(string)
	r.Master_password = &x
}

if x, ok := state["encrypted"]; ok {
	x := x.(bool)
	r.Encrypted = &x
}

if x, ok := state["skip_final_snapshot"]; ok {
	x := x.(bool)
	r.Skip_final_snapshot = &x
}

if x, ok := state["dns_name"]; ok {
	x := x.(string)
	r.Dns_name = &x
}

if x, ok := state["snapshot_identifier"]; ok {
	x := x.(string)
	r.Snapshot_identifier = &x
}
	return r
}


// Aws_redshift_clusterHandler ...
type Aws_redshift_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_redshift_clusterHandler) Create(desired *Aws_redshift_cluster) (*Aws_redshift_cluster, string, error) {
	rState := Aws_redshift_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_redshift_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_redshift_clusterHandler) Read(externalID string) (*Aws_redshift_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_redshift_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_redshift_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_redshift_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_redshift_cluster", externalID)
}

type Aws_ses_template struct {
     Aws_ses_template_id *string
     Name string
     Html *string
     Subject *string
     Text *string
}


func Aws_ses_templateMapper(r *Aws_ses_template) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Subject != nil {
    config["subject"] = *r.Subject
}
if r.Text != nil {
    config["text"] = *r.Text
}
    config["name"] = r.Name
if r.Html != nil {
    config["html"] = *r.Html
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_templateUnmapper(state map[string]interface{}) *Aws_ses_template {
	r := &Aws_ses_template{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_template_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["html"]; ok {
	x := x.(string)
	r.Html = &x
}

if x, ok := state["subject"]; ok {
	x := x.(string)
	r.Subject = &x
}

if x, ok := state["text"]; ok {
	x := x.(string)
	r.Text = &x
}
	return r
}


// Aws_ses_templateHandler ...
type Aws_ses_templateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_templateHandler) Create(desired *Aws_ses_template) (*Aws_ses_template, string, error) {
	rState := Aws_ses_templateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_template", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_templateHandler) Read(externalID string) (*Aws_ses_template, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_template", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_templateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_templateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_template", externalID)
}

type Aws_alb_listener_rule struct {
     Aws_alb_listener_rule_id *string
     Arn *string
     Listener_arn string
}


func Aws_alb_listener_ruleMapper(r *Aws_alb_listener_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["listener_arn"] = r.Listener_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_alb_listener_ruleUnmapper(state map[string]interface{}) *Aws_alb_listener_rule {
	r := &Aws_alb_listener_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_alb_listener_rule_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["listener_arn"]; ok {
	r.Listener_arn = x.(string)
}
	return r
}


// Aws_alb_listener_ruleHandler ...
type Aws_alb_listener_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_alb_listener_ruleHandler) Create(desired *Aws_alb_listener_rule) (*Aws_alb_listener_rule, string, error) {
	rState := Aws_alb_listener_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_alb_listener_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_alb_listener_ruleHandler) Read(externalID string) (*Aws_alb_listener_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_alb_listener_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_alb_listener_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_alb_listener_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_alb_listener_rule", externalID)
}

type Aws_api_gateway_documentation_part struct {
     Aws_api_gateway_documentation_part_id *string
     Properties string
     Rest_api_id string
}


func Aws_api_gateway_documentation_partMapper(r *Aws_api_gateway_documentation_part) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["properties"] = r.Properties
    config["rest_api_id"] = r.Rest_api_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_documentation_partUnmapper(state map[string]interface{}) *Aws_api_gateway_documentation_part {
	r := &Aws_api_gateway_documentation_part{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_documentation_part_id = &x
}

if x, ok := state["properties"]; ok {
	r.Properties = x.(string)
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}
	return r
}


// Aws_api_gateway_documentation_partHandler ...
type Aws_api_gateway_documentation_partHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_documentation_partHandler) Create(desired *Aws_api_gateway_documentation_part) (*Aws_api_gateway_documentation_part, string, error) {
	rState := Aws_api_gateway_documentation_partMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_documentation_part", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_documentation_partHandler) Read(externalID string) (*Aws_api_gateway_documentation_part, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_documentation_part", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_documentation_partUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_documentation_partHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_documentation_part", externalID)
}

type Aws_iam_openid_connect_provider struct {
     Aws_iam_openid_connect_provider_id *string
     Arn *string
     Url string
}


func Aws_iam_openid_connect_providerMapper(r *Aws_iam_openid_connect_provider) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["url"] = r.Url
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_openid_connect_providerUnmapper(state map[string]interface{}) *Aws_iam_openid_connect_provider {
	r := &Aws_iam_openid_connect_provider{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_openid_connect_provider_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["url"]; ok {
	r.Url = x.(string)
}
	return r
}


// Aws_iam_openid_connect_providerHandler ...
type Aws_iam_openid_connect_providerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_openid_connect_providerHandler) Create(desired *Aws_iam_openid_connect_provider) (*Aws_iam_openid_connect_provider, string, error) {
	rState := Aws_iam_openid_connect_providerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_openid_connect_provider", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_openid_connect_providerHandler) Read(externalID string) (*Aws_iam_openid_connect_provider, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_openid_connect_provider", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_openid_connect_providerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_openid_connect_providerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_openid_connect_provider", externalID)
}

type Aws_ses_domain_mail_from struct {
     Aws_ses_domain_mail_from_id *string
     Domain string
     Mail_from_domain string
     Behavior_on_mx_failure *string
}


func Aws_ses_domain_mail_fromMapper(r *Aws_ses_domain_mail_from) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["domain"] = r.Domain
    config["mail_from_domain"] = r.Mail_from_domain
if r.Behavior_on_mx_failure != nil {
    config["behavior_on_mx_failure"] = *r.Behavior_on_mx_failure
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_domain_mail_fromUnmapper(state map[string]interface{}) *Aws_ses_domain_mail_from {
	r := &Aws_ses_domain_mail_from{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_domain_mail_from_id = &x
}

if x, ok := state["domain"]; ok {
	r.Domain = x.(string)
}

if x, ok := state["mail_from_domain"]; ok {
	r.Mail_from_domain = x.(string)
}

if x, ok := state["behavior_on_mx_failure"]; ok {
	x := x.(string)
	r.Behavior_on_mx_failure = &x
}
	return r
}


// Aws_ses_domain_mail_fromHandler ...
type Aws_ses_domain_mail_fromHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_domain_mail_fromHandler) Create(desired *Aws_ses_domain_mail_from) (*Aws_ses_domain_mail_from, string, error) {
	rState := Aws_ses_domain_mail_fromMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_domain_mail_from", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_domain_mail_fromHandler) Read(externalID string) (*Aws_ses_domain_mail_from, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_domain_mail_from", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_domain_mail_fromUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_domain_mail_fromHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_domain_mail_from", externalID)
}

type Aws_swf_domain struct {
     Aws_swf_domain_id *string
     Workflow_execution_retention_period_in_days string
     Name *string
     Name_prefix *string
     Description *string
}


func Aws_swf_domainMapper(r *Aws_swf_domain) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Description != nil {
    config["description"] = *r.Description
}
    config["workflow_execution_retention_period_in_days"] = r.Workflow_execution_retention_period_in_days
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_swf_domainUnmapper(state map[string]interface{}) *Aws_swf_domain {
	r := &Aws_swf_domain{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_swf_domain_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["workflow_execution_retention_period_in_days"]; ok {
	r.Workflow_execution_retention_period_in_days = x.(string)
}
	return r
}


// Aws_swf_domainHandler ...
type Aws_swf_domainHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_swf_domainHandler) Create(desired *Aws_swf_domain) (*Aws_swf_domain, string, error) {
	rState := Aws_swf_domainMapper(desired)
	id, err := bridge.Create(h.provider, "aws_swf_domain", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_swf_domainHandler) Read(externalID string) (*Aws_swf_domain, error) {
	actual, err := bridge.Read(h.provider, "aws_swf_domain", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_swf_domainUnmapper(actual), nil
}

// Delete ...
func (h *Aws_swf_domainHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_swf_domain", externalID)
}

type Aws_vpn_gateway_attachment struct {
     Aws_vpn_gateway_attachment_id *string
     Vpc_id string
     Vpn_gateway_id string
}


func Aws_vpn_gateway_attachmentMapper(r *Aws_vpn_gateway_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpn_gateway_id"] = r.Vpn_gateway_id
    config["vpc_id"] = r.Vpc_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpn_gateway_attachmentUnmapper(state map[string]interface{}) *Aws_vpn_gateway_attachment {
	r := &Aws_vpn_gateway_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpn_gateway_attachment_id = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["vpn_gateway_id"]; ok {
	r.Vpn_gateway_id = x.(string)
}
	return r
}


// Aws_vpn_gateway_attachmentHandler ...
type Aws_vpn_gateway_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpn_gateway_attachmentHandler) Create(desired *Aws_vpn_gateway_attachment) (*Aws_vpn_gateway_attachment, string, error) {
	rState := Aws_vpn_gateway_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpn_gateway_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpn_gateway_attachmentHandler) Read(externalID string) (*Aws_vpn_gateway_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_vpn_gateway_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpn_gateway_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpn_gateway_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpn_gateway_attachment", externalID)
}

type Aws_cloudwatch_log_group struct {
     Aws_cloudwatch_log_group_id *string
     Kms_key_id *string
     Arn *string
     Tags *map[string]string
     Name *string
     Name_prefix *string
}


func Aws_cloudwatch_log_groupMapper(r *Aws_cloudwatch_log_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_log_groupUnmapper(state map[string]interface{}) *Aws_cloudwatch_log_group {
	r := &Aws_cloudwatch_log_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_log_group_id = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}
	return r
}


// Aws_cloudwatch_log_groupHandler ...
type Aws_cloudwatch_log_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_log_groupHandler) Create(desired *Aws_cloudwatch_log_group) (*Aws_cloudwatch_log_group, string, error) {
	rState := Aws_cloudwatch_log_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_log_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_log_groupHandler) Read(externalID string) (*Aws_cloudwatch_log_group, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_log_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_log_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_log_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_log_group", externalID)
}

type Aws_codecommit_repository struct {
     Aws_codecommit_repository_id *string
     Clone_url_ssh *string
     Default_branch *string
     Repository_name string
     Description *string
     Arn *string
     Repository_id *string
     Clone_url_http *string
}


func Aws_codecommit_repositoryMapper(r *Aws_codecommit_repository) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["repository_name"] = r.Repository_name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Repository_id != nil {
    config["repository_id"] = *r.Repository_id
}
if r.Clone_url_http != nil {
    config["clone_url_http"] = *r.Clone_url_http
}
if r.Clone_url_ssh != nil {
    config["clone_url_ssh"] = *r.Clone_url_ssh
}
if r.Default_branch != nil {
    config["default_branch"] = *r.Default_branch
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_codecommit_repositoryUnmapper(state map[string]interface{}) *Aws_codecommit_repository {
	r := &Aws_codecommit_repository{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_codecommit_repository_id = &x
}

if x, ok := state["repository_name"]; ok {
	r.Repository_name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["repository_id"]; ok {
	x := x.(string)
	r.Repository_id = &x
}

if x, ok := state["clone_url_http"]; ok {
	x := x.(string)
	r.Clone_url_http = &x
}

if x, ok := state["clone_url_ssh"]; ok {
	x := x.(string)
	r.Clone_url_ssh = &x
}

if x, ok := state["default_branch"]; ok {
	x := x.(string)
	r.Default_branch = &x
}
	return r
}


// Aws_codecommit_repositoryHandler ...
type Aws_codecommit_repositoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_codecommit_repositoryHandler) Create(desired *Aws_codecommit_repository) (*Aws_codecommit_repository, string, error) {
	rState := Aws_codecommit_repositoryMapper(desired)
	id, err := bridge.Create(h.provider, "aws_codecommit_repository", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_codecommit_repositoryHandler) Read(externalID string) (*Aws_codecommit_repository, error) {
	actual, err := bridge.Read(h.provider, "aws_codecommit_repository", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_codecommit_repositoryUnmapper(actual), nil
}

// Delete ...
func (h *Aws_codecommit_repositoryHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_codecommit_repository", externalID)
}

type Aws_proxy_protocol_policy struct {
     Aws_proxy_protocol_policy_id *string
     Load_balancer string
}


func Aws_proxy_protocol_policyMapper(r *Aws_proxy_protocol_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["load_balancer"] = r.Load_balancer
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_proxy_protocol_policyUnmapper(state map[string]interface{}) *Aws_proxy_protocol_policy {
	r := &Aws_proxy_protocol_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_proxy_protocol_policy_id = &x
}

if x, ok := state["load_balancer"]; ok {
	r.Load_balancer = x.(string)
}
	return r
}


// Aws_proxy_protocol_policyHandler ...
type Aws_proxy_protocol_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_proxy_protocol_policyHandler) Create(desired *Aws_proxy_protocol_policy) (*Aws_proxy_protocol_policy, string, error) {
	rState := Aws_proxy_protocol_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_proxy_protocol_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_proxy_protocol_policyHandler) Read(externalID string) (*Aws_proxy_protocol_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_proxy_protocol_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_proxy_protocol_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_proxy_protocol_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_proxy_protocol_policy", externalID)
}

type Aws_elasticsearch_domain struct {
     Aws_elasticsearch_domain_id *string
     Domain_name string
     Access_policies *string
     Advanced_options *map[string]string
     Arn *string
     Endpoint *string
     Domain_id *string
     Kibana_endpoint *string
     Elasticsearch_version *string
     Tags *map[string]string
}


func Aws_elasticsearch_domainMapper(r *Aws_elasticsearch_domain) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Access_policies != nil {
    config["access_policies"] = *r.Access_policies
}
if r.Advanced_options != nil {
    config["advanced_options"] = *r.Advanced_options
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
if r.Domain_id != nil {
    config["domain_id"] = *r.Domain_id
}
if r.Kibana_endpoint != nil {
    config["kibana_endpoint"] = *r.Kibana_endpoint
}
if r.Elasticsearch_version != nil {
    config["elasticsearch_version"] = *r.Elasticsearch_version
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["domain_name"] = r.Domain_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elasticsearch_domainUnmapper(state map[string]interface{}) *Aws_elasticsearch_domain {
	r := &Aws_elasticsearch_domain{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elasticsearch_domain_id = &x
}

if x, ok := state["elasticsearch_version"]; ok {
	x := x.(string)
	r.Elasticsearch_version = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["domain_name"]; ok {
	r.Domain_name = x.(string)
}

if x, ok := state["advanced_options"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Advanced_options = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["access_policies"]; ok {
	x := x.(string)
	r.Access_policies = &x
}

if x, ok := state["kibana_endpoint"]; ok {
	x := x.(string)
	r.Kibana_endpoint = &x
}

if x, ok := state["domain_id"]; ok {
	x := x.(string)
	r.Domain_id = &x
}
	return r
}


// Aws_elasticsearch_domainHandler ...
type Aws_elasticsearch_domainHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elasticsearch_domainHandler) Create(desired *Aws_elasticsearch_domain) (*Aws_elasticsearch_domain, string, error) {
	rState := Aws_elasticsearch_domainMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elasticsearch_domain", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elasticsearch_domainHandler) Read(externalID string) (*Aws_elasticsearch_domain, error) {
	actual, err := bridge.Read(h.provider, "aws_elasticsearch_domain", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elasticsearch_domainUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elasticsearch_domainHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elasticsearch_domain", externalID)
}

type Aws_lambda_event_source_mapping struct {
     Aws_lambda_event_source_mapping_id *string
     Last_modified *string
     Last_processing_result *string
     Event_source_arn string
     Function_name string
     Starting_position *string
     Enabled *bool
     Function_arn *string
     State *string
     State_transition_reason *string
     Starting_position_timestamp *string
     Uuid *string
}


func Aws_lambda_event_source_mappingMapper(r *Aws_lambda_event_source_mapping) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Function_arn != nil {
    config["function_arn"] = *r.Function_arn
}
if r.Last_modified != nil {
    config["last_modified"] = *r.Last_modified
}
if r.Last_processing_result != nil {
    config["last_processing_result"] = *r.Last_processing_result
}
    config["event_source_arn"] = r.Event_source_arn
    config["function_name"] = r.Function_name
if r.Starting_position != nil {
    config["starting_position"] = *r.Starting_position
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.State != nil {
    config["state"] = *r.State
}
if r.State_transition_reason != nil {
    config["state_transition_reason"] = *r.State_transition_reason
}
if r.Starting_position_timestamp != nil {
    config["starting_position_timestamp"] = *r.Starting_position_timestamp
}
if r.Uuid != nil {
    config["uuid"] = *r.Uuid
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lambda_event_source_mappingUnmapper(state map[string]interface{}) *Aws_lambda_event_source_mapping {
	r := &Aws_lambda_event_source_mapping{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lambda_event_source_mapping_id = &x
}

if x, ok := state["starting_position_timestamp"]; ok {
	x := x.(string)
	r.Starting_position_timestamp = &x
}

if x, ok := state["uuid"]; ok {
	x := x.(string)
	r.Uuid = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["function_arn"]; ok {
	x := x.(string)
	r.Function_arn = &x
}

if x, ok := state["last_modified"]; ok {
	x := x.(string)
	r.Last_modified = &x
}

if x, ok := state["last_processing_result"]; ok {
	x := x.(string)
	r.Last_processing_result = &x
}

if x, ok := state["event_source_arn"]; ok {
	r.Event_source_arn = x.(string)
}

if x, ok := state["function_name"]; ok {
	r.Function_name = x.(string)
}

if x, ok := state["starting_position"]; ok {
	x := x.(string)
	r.Starting_position = &x
}

if x, ok := state["state"]; ok {
	x := x.(string)
	r.State = &x
}

if x, ok := state["state_transition_reason"]; ok {
	x := x.(string)
	r.State_transition_reason = &x
}
	return r
}


// Aws_lambda_event_source_mappingHandler ...
type Aws_lambda_event_source_mappingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lambda_event_source_mappingHandler) Create(desired *Aws_lambda_event_source_mapping) (*Aws_lambda_event_source_mapping, string, error) {
	rState := Aws_lambda_event_source_mappingMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lambda_event_source_mapping", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lambda_event_source_mappingHandler) Read(externalID string) (*Aws_lambda_event_source_mapping, error) {
	actual, err := bridge.Read(h.provider, "aws_lambda_event_source_mapping", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lambda_event_source_mappingUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lambda_event_source_mappingHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lambda_event_source_mapping", externalID)
}

type Aws_network_interface struct {
     Aws_network_interface_id *string
     Private_ip *string
     Description *string
     Subnet_id string
     Source_dest_check *bool
     Tags *map[string]string
     Private_dns_name *string
}


func Aws_network_interfaceMapper(r *Aws_network_interface) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Private_dns_name != nil {
    config["private_dns_name"] = *r.Private_dns_name
}
if r.Source_dest_check != nil {
    config["source_dest_check"] = *r.Source_dest_check
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Description != nil {
    config["description"] = *r.Description
}
    config["subnet_id"] = r.Subnet_id
if r.Private_ip != nil {
    config["private_ip"] = *r.Private_ip
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_network_interfaceUnmapper(state map[string]interface{}) *Aws_network_interface {
	r := &Aws_network_interface{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_network_interface_id = &x
}

if x, ok := state["private_dns_name"]; ok {
	x := x.(string)
	r.Private_dns_name = &x
}

if x, ok := state["source_dest_check"]; ok {
	x := x.(bool)
	r.Source_dest_check = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["subnet_id"]; ok {
	r.Subnet_id = x.(string)
}

if x, ok := state["private_ip"]; ok {
	x := x.(string)
	r.Private_ip = &x
}
	return r
}


// Aws_network_interfaceHandler ...
type Aws_network_interfaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_network_interfaceHandler) Create(desired *Aws_network_interface) (*Aws_network_interface, string, error) {
	rState := Aws_network_interfaceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_network_interface", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_network_interfaceHandler) Read(externalID string) (*Aws_network_interface, error) {
	actual, err := bridge.Read(h.provider, "aws_network_interface", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_network_interfaceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_network_interfaceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_network_interface", externalID)
}

type Aws_ssm_maintenance_window_target struct {
     Aws_ssm_maintenance_window_target_id *string
     Window_id string
     Resource_type string
     Owner_information *string
}


func Aws_ssm_maintenance_window_targetMapper(r *Aws_ssm_maintenance_window_target) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["window_id"] = r.Window_id
    config["resource_type"] = r.Resource_type
if r.Owner_information != nil {
    config["owner_information"] = *r.Owner_information
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_maintenance_window_targetUnmapper(state map[string]interface{}) *Aws_ssm_maintenance_window_target {
	r := &Aws_ssm_maintenance_window_target{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_maintenance_window_target_id = &x
}

if x, ok := state["owner_information"]; ok {
	x := x.(string)
	r.Owner_information = &x
}

if x, ok := state["window_id"]; ok {
	r.Window_id = x.(string)
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}
	return r
}


// Aws_ssm_maintenance_window_targetHandler ...
type Aws_ssm_maintenance_window_targetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_maintenance_window_targetHandler) Create(desired *Aws_ssm_maintenance_window_target) (*Aws_ssm_maintenance_window_target, string, error) {
	rState := Aws_ssm_maintenance_window_targetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_maintenance_window_target", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_maintenance_window_targetHandler) Read(externalID string) (*Aws_ssm_maintenance_window_target, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_maintenance_window_target", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_maintenance_window_targetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_maintenance_window_targetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_maintenance_window_target", externalID)
}

type Aws_cognito_user_pool_client struct {
     Aws_cognito_user_pool_client_id *string
     Default_redirect_uri *string
     Client_secret *string
     Generate_secret *bool
     Allowed_oauth_flows_user_pool_client *bool
     Name string
     User_pool_id string
}


func Aws_cognito_user_pool_clientMapper(r *Aws_cognito_user_pool_client) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Default_redirect_uri != nil {
    config["default_redirect_uri"] = *r.Default_redirect_uri
}
if r.Client_secret != nil {
    config["client_secret"] = *r.Client_secret
}
if r.Generate_secret != nil {
    config["generate_secret"] = *r.Generate_secret
}
if r.Allowed_oauth_flows_user_pool_client != nil {
    config["allowed_oauth_flows_user_pool_client"] = *r.Allowed_oauth_flows_user_pool_client
}
    config["name"] = r.Name
    config["user_pool_id"] = r.User_pool_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cognito_user_pool_clientUnmapper(state map[string]interface{}) *Aws_cognito_user_pool_client {
	r := &Aws_cognito_user_pool_client{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cognito_user_pool_client_id = &x
}

if x, ok := state["user_pool_id"]; ok {
	r.User_pool_id = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["generate_secret"]; ok {
	x := x.(bool)
	r.Generate_secret = &x
}

if x, ok := state["allowed_oauth_flows_user_pool_client"]; ok {
	x := x.(bool)
	r.Allowed_oauth_flows_user_pool_client = &x
}

if x, ok := state["default_redirect_uri"]; ok {
	x := x.(string)
	r.Default_redirect_uri = &x
}

if x, ok := state["client_secret"]; ok {
	x := x.(string)
	r.Client_secret = &x
}
	return r
}


// Aws_cognito_user_pool_clientHandler ...
type Aws_cognito_user_pool_clientHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cognito_user_pool_clientHandler) Create(desired *Aws_cognito_user_pool_client) (*Aws_cognito_user_pool_client, string, error) {
	rState := Aws_cognito_user_pool_clientMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cognito_user_pool_client", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cognito_user_pool_clientHandler) Read(externalID string) (*Aws_cognito_user_pool_client, error) {
	actual, err := bridge.Read(h.provider, "aws_cognito_user_pool_client", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cognito_user_pool_clientUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cognito_user_pool_clientHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cognito_user_pool_client", externalID)
}

type Aws_devicefarm_project struct {
     Aws_devicefarm_project_id *string
     Arn *string
     Name string
}


func Aws_devicefarm_projectMapper(r *Aws_devicefarm_project) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_devicefarm_projectUnmapper(state map[string]interface{}) *Aws_devicefarm_project {
	r := &Aws_devicefarm_project{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_devicefarm_project_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_devicefarm_projectHandler ...
type Aws_devicefarm_projectHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_devicefarm_projectHandler) Create(desired *Aws_devicefarm_project) (*Aws_devicefarm_project, string, error) {
	rState := Aws_devicefarm_projectMapper(desired)
	id, err := bridge.Create(h.provider, "aws_devicefarm_project", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_devicefarm_projectHandler) Read(externalID string) (*Aws_devicefarm_project, error) {
	actual, err := bridge.Read(h.provider, "aws_devicefarm_project", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_devicefarm_projectUnmapper(actual), nil
}

// Delete ...
func (h *Aws_devicefarm_projectHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_devicefarm_project", externalID)
}

type Aws_securityhub_product_subscription struct {
     Aws_securityhub_product_subscription_id *string
     Product_arn string
     Arn *string
}


func Aws_securityhub_product_subscriptionMapper(r *Aws_securityhub_product_subscription) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["product_arn"] = r.Product_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_securityhub_product_subscriptionUnmapper(state map[string]interface{}) *Aws_securityhub_product_subscription {
	r := &Aws_securityhub_product_subscription{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_securityhub_product_subscription_id = &x
}

if x, ok := state["product_arn"]; ok {
	r.Product_arn = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_securityhub_product_subscriptionHandler ...
type Aws_securityhub_product_subscriptionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_securityhub_product_subscriptionHandler) Create(desired *Aws_securityhub_product_subscription) (*Aws_securityhub_product_subscription, string, error) {
	rState := Aws_securityhub_product_subscriptionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_securityhub_product_subscription", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_securityhub_product_subscriptionHandler) Read(externalID string) (*Aws_securityhub_product_subscription, error) {
	actual, err := bridge.Read(h.provider, "aws_securityhub_product_subscription", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_securityhub_product_subscriptionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_securityhub_product_subscriptionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_securityhub_product_subscription", externalID)
}

type Aws_eks_cluster struct {
     Aws_eks_cluster_id *string
     Name string
     Platform_version *string
     Arn *string
     Endpoint *string
     Created_at *string
     Role_arn string
     Version *string
}


func Aws_eks_clusterMapper(r *Aws_eks_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["role_arn"] = r.Role_arn
if r.Version != nil {
    config["version"] = *r.Version
}
if r.Created_at != nil {
    config["created_at"] = *r.Created_at
}
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
    config["name"] = r.Name
if r.Platform_version != nil {
    config["platform_version"] = *r.Platform_version
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_eks_clusterUnmapper(state map[string]interface{}) *Aws_eks_cluster {
	r := &Aws_eks_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_eks_cluster_id = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["platform_version"]; ok {
	x := x.(string)
	r.Platform_version = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["version"]; ok {
	x := x.(string)
	r.Version = &x
}

if x, ok := state["created_at"]; ok {
	x := x.(string)
	r.Created_at = &x
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}
	return r
}


// Aws_eks_clusterHandler ...
type Aws_eks_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_eks_clusterHandler) Create(desired *Aws_eks_cluster) (*Aws_eks_cluster, string, error) {
	rState := Aws_eks_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_eks_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_eks_clusterHandler) Read(externalID string) (*Aws_eks_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_eks_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_eks_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_eks_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_eks_cluster", externalID)
}

type Aws_elastictranscoder_preset struct {
     Aws_elastictranscoder_preset_id *string
     Resource_type *string
     Arn *string
     Container string
     Description *string
     Name *string
     Video_codec_options *map[string]string
}


func Aws_elastictranscoder_presetMapper(r *Aws_elastictranscoder_preset) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Video_codec_options != nil {
    config["video_codec_options"] = *r.Video_codec_options
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["container"] = r.Container
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elastictranscoder_presetUnmapper(state map[string]interface{}) *Aws_elastictranscoder_preset {
	r := &Aws_elastictranscoder_preset{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elastictranscoder_preset_id = &x
}

if x, ok := state["video_codec_options"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Video_codec_options = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["container"]; ok {
	r.Container = x.(string)
}
	return r
}


// Aws_elastictranscoder_presetHandler ...
type Aws_elastictranscoder_presetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elastictranscoder_presetHandler) Create(desired *Aws_elastictranscoder_preset) (*Aws_elastictranscoder_preset, string, error) {
	rState := Aws_elastictranscoder_presetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elastictranscoder_preset", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elastictranscoder_presetHandler) Read(externalID string) (*Aws_elastictranscoder_preset, error) {
	actual, err := bridge.Read(h.provider, "aws_elastictranscoder_preset", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elastictranscoder_presetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elastictranscoder_presetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elastictranscoder_preset", externalID)
}

type Aws_organizations_policy struct {
     Aws_organizations_policy_id *string
     Content string
     Description *string
     Name string
     Resource_type *string
     Arn *string
}


func Aws_organizations_policyMapper(r *Aws_organizations_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["content"] = r.Content
if r.Description != nil {
    config["description"] = *r.Description
}
    config["name"] = r.Name
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_organizations_policyUnmapper(state map[string]interface{}) *Aws_organizations_policy {
	r := &Aws_organizations_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_organizations_policy_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["content"]; ok {
	r.Content = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_organizations_policyHandler ...
type Aws_organizations_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_organizations_policyHandler) Create(desired *Aws_organizations_policy) (*Aws_organizations_policy, string, error) {
	rState := Aws_organizations_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_organizations_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_organizations_policyHandler) Read(externalID string) (*Aws_organizations_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_organizations_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_organizations_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_organizations_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_organizations_policy", externalID)
}

type Aws_dms_endpoint struct {
     Aws_dms_endpoint_id *string
     Certificate_arn *string
     Ssl_mode *string
     Endpoint_arn *string
     Extra_connection_attributes *string
     Kms_key_arn *string
     Tags *map[string]string
     Username *string
     Database_name *string
     Endpoint_id string
     Service_access_role *string
     Engine_name string
     Server_name *string
     Endpoint_type string
     Password *string
}


func Aws_dms_endpointMapper(r *Aws_dms_endpoint) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["endpoint_type"] = r.Endpoint_type
if r.Password != nil {
    config["password"] = *r.Password
}
if r.Certificate_arn != nil {
    config["certificate_arn"] = *r.Certificate_arn
}
if r.Ssl_mode != nil {
    config["ssl_mode"] = *r.Ssl_mode
}
if r.Endpoint_arn != nil {
    config["endpoint_arn"] = *r.Endpoint_arn
}
if r.Extra_connection_attributes != nil {
    config["extra_connection_attributes"] = *r.Extra_connection_attributes
}
if r.Kms_key_arn != nil {
    config["kms_key_arn"] = *r.Kms_key_arn
}
if r.Database_name != nil {
    config["database_name"] = *r.Database_name
}
    config["endpoint_id"] = r.Endpoint_id
if r.Service_access_role != nil {
    config["service_access_role"] = *r.Service_access_role
}
    config["engine_name"] = r.Engine_name
if r.Server_name != nil {
    config["server_name"] = *r.Server_name
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Username != nil {
    config["username"] = *r.Username
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dms_endpointUnmapper(state map[string]interface{}) *Aws_dms_endpoint {
	r := &Aws_dms_endpoint{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dms_endpoint_id = &x
}

if x, ok := state["kms_key_arn"]; ok {
	x := x.(string)
	r.Kms_key_arn = &x
}

if x, ok := state["endpoint_arn"]; ok {
	x := x.(string)
	r.Endpoint_arn = &x
}

if x, ok := state["extra_connection_attributes"]; ok {
	x := x.(string)
	r.Extra_connection_attributes = &x
}

if x, ok := state["service_access_role"]; ok {
	x := x.(string)
	r.Service_access_role = &x
}

if x, ok := state["engine_name"]; ok {
	r.Engine_name = x.(string)
}

if x, ok := state["server_name"]; ok {
	x := x.(string)
	r.Server_name = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["username"]; ok {
	x := x.(string)
	r.Username = &x
}

if x, ok := state["database_name"]; ok {
	x := x.(string)
	r.Database_name = &x
}

if x, ok := state["endpoint_id"]; ok {
	r.Endpoint_id = x.(string)
}

if x, ok := state["endpoint_type"]; ok {
	r.Endpoint_type = x.(string)
}

if x, ok := state["password"]; ok {
	x := x.(string)
	r.Password = &x
}

if x, ok := state["certificate_arn"]; ok {
	x := x.(string)
	r.Certificate_arn = &x
}

if x, ok := state["ssl_mode"]; ok {
	x := x.(string)
	r.Ssl_mode = &x
}
	return r
}


// Aws_dms_endpointHandler ...
type Aws_dms_endpointHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dms_endpointHandler) Create(desired *Aws_dms_endpoint) (*Aws_dms_endpoint, string, error) {
	rState := Aws_dms_endpointMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dms_endpoint", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dms_endpointHandler) Read(externalID string) (*Aws_dms_endpoint, error) {
	actual, err := bridge.Read(h.provider, "aws_dms_endpoint", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dms_endpointUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dms_endpointHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dms_endpoint", externalID)
}

type Aws_flow_log struct {
     Aws_flow_log_id *string
     Log_destination_type *string
     Log_group_name *string
     Vpc_id *string
     Subnet_id *string
     Eni_id *string
     Traffic_type string
     Iam_role_arn *string
     Log_destination *string
}


func Aws_flow_logMapper(r *Aws_flow_log) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Subnet_id != nil {
    config["subnet_id"] = *r.Subnet_id
}
if r.Eni_id != nil {
    config["eni_id"] = *r.Eni_id
}
    config["traffic_type"] = r.Traffic_type
if r.Iam_role_arn != nil {
    config["iam_role_arn"] = *r.Iam_role_arn
}
if r.Log_destination != nil {
    config["log_destination"] = *r.Log_destination
}
if r.Log_destination_type != nil {
    config["log_destination_type"] = *r.Log_destination_type
}
if r.Log_group_name != nil {
    config["log_group_name"] = *r.Log_group_name
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_flow_logUnmapper(state map[string]interface{}) *Aws_flow_log {
	r := &Aws_flow_log{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_flow_log_id = &x
}

if x, ok := state["traffic_type"]; ok {
	r.Traffic_type = x.(string)
}

if x, ok := state["iam_role_arn"]; ok {
	x := x.(string)
	r.Iam_role_arn = &x
}

if x, ok := state["log_destination"]; ok {
	x := x.(string)
	r.Log_destination = &x
}

if x, ok := state["log_destination_type"]; ok {
	x := x.(string)
	r.Log_destination_type = &x
}

if x, ok := state["log_group_name"]; ok {
	x := x.(string)
	r.Log_group_name = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["subnet_id"]; ok {
	x := x.(string)
	r.Subnet_id = &x
}

if x, ok := state["eni_id"]; ok {
	x := x.(string)
	r.Eni_id = &x
}
	return r
}


// Aws_flow_logHandler ...
type Aws_flow_logHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_flow_logHandler) Create(desired *Aws_flow_log) (*Aws_flow_log, string, error) {
	rState := Aws_flow_logMapper(desired)
	id, err := bridge.Create(h.provider, "aws_flow_log", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_flow_logHandler) Read(externalID string) (*Aws_flow_log, error) {
	actual, err := bridge.Read(h.provider, "aws_flow_log", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_flow_logUnmapper(actual), nil
}

// Delete ...
func (h *Aws_flow_logHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_flow_log", externalID)
}

type Aws_neptune_cluster_parameter_group struct {
     Aws_neptune_cluster_parameter_group_id *string
     Tags *map[string]string
     Arn *string
     Name *string
     Name_prefix *string
     Family string
     Description *string
}


func Aws_neptune_cluster_parameter_groupMapper(r *Aws_neptune_cluster_parameter_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["family"] = r.Family
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_neptune_cluster_parameter_groupUnmapper(state map[string]interface{}) *Aws_neptune_cluster_parameter_group {
	r := &Aws_neptune_cluster_parameter_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_neptune_cluster_parameter_group_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["family"]; ok {
	r.Family = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_neptune_cluster_parameter_groupHandler ...
type Aws_neptune_cluster_parameter_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_neptune_cluster_parameter_groupHandler) Create(desired *Aws_neptune_cluster_parameter_group) (*Aws_neptune_cluster_parameter_group, string, error) {
	rState := Aws_neptune_cluster_parameter_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_neptune_cluster_parameter_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_neptune_cluster_parameter_groupHandler) Read(externalID string) (*Aws_neptune_cluster_parameter_group, error) {
	actual, err := bridge.Read(h.provider, "aws_neptune_cluster_parameter_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_neptune_cluster_parameter_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_neptune_cluster_parameter_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_neptune_cluster_parameter_group", externalID)
}

type Aws_api_gateway_authorizer struct {
     Aws_api_gateway_authorizer_id *string
     Authorizer_uri *string
     Identity_source *string
     Name string
     Authorizer_credentials *string
     Rest_api_id string
     Resource_type *string
     Identity_validation_expression *string
}


func Aws_api_gateway_authorizerMapper(r *Aws_api_gateway_authorizer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["rest_api_id"] = r.Rest_api_id
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
if r.Identity_validation_expression != nil {
    config["identity_validation_expression"] = *r.Identity_validation_expression
}
if r.Authorizer_uri != nil {
    config["authorizer_uri"] = *r.Authorizer_uri
}
if r.Identity_source != nil {
    config["identity_source"] = *r.Identity_source
}
    config["name"] = r.Name
if r.Authorizer_credentials != nil {
    config["authorizer_credentials"] = *r.Authorizer_credentials
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_authorizerUnmapper(state map[string]interface{}) *Aws_api_gateway_authorizer {
	r := &Aws_api_gateway_authorizer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_authorizer_id = &x
}

if x, ok := state["authorizer_credentials"]; ok {
	x := x.(string)
	r.Authorizer_credentials = &x
}

if x, ok := state["authorizer_uri"]; ok {
	x := x.(string)
	r.Authorizer_uri = &x
}

if x, ok := state["identity_source"]; ok {
	x := x.(string)
	r.Identity_source = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["identity_validation_expression"]; ok {
	x := x.(string)
	r.Identity_validation_expression = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}
	return r
}


// Aws_api_gateway_authorizerHandler ...
type Aws_api_gateway_authorizerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_authorizerHandler) Create(desired *Aws_api_gateway_authorizer) (*Aws_api_gateway_authorizer, string, error) {
	rState := Aws_api_gateway_authorizerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_authorizer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_authorizerHandler) Read(externalID string) (*Aws_api_gateway_authorizer, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_authorizer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_authorizerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_authorizerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_authorizer", externalID)
}

type Aws_api_gateway_method_settings struct {
     Aws_api_gateway_method_settings_id *string
     Rest_api_id string
     Stage_name string
     Method_path string
}


func Aws_api_gateway_method_settingsMapper(r *Aws_api_gateway_method_settings) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["rest_api_id"] = r.Rest_api_id
    config["stage_name"] = r.Stage_name
    config["method_path"] = r.Method_path
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_method_settingsUnmapper(state map[string]interface{}) *Aws_api_gateway_method_settings {
	r := &Aws_api_gateway_method_settings{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_method_settings_id = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["stage_name"]; ok {
	r.Stage_name = x.(string)
}

if x, ok := state["method_path"]; ok {
	r.Method_path = x.(string)
}
	return r
}


// Aws_api_gateway_method_settingsHandler ...
type Aws_api_gateway_method_settingsHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_method_settingsHandler) Create(desired *Aws_api_gateway_method_settings) (*Aws_api_gateway_method_settings, string, error) {
	rState := Aws_api_gateway_method_settingsMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_method_settings", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_method_settingsHandler) Read(externalID string) (*Aws_api_gateway_method_settings, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_method_settings", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_method_settingsUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_method_settingsHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_method_settings", externalID)
}

type Aws_ses_receipt_filter struct {
     Aws_ses_receipt_filter_id *string
     Name string
     Cidr string
     Policy string
}


func Aws_ses_receipt_filterMapper(r *Aws_ses_receipt_filter) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["cidr"] = r.Cidr
    config["policy"] = r.Policy
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_receipt_filterUnmapper(state map[string]interface{}) *Aws_ses_receipt_filter {
	r := &Aws_ses_receipt_filter{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_receipt_filter_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["cidr"]; ok {
	r.Cidr = x.(string)
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}
	return r
}


// Aws_ses_receipt_filterHandler ...
type Aws_ses_receipt_filterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_receipt_filterHandler) Create(desired *Aws_ses_receipt_filter) (*Aws_ses_receipt_filter, string, error) {
	rState := Aws_ses_receipt_filterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_receipt_filter", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_receipt_filterHandler) Read(externalID string) (*Aws_ses_receipt_filter, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_receipt_filter", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_receipt_filterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_receipt_filterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_receipt_filter", externalID)
}

type Aws_vpn_gateway struct {
     Aws_vpn_gateway_id *string
     Availability_zone *string
     Amazon_side_asn *string
     Vpc_id *string
     Tags *map[string]string
}


func Aws_vpn_gatewayMapper(r *Aws_vpn_gateway) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Amazon_side_asn != nil {
    config["amazon_side_asn"] = *r.Amazon_side_asn
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpn_gatewayUnmapper(state map[string]interface{}) *Aws_vpn_gateway {
	r := &Aws_vpn_gateway{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpn_gateway_id = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["amazon_side_asn"]; ok {
	x := x.(string)
	r.Amazon_side_asn = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_vpn_gatewayHandler ...
type Aws_vpn_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpn_gatewayHandler) Create(desired *Aws_vpn_gateway) (*Aws_vpn_gateway, string, error) {
	rState := Aws_vpn_gatewayMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpn_gateway", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpn_gatewayHandler) Read(externalID string) (*Aws_vpn_gateway, error) {
	actual, err := bridge.Read(h.provider, "aws_vpn_gateway", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpn_gatewayUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpn_gatewayHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpn_gateway", externalID)
}

type Aws_alb_listener_certificate struct {
     Aws_alb_listener_certificate_id *string
     Listener_arn string
     Certificate_arn string
}


func Aws_alb_listener_certificateMapper(r *Aws_alb_listener_certificate) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["listener_arn"] = r.Listener_arn
    config["certificate_arn"] = r.Certificate_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_alb_listener_certificateUnmapper(state map[string]interface{}) *Aws_alb_listener_certificate {
	r := &Aws_alb_listener_certificate{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_alb_listener_certificate_id = &x
}

if x, ok := state["listener_arn"]; ok {
	r.Listener_arn = x.(string)
}

if x, ok := state["certificate_arn"]; ok {
	r.Certificate_arn = x.(string)
}
	return r
}


// Aws_alb_listener_certificateHandler ...
type Aws_alb_listener_certificateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_alb_listener_certificateHandler) Create(desired *Aws_alb_listener_certificate) (*Aws_alb_listener_certificate, string, error) {
	rState := Aws_alb_listener_certificateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_alb_listener_certificate", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_alb_listener_certificateHandler) Read(externalID string) (*Aws_alb_listener_certificate, error) {
	actual, err := bridge.Read(h.provider, "aws_alb_listener_certificate", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_alb_listener_certificateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_alb_listener_certificateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_alb_listener_certificate", externalID)
}

type Aws_eip struct {
     Aws_eip_id *string
     Instance *string
     Network_interface *string
     Private_ip *string
     Vpc *bool
     Association_id *string
     Domain *string
     Public_ip *string
     Associate_with_private_ip *string
     Public_ipv4_pool *string
     Tags *map[string]string
     Allocation_id *string
}


func Aws_eipMapper(r *Aws_eip) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Network_interface != nil {
    config["network_interface"] = *r.Network_interface
}
if r.Private_ip != nil {
    config["private_ip"] = *r.Private_ip
}
if r.Vpc != nil {
    config["vpc"] = *r.Vpc
}
if r.Instance != nil {
    config["instance"] = *r.Instance
}
if r.Domain != nil {
    config["domain"] = *r.Domain
}
if r.Public_ip != nil {
    config["public_ip"] = *r.Public_ip
}
if r.Associate_with_private_ip != nil {
    config["associate_with_private_ip"] = *r.Associate_with_private_ip
}
if r.Public_ipv4_pool != nil {
    config["public_ipv4_pool"] = *r.Public_ipv4_pool
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Allocation_id != nil {
    config["allocation_id"] = *r.Allocation_id
}
if r.Association_id != nil {
    config["association_id"] = *r.Association_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_eipUnmapper(state map[string]interface{}) *Aws_eip {
	r := &Aws_eip{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_eip_id = &x
}

if x, ok := state["allocation_id"]; ok {
	x := x.(string)
	r.Allocation_id = &x
}

if x, ok := state["association_id"]; ok {
	x := x.(string)
	r.Association_id = &x
}

if x, ok := state["domain"]; ok {
	x := x.(string)
	r.Domain = &x
}

if x, ok := state["public_ip"]; ok {
	x := x.(string)
	r.Public_ip = &x
}

if x, ok := state["associate_with_private_ip"]; ok {
	x := x.(string)
	r.Associate_with_private_ip = &x
}

if x, ok := state["public_ipv4_pool"]; ok {
	x := x.(string)
	r.Public_ipv4_pool = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["vpc"]; ok {
	x := x.(bool)
	r.Vpc = &x
}

if x, ok := state["instance"]; ok {
	x := x.(string)
	r.Instance = &x
}

if x, ok := state["network_interface"]; ok {
	x := x.(string)
	r.Network_interface = &x
}

if x, ok := state["private_ip"]; ok {
	x := x.(string)
	r.Private_ip = &x
}
	return r
}


// Aws_eipHandler ...
type Aws_eipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_eipHandler) Create(desired *Aws_eip) (*Aws_eip, string, error) {
	rState := Aws_eipMapper(desired)
	id, err := bridge.Create(h.provider, "aws_eip", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_eipHandler) Read(externalID string) (*Aws_eip, error) {
	actual, err := bridge.Read(h.provider, "aws_eip", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_eipUnmapper(actual), nil
}

// Delete ...
func (h *Aws_eipHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_eip", externalID)
}

type Aws_ram_resource_share struct {
     Aws_ram_resource_share_id *string
     Allow_external_principals *bool
     Tags *map[string]string
     Name string
}


func Aws_ram_resource_shareMapper(r *Aws_ram_resource_share) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Allow_external_principals != nil {
    config["allow_external_principals"] = *r.Allow_external_principals
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ram_resource_shareUnmapper(state map[string]interface{}) *Aws_ram_resource_share {
	r := &Aws_ram_resource_share{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ram_resource_share_id = &x
}

if x, ok := state["allow_external_principals"]; ok {
	x := x.(bool)
	r.Allow_external_principals = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_ram_resource_shareHandler ...
type Aws_ram_resource_shareHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ram_resource_shareHandler) Create(desired *Aws_ram_resource_share) (*Aws_ram_resource_share, string, error) {
	rState := Aws_ram_resource_shareMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ram_resource_share", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ram_resource_shareHandler) Read(externalID string) (*Aws_ram_resource_share, error) {
	actual, err := bridge.Read(h.provider, "aws_ram_resource_share", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ram_resource_shareUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ram_resource_shareHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ram_resource_share", externalID)
}

type Aws_wafregional_regex_pattern_set struct {
     Aws_wafregional_regex_pattern_set_id *string
     Name string
}


func Aws_wafregional_regex_pattern_setMapper(r *Aws_wafregional_regex_pattern_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_regex_pattern_setUnmapper(state map[string]interface{}) *Aws_wafregional_regex_pattern_set {
	r := &Aws_wafregional_regex_pattern_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_regex_pattern_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_wafregional_regex_pattern_setHandler ...
type Aws_wafregional_regex_pattern_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_regex_pattern_setHandler) Create(desired *Aws_wafregional_regex_pattern_set) (*Aws_wafregional_regex_pattern_set, string, error) {
	rState := Aws_wafregional_regex_pattern_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_regex_pattern_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_regex_pattern_setHandler) Read(externalID string) (*Aws_wafregional_regex_pattern_set, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_regex_pattern_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_regex_pattern_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_regex_pattern_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_regex_pattern_set", externalID)
}

type Aws_api_gateway_client_certificate struct {
     Aws_api_gateway_client_certificate_id *string
     Pem_encoded_certificate *string
     Description *string
     Created_date *string
     Expiration_date *string
}


func Aws_api_gateway_client_certificateMapper(r *Aws_api_gateway_client_certificate) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
if r.Expiration_date != nil {
    config["expiration_date"] = *r.Expiration_date
}
if r.Pem_encoded_certificate != nil {
    config["pem_encoded_certificate"] = *r.Pem_encoded_certificate
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_client_certificateUnmapper(state map[string]interface{}) *Aws_api_gateway_client_certificate {
	r := &Aws_api_gateway_client_certificate{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_client_certificate_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}

if x, ok := state["expiration_date"]; ok {
	x := x.(string)
	r.Expiration_date = &x
}

if x, ok := state["pem_encoded_certificate"]; ok {
	x := x.(string)
	r.Pem_encoded_certificate = &x
}
	return r
}


// Aws_api_gateway_client_certificateHandler ...
type Aws_api_gateway_client_certificateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_client_certificateHandler) Create(desired *Aws_api_gateway_client_certificate) (*Aws_api_gateway_client_certificate, string, error) {
	rState := Aws_api_gateway_client_certificateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_client_certificate", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_client_certificateHandler) Read(externalID string) (*Aws_api_gateway_client_certificate, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_client_certificate", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_client_certificateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_client_certificateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_client_certificate", externalID)
}

type Aws_iam_group_membership struct {
     Aws_iam_group_membership_id *string
     Name string
     Group string
}


func Aws_iam_group_membershipMapper(r *Aws_iam_group_membership) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["group"] = r.Group
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_group_membershipUnmapper(state map[string]interface{}) *Aws_iam_group_membership {
	r := &Aws_iam_group_membership{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_group_membership_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["group"]; ok {
	r.Group = x.(string)
}
	return r
}


// Aws_iam_group_membershipHandler ...
type Aws_iam_group_membershipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_group_membershipHandler) Create(desired *Aws_iam_group_membership) (*Aws_iam_group_membership, string, error) {
	rState := Aws_iam_group_membershipMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_group_membership", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_group_membershipHandler) Read(externalID string) (*Aws_iam_group_membership, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_group_membership", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_group_membershipUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_group_membershipHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_group_membership", externalID)
}

type Aws_kms_alias struct {
     Aws_kms_alias_id *string
     Target_key_arn *string
     Arn *string
     Name *string
     Name_prefix *string
     Target_key_id string
}


func Aws_kms_aliasMapper(r *Aws_kms_alias) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["target_key_id"] = r.Target_key_id
if r.Target_key_arn != nil {
    config["target_key_arn"] = *r.Target_key_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_kms_aliasUnmapper(state map[string]interface{}) *Aws_kms_alias {
	r := &Aws_kms_alias{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_kms_alias_id = &x
}

if x, ok := state["target_key_arn"]; ok {
	x := x.(string)
	r.Target_key_arn = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["target_key_id"]; ok {
	r.Target_key_id = x.(string)
}
	return r
}


// Aws_kms_aliasHandler ...
type Aws_kms_aliasHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_kms_aliasHandler) Create(desired *Aws_kms_alias) (*Aws_kms_alias, string, error) {
	rState := Aws_kms_aliasMapper(desired)
	id, err := bridge.Create(h.provider, "aws_kms_alias", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_kms_aliasHandler) Read(externalID string) (*Aws_kms_alias, error) {
	actual, err := bridge.Read(h.provider, "aws_kms_alias", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_kms_aliasUnmapper(actual), nil
}

// Delete ...
func (h *Aws_kms_aliasHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_kms_alias", externalID)
}

type Aws_ssm_patch_group struct {
     Aws_ssm_patch_group_id *string
     Baseline_id string
     Patch_group string
}


func Aws_ssm_patch_groupMapper(r *Aws_ssm_patch_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["baseline_id"] = r.Baseline_id
    config["patch_group"] = r.Patch_group
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_patch_groupUnmapper(state map[string]interface{}) *Aws_ssm_patch_group {
	r := &Aws_ssm_patch_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_patch_group_id = &x
}

if x, ok := state["baseline_id"]; ok {
	r.Baseline_id = x.(string)
}

if x, ok := state["patch_group"]; ok {
	r.Patch_group = x.(string)
}
	return r
}


// Aws_ssm_patch_groupHandler ...
type Aws_ssm_patch_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_patch_groupHandler) Create(desired *Aws_ssm_patch_group) (*Aws_ssm_patch_group, string, error) {
	rState := Aws_ssm_patch_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_patch_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_patch_groupHandler) Read(externalID string) (*Aws_ssm_patch_group, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_patch_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_patch_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_patch_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_patch_group", externalID)
}

type Aws_dms_certificate struct {
     Aws_dms_certificate_id *string
     Certificate_id string
     Certificate_pem *string
     Certificate_wallet *string
     Certificate_arn *string
}


func Aws_dms_certificateMapper(r *Aws_dms_certificate) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Certificate_arn != nil {
    config["certificate_arn"] = *r.Certificate_arn
}
    config["certificate_id"] = r.Certificate_id
if r.Certificate_pem != nil {
    config["certificate_pem"] = *r.Certificate_pem
}
if r.Certificate_wallet != nil {
    config["certificate_wallet"] = *r.Certificate_wallet
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dms_certificateUnmapper(state map[string]interface{}) *Aws_dms_certificate {
	r := &Aws_dms_certificate{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dms_certificate_id = &x
}

if x, ok := state["certificate_id"]; ok {
	r.Certificate_id = x.(string)
}

if x, ok := state["certificate_pem"]; ok {
	x := x.(string)
	r.Certificate_pem = &x
}

if x, ok := state["certificate_wallet"]; ok {
	x := x.(string)
	r.Certificate_wallet = &x
}

if x, ok := state["certificate_arn"]; ok {
	x := x.(string)
	r.Certificate_arn = &x
}
	return r
}


// Aws_dms_certificateHandler ...
type Aws_dms_certificateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dms_certificateHandler) Create(desired *Aws_dms_certificate) (*Aws_dms_certificate, string, error) {
	rState := Aws_dms_certificateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dms_certificate", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dms_certificateHandler) Read(externalID string) (*Aws_dms_certificate, error) {
	actual, err := bridge.Read(h.provider, "aws_dms_certificate", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dms_certificateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dms_certificateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dms_certificate", externalID)
}

type Aws_wafregional_sql_injection_match_set struct {
     Aws_wafregional_sql_injection_match_set_id *string
     Name string
}


func Aws_wafregional_sql_injection_match_setMapper(r *Aws_wafregional_sql_injection_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_sql_injection_match_setUnmapper(state map[string]interface{}) *Aws_wafregional_sql_injection_match_set {
	r := &Aws_wafregional_sql_injection_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_sql_injection_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_wafregional_sql_injection_match_setHandler ...
type Aws_wafregional_sql_injection_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_sql_injection_match_setHandler) Create(desired *Aws_wafregional_sql_injection_match_set) (*Aws_wafregional_sql_injection_match_set, string, error) {
	rState := Aws_wafregional_sql_injection_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_sql_injection_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_sql_injection_match_setHandler) Read(externalID string) (*Aws_wafregional_sql_injection_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_sql_injection_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_sql_injection_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_sql_injection_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_sql_injection_match_set", externalID)
}

type Aws_pinpoint_apns_channel struct {
     Aws_pinpoint_apns_channel_id *string
     Application_id string
     Bundle_id *string
     Enabled *bool
     Token_key *string
     Certificate *string
     Default_authentication_method *string
     Private_key *string
     Team_id *string
     Token_key_id *string
}


func Aws_pinpoint_apns_channelMapper(r *Aws_pinpoint_apns_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["application_id"] = r.Application_id
if r.Bundle_id != nil {
    config["bundle_id"] = *r.Bundle_id
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.Token_key != nil {
    config["token_key"] = *r.Token_key
}
if r.Certificate != nil {
    config["certificate"] = *r.Certificate
}
if r.Default_authentication_method != nil {
    config["default_authentication_method"] = *r.Default_authentication_method
}
if r.Private_key != nil {
    config["private_key"] = *r.Private_key
}
if r.Team_id != nil {
    config["team_id"] = *r.Team_id
}
if r.Token_key_id != nil {
    config["token_key_id"] = *r.Token_key_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_apns_channelUnmapper(state map[string]interface{}) *Aws_pinpoint_apns_channel {
	r := &Aws_pinpoint_apns_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_apns_channel_id = &x
}

if x, ok := state["certificate"]; ok {
	x := x.(string)
	r.Certificate = &x
}

if x, ok := state["default_authentication_method"]; ok {
	x := x.(string)
	r.Default_authentication_method = &x
}

if x, ok := state["private_key"]; ok {
	x := x.(string)
	r.Private_key = &x
}

if x, ok := state["team_id"]; ok {
	x := x.(string)
	r.Team_id = &x
}

if x, ok := state["token_key_id"]; ok {
	x := x.(string)
	r.Token_key_id = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["bundle_id"]; ok {
	x := x.(string)
	r.Bundle_id = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["token_key"]; ok {
	x := x.(string)
	r.Token_key = &x
}
	return r
}


// Aws_pinpoint_apns_channelHandler ...
type Aws_pinpoint_apns_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_apns_channelHandler) Create(desired *Aws_pinpoint_apns_channel) (*Aws_pinpoint_apns_channel, string, error) {
	rState := Aws_pinpoint_apns_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_apns_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_apns_channelHandler) Read(externalID string) (*Aws_pinpoint_apns_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_apns_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_apns_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_apns_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_apns_channel", externalID)
}

type Aws_pinpoint_gcm_channel struct {
     Aws_pinpoint_gcm_channel_id *string
     Application_id string
     Api_key string
     Enabled *bool
}


func Aws_pinpoint_gcm_channelMapper(r *Aws_pinpoint_gcm_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["application_id"] = r.Application_id
    config["api_key"] = r.Api_key
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_gcm_channelUnmapper(state map[string]interface{}) *Aws_pinpoint_gcm_channel {
	r := &Aws_pinpoint_gcm_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_gcm_channel_id = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["api_key"]; ok {
	r.Api_key = x.(string)
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}
	return r
}


// Aws_pinpoint_gcm_channelHandler ...
type Aws_pinpoint_gcm_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_gcm_channelHandler) Create(desired *Aws_pinpoint_gcm_channel) (*Aws_pinpoint_gcm_channel, string, error) {
	rState := Aws_pinpoint_gcm_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_gcm_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_gcm_channelHandler) Read(externalID string) (*Aws_pinpoint_gcm_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_gcm_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_gcm_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_gcm_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_gcm_channel", externalID)
}

type Aws_app_cookie_stickiness_policy struct {
     Aws_app_cookie_stickiness_policy_id *string
     Load_balancer string
     Cookie_name string
     Name string
}


func Aws_app_cookie_stickiness_policyMapper(r *Aws_app_cookie_stickiness_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["load_balancer"] = r.Load_balancer
    config["cookie_name"] = r.Cookie_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_app_cookie_stickiness_policyUnmapper(state map[string]interface{}) *Aws_app_cookie_stickiness_policy {
	r := &Aws_app_cookie_stickiness_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_app_cookie_stickiness_policy_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["load_balancer"]; ok {
	r.Load_balancer = x.(string)
}

if x, ok := state["cookie_name"]; ok {
	r.Cookie_name = x.(string)
}
	return r
}


// Aws_app_cookie_stickiness_policyHandler ...
type Aws_app_cookie_stickiness_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_app_cookie_stickiness_policyHandler) Create(desired *Aws_app_cookie_stickiness_policy) (*Aws_app_cookie_stickiness_policy, string, error) {
	rState := Aws_app_cookie_stickiness_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_app_cookie_stickiness_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_app_cookie_stickiness_policyHandler) Read(externalID string) (*Aws_app_cookie_stickiness_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_app_cookie_stickiness_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_app_cookie_stickiness_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_app_cookie_stickiness_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_app_cookie_stickiness_policy", externalID)
}

type Aws_cloud9_environment_ec2 struct {
     Aws_cloud9_environment_ec2_id *string
     Arn *string
     Resource_type *string
     Name string
     Instance_type string
     Description *string
     Owner_arn *string
     Subnet_id *string
}


func Aws_cloud9_environment_ec2Mapper(r *Aws_cloud9_environment_ec2) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
    config["name"] = r.Name
    config["instance_type"] = r.Instance_type
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Owner_arn != nil {
    config["owner_arn"] = *r.Owner_arn
}
if r.Subnet_id != nil {
    config["subnet_id"] = *r.Subnet_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloud9_environment_ec2Unmapper(state map[string]interface{}) *Aws_cloud9_environment_ec2 {
	r := &Aws_cloud9_environment_ec2{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloud9_environment_ec2_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["instance_type"]; ok {
	r.Instance_type = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["owner_arn"]; ok {
	x := x.(string)
	r.Owner_arn = &x
}

if x, ok := state["subnet_id"]; ok {
	x := x.(string)
	r.Subnet_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}
	return r
}


// Aws_cloud9_environment_ec2Handler ...
type Aws_cloud9_environment_ec2Handler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloud9_environment_ec2Handler) Create(desired *Aws_cloud9_environment_ec2) (*Aws_cloud9_environment_ec2, string, error) {
	rState := Aws_cloud9_environment_ec2Mapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloud9_environment_ec2", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloud9_environment_ec2Handler) Read(externalID string) (*Aws_cloud9_environment_ec2, error) {
	actual, err := bridge.Read(h.provider, "aws_cloud9_environment_ec2", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloud9_environment_ec2Unmapper(actual), nil
}

// Delete ...
func (h *Aws_cloud9_environment_ec2Handler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloud9_environment_ec2", externalID)
}

type Aws_mq_broker struct {
     Aws_mq_broker_id *string
     Broker_name string
     Host_instance_type string
     Publicly_accessible *bool
     Apply_immediately *bool
     Auto_minor_version_upgrade *bool
     Engine_type string
     Deployment_mode *string
     Engine_version string
     Arn *string
}


func Aws_mq_brokerMapper(r *Aws_mq_broker) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["host_instance_type"] = r.Host_instance_type
if r.Publicly_accessible != nil {
    config["publicly_accessible"] = *r.Publicly_accessible
}
    config["broker_name"] = r.Broker_name
if r.Auto_minor_version_upgrade != nil {
    config["auto_minor_version_upgrade"] = *r.Auto_minor_version_upgrade
}
    config["engine_type"] = r.Engine_type
if r.Apply_immediately != nil {
    config["apply_immediately"] = *r.Apply_immediately
}
    config["engine_version"] = r.Engine_version
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Deployment_mode != nil {
    config["deployment_mode"] = *r.Deployment_mode
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_mq_brokerUnmapper(state map[string]interface{}) *Aws_mq_broker {
	r := &Aws_mq_broker{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_mq_broker_id = &x
}

if x, ok := state["apply_immediately"]; ok {
	x := x.(bool)
	r.Apply_immediately = &x
}

if x, ok := state["auto_minor_version_upgrade"]; ok {
	x := x.(bool)
	r.Auto_minor_version_upgrade = &x
}

if x, ok := state["engine_type"]; ok {
	r.Engine_type = x.(string)
}

if x, ok := state["deployment_mode"]; ok {
	x := x.(string)
	r.Deployment_mode = &x
}

if x, ok := state["engine_version"]; ok {
	r.Engine_version = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["broker_name"]; ok {
	r.Broker_name = x.(string)
}

if x, ok := state["host_instance_type"]; ok {
	r.Host_instance_type = x.(string)
}

if x, ok := state["publicly_accessible"]; ok {
	x := x.(bool)
	r.Publicly_accessible = &x
}
	return r
}


// Aws_mq_brokerHandler ...
type Aws_mq_brokerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_mq_brokerHandler) Create(desired *Aws_mq_broker) (*Aws_mq_broker, string, error) {
	rState := Aws_mq_brokerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_mq_broker", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_mq_brokerHandler) Read(externalID string) (*Aws_mq_broker, error) {
	actual, err := bridge.Read(h.provider, "aws_mq_broker", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_mq_brokerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_mq_brokerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_mq_broker", externalID)
}

type Aws_spot_datafeed_subscription struct {
     Aws_spot_datafeed_subscription_id *string
     Bucket string
     Prefix *string
}


func Aws_spot_datafeed_subscriptionMapper(r *Aws_spot_datafeed_subscription) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["bucket"] = r.Bucket
if r.Prefix != nil {
    config["prefix"] = *r.Prefix
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_spot_datafeed_subscriptionUnmapper(state map[string]interface{}) *Aws_spot_datafeed_subscription {
	r := &Aws_spot_datafeed_subscription{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_spot_datafeed_subscription_id = &x
}

if x, ok := state["prefix"]; ok {
	x := x.(string)
	r.Prefix = &x
}

if x, ok := state["bucket"]; ok {
	r.Bucket = x.(string)
}
	return r
}


// Aws_spot_datafeed_subscriptionHandler ...
type Aws_spot_datafeed_subscriptionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_spot_datafeed_subscriptionHandler) Create(desired *Aws_spot_datafeed_subscription) (*Aws_spot_datafeed_subscription, string, error) {
	rState := Aws_spot_datafeed_subscriptionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_spot_datafeed_subscription", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_spot_datafeed_subscriptionHandler) Read(externalID string) (*Aws_spot_datafeed_subscription, error) {
	actual, err := bridge.Read(h.provider, "aws_spot_datafeed_subscription", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_spot_datafeed_subscriptionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_spot_datafeed_subscriptionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_spot_datafeed_subscription", externalID)
}

type Aws_api_gateway_method struct {
     Aws_api_gateway_method_id *string
     Rest_api_id string
     Resource_id string
     Authorizer_id *string
     Api_key_required *bool
     Request_parameters_in_json *string
     Request_validator_id *string
     Http_method string
     Authorization string
     Request_models *map[string]string
     Request_parameters *map[string]string
}


func Aws_api_gateway_methodMapper(r *Aws_api_gateway_method) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["authorization"] = r.Authorization
if r.Request_models != nil {
    config["request_models"] = *r.Request_models
}
if r.Request_parameters != nil {
    config["request_parameters"] = *r.Request_parameters
}
    config["http_method"] = r.Http_method
    config["resource_id"] = r.Resource_id
if r.Authorizer_id != nil {
    config["authorizer_id"] = *r.Authorizer_id
}
if r.Api_key_required != nil {
    config["api_key_required"] = *r.Api_key_required
}
if r.Request_parameters_in_json != nil {
    config["request_parameters_in_json"] = *r.Request_parameters_in_json
}
if r.Request_validator_id != nil {
    config["request_validator_id"] = *r.Request_validator_id
}
    config["rest_api_id"] = r.Rest_api_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_methodUnmapper(state map[string]interface{}) *Aws_api_gateway_method {
	r := &Aws_api_gateway_method{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_method_id = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["resource_id"]; ok {
	r.Resource_id = x.(string)
}

if x, ok := state["authorizer_id"]; ok {
	x := x.(string)
	r.Authorizer_id = &x
}

if x, ok := state["api_key_required"]; ok {
	x := x.(bool)
	r.Api_key_required = &x
}

if x, ok := state["request_parameters_in_json"]; ok {
	x := x.(string)
	r.Request_parameters_in_json = &x
}

if x, ok := state["request_validator_id"]; ok {
	x := x.(string)
	r.Request_validator_id = &x
}

if x, ok := state["http_method"]; ok {
	r.Http_method = x.(string)
}

if x, ok := state["authorization"]; ok {
	r.Authorization = x.(string)
}

if x, ok := state["request_models"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Request_models = &x
}

if x, ok := state["request_parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Request_parameters = &x
}
	return r
}


// Aws_api_gateway_methodHandler ...
type Aws_api_gateway_methodHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_methodHandler) Create(desired *Aws_api_gateway_method) (*Aws_api_gateway_method, string, error) {
	rState := Aws_api_gateway_methodMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_method", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_methodHandler) Read(externalID string) (*Aws_api_gateway_method, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_method", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_methodUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_methodHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_method", externalID)
}

type Aws_dx_connection struct {
     Aws_dx_connection_id *string
     Location string
     Jumbo_frame_capable *bool
     Tags *map[string]string
     Arn *string
     Name string
     Bandwidth string
}


func Aws_dx_connectionMapper(r *Aws_dx_connection) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["bandwidth"] = r.Bandwidth
    config["location"] = r.Location
if r.Jumbo_frame_capable != nil {
    config["jumbo_frame_capable"] = *r.Jumbo_frame_capable
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_connectionUnmapper(state map[string]interface{}) *Aws_dx_connection {
	r := &Aws_dx_connection{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_connection_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["bandwidth"]; ok {
	r.Bandwidth = x.(string)
}

if x, ok := state["location"]; ok {
	r.Location = x.(string)
}

if x, ok := state["jumbo_frame_capable"]; ok {
	x := x.(bool)
	r.Jumbo_frame_capable = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_dx_connectionHandler ...
type Aws_dx_connectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_connectionHandler) Create(desired *Aws_dx_connection) (*Aws_dx_connection, string, error) {
	rState := Aws_dx_connectionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_connection", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_connectionHandler) Read(externalID string) (*Aws_dx_connection, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_connection", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_connectionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_connectionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_connection", externalID)
}

type Aws_service_discovery_http_namespace struct {
     Aws_service_discovery_http_namespace_id *string
     Description *string
     Arn *string
     Name string
}


func Aws_service_discovery_http_namespaceMapper(r *Aws_service_discovery_http_namespace) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_service_discovery_http_namespaceUnmapper(state map[string]interface{}) *Aws_service_discovery_http_namespace {
	r := &Aws_service_discovery_http_namespace{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_service_discovery_http_namespace_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_service_discovery_http_namespaceHandler ...
type Aws_service_discovery_http_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_service_discovery_http_namespaceHandler) Create(desired *Aws_service_discovery_http_namespace) (*Aws_service_discovery_http_namespace, string, error) {
	rState := Aws_service_discovery_http_namespaceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_service_discovery_http_namespace", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_service_discovery_http_namespaceHandler) Read(externalID string) (*Aws_service_discovery_http_namespace, error) {
	actual, err := bridge.Read(h.provider, "aws_service_discovery_http_namespace", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_service_discovery_http_namespaceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_service_discovery_http_namespaceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_service_discovery_http_namespace", externalID)
}

type Aws_lb_listener_rule struct {
     Aws_lb_listener_rule_id *string
     Arn *string
     Listener_arn string
}


func Aws_lb_listener_ruleMapper(r *Aws_lb_listener_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["listener_arn"] = r.Listener_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lb_listener_ruleUnmapper(state map[string]interface{}) *Aws_lb_listener_rule {
	r := &Aws_lb_listener_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lb_listener_rule_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["listener_arn"]; ok {
	r.Listener_arn = x.(string)
}
	return r
}


// Aws_lb_listener_ruleHandler ...
type Aws_lb_listener_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lb_listener_ruleHandler) Create(desired *Aws_lb_listener_rule) (*Aws_lb_listener_rule, string, error) {
	rState := Aws_lb_listener_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lb_listener_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lb_listener_ruleHandler) Read(externalID string) (*Aws_lb_listener_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_lb_listener_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lb_listener_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lb_listener_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lb_listener_rule", externalID)
}

type Aws_dms_replication_task struct {
     Aws_dms_replication_task_id *string
     Replication_task_id string
     Replication_task_settings *string
     Table_mappings string
     Tags *map[string]string
     Migration_type string
     Replication_task_arn *string
     Source_endpoint_arn string
     Target_endpoint_arn string
     Cdc_start_time *string
     Replication_instance_arn string
}


func Aws_dms_replication_taskMapper(r *Aws_dms_replication_task) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Cdc_start_time != nil {
    config["cdc_start_time"] = *r.Cdc_start_time
}
    config["replication_instance_arn"] = r.Replication_instance_arn
    config["source_endpoint_arn"] = r.Source_endpoint_arn
    config["target_endpoint_arn"] = r.Target_endpoint_arn
    config["table_mappings"] = r.Table_mappings
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["migration_type"] = r.Migration_type
if r.Replication_task_arn != nil {
    config["replication_task_arn"] = *r.Replication_task_arn
}
    config["replication_task_id"] = r.Replication_task_id
if r.Replication_task_settings != nil {
    config["replication_task_settings"] = *r.Replication_task_settings
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dms_replication_taskUnmapper(state map[string]interface{}) *Aws_dms_replication_task {
	r := &Aws_dms_replication_task{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dms_replication_task_id = &x
}

if x, ok := state["cdc_start_time"]; ok {
	x := x.(string)
	r.Cdc_start_time = &x
}

if x, ok := state["replication_instance_arn"]; ok {
	r.Replication_instance_arn = x.(string)
}

if x, ok := state["source_endpoint_arn"]; ok {
	r.Source_endpoint_arn = x.(string)
}

if x, ok := state["target_endpoint_arn"]; ok {
	r.Target_endpoint_arn = x.(string)
}

if x, ok := state["migration_type"]; ok {
	r.Migration_type = x.(string)
}

if x, ok := state["replication_task_arn"]; ok {
	x := x.(string)
	r.Replication_task_arn = &x
}

if x, ok := state["replication_task_id"]; ok {
	r.Replication_task_id = x.(string)
}

if x, ok := state["replication_task_settings"]; ok {
	x := x.(string)
	r.Replication_task_settings = &x
}

if x, ok := state["table_mappings"]; ok {
	r.Table_mappings = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_dms_replication_taskHandler ...
type Aws_dms_replication_taskHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dms_replication_taskHandler) Create(desired *Aws_dms_replication_task) (*Aws_dms_replication_task, string, error) {
	rState := Aws_dms_replication_taskMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dms_replication_task", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dms_replication_taskHandler) Read(externalID string) (*Aws_dms_replication_task, error) {
	actual, err := bridge.Read(h.provider, "aws_dms_replication_task", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dms_replication_taskUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dms_replication_taskHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dms_replication_task", externalID)
}

type Aws_ec2_transit_gateway_route_table_association struct {
     Aws_ec2_transit_gateway_route_table_association_id *string
     Resource_type *string
     Transit_gateway_attachment_id string
     Transit_gateway_route_table_id string
     Resource_id *string
}


func Aws_ec2_transit_gateway_route_table_associationMapper(r *Aws_ec2_transit_gateway_route_table_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["transit_gateway_route_table_id"] = r.Transit_gateway_route_table_id
if r.Resource_id != nil {
    config["resource_id"] = *r.Resource_id
}
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
    config["transit_gateway_attachment_id"] = r.Transit_gateway_attachment_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ec2_transit_gateway_route_table_associationUnmapper(state map[string]interface{}) *Aws_ec2_transit_gateway_route_table_association {
	r := &Aws_ec2_transit_gateway_route_table_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ec2_transit_gateway_route_table_association_id = &x
}

if x, ok := state["transit_gateway_route_table_id"]; ok {
	r.Transit_gateway_route_table_id = x.(string)
}

if x, ok := state["resource_id"]; ok {
	x := x.(string)
	r.Resource_id = &x
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}

if x, ok := state["transit_gateway_attachment_id"]; ok {
	r.Transit_gateway_attachment_id = x.(string)
}
	return r
}


// Aws_ec2_transit_gateway_route_table_associationHandler ...
type Aws_ec2_transit_gateway_route_table_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ec2_transit_gateway_route_table_associationHandler) Create(desired *Aws_ec2_transit_gateway_route_table_association) (*Aws_ec2_transit_gateway_route_table_association, string, error) {
	rState := Aws_ec2_transit_gateway_route_table_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ec2_transit_gateway_route_table_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ec2_transit_gateway_route_table_associationHandler) Read(externalID string) (*Aws_ec2_transit_gateway_route_table_association, error) {
	actual, err := bridge.Read(h.provider, "aws_ec2_transit_gateway_route_table_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ec2_transit_gateway_route_table_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ec2_transit_gateway_route_table_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ec2_transit_gateway_route_table_association", externalID)
}

type Aws_opsworks_haproxy_layer struct {
     Aws_opsworks_haproxy_layer_id *string
     Custom_json *string
     Install_updates_on_boot *bool
     Drain_elb_on_shutdown *bool
     Healthcheck_method *string
     Stats_user *string
     Elastic_load_balancer *string
     Stack_id string
     Name *string
     Auto_assign_elastic_ips *bool
     Custom_instance_profile_arn *string
     Use_ebs_optimized_instances *bool
     Stats_password string
     Stats_enabled *bool
     Stats_url *string
     Auto_assign_public_ips *bool
     Healthcheck_url *string
     Auto_healing *bool
}


func Aws_opsworks_haproxy_layerMapper(r *Aws_opsworks_haproxy_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["stack_id"] = r.Stack_id
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
    config["stats_password"] = r.Stats_password
if r.Stats_enabled != nil {
    config["stats_enabled"] = *r.Stats_enabled
}
if r.Stats_url != nil {
    config["stats_url"] = *r.Stats_url
}
if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
if r.Healthcheck_url != nil {
    config["healthcheck_url"] = *r.Healthcheck_url
}
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
if r.Healthcheck_method != nil {
    config["healthcheck_method"] = *r.Healthcheck_method
}
if r.Stats_user != nil {
    config["stats_user"] = *r.Stats_user
}
if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_haproxy_layerUnmapper(state map[string]interface{}) *Aws_opsworks_haproxy_layer {
	r := &Aws_opsworks_haproxy_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_haproxy_layer_id = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["healthcheck_method"]; ok {
	x := x.(string)
	r.Healthcheck_method = &x
}

if x, ok := state["stats_user"]; ok {
	x := x.(string)
	r.Stats_user = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["stats_password"]; ok {
	r.Stats_password = x.(string)
}

if x, ok := state["stats_enabled"]; ok {
	x := x.(bool)
	r.Stats_enabled = &x
}

if x, ok := state["stats_url"]; ok {
	x := x.(string)
	r.Stats_url = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["healthcheck_url"]; ok {
	x := x.(string)
	r.Healthcheck_url = &x
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}
	return r
}


// Aws_opsworks_haproxy_layerHandler ...
type Aws_opsworks_haproxy_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_haproxy_layerHandler) Create(desired *Aws_opsworks_haproxy_layer) (*Aws_opsworks_haproxy_layer, string, error) {
	rState := Aws_opsworks_haproxy_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_haproxy_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_haproxy_layerHandler) Read(externalID string) (*Aws_opsworks_haproxy_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_haproxy_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_haproxy_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_haproxy_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_haproxy_layer", externalID)
}

type Aws_opsworks_mysql_layer struct {
     Aws_opsworks_mysql_layer_id *string
     Name *string
     Auto_assign_public_ips *bool
     Custom_instance_profile_arn *string
     Custom_json *string
     Stack_id string
     Use_ebs_optimized_instances *bool
     Root_password_on_all_instances *bool
     Auto_healing *bool
     Install_updates_on_boot *bool
     Drain_elb_on_shutdown *bool
     Root_password *string
     Auto_assign_elastic_ips *bool
     Elastic_load_balancer *string
}


func Aws_opsworks_mysql_layerMapper(r *Aws_opsworks_mysql_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
if r.Root_password_on_all_instances != nil {
    config["root_password_on_all_instances"] = *r.Root_password_on_all_instances
}
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
    config["stack_id"] = r.Stack_id
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
if r.Root_password != nil {
    config["root_password"] = *r.Root_password
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_mysql_layerUnmapper(state map[string]interface{}) *Aws_opsworks_mysql_layer {
	r := &Aws_opsworks_mysql_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_mysql_layer_id = &x
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["root_password_on_all_instances"]; ok {
	x := x.(bool)
	r.Root_password_on_all_instances = &x
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["root_password"]; ok {
	x := x.(string)
	r.Root_password = &x
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}
	return r
}


// Aws_opsworks_mysql_layerHandler ...
type Aws_opsworks_mysql_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_mysql_layerHandler) Create(desired *Aws_opsworks_mysql_layer) (*Aws_opsworks_mysql_layer, string, error) {
	rState := Aws_opsworks_mysql_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_mysql_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_mysql_layerHandler) Read(externalID string) (*Aws_opsworks_mysql_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_mysql_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_mysql_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_mysql_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_mysql_layer", externalID)
}

type Aws_rds_cluster_endpoint struct {
     Aws_rds_cluster_endpoint_id *string
     Arn *string
     Cluster_endpoint_identifier string
     Cluster_identifier string
     Custom_endpoint_type string
     Endpoint *string
}


func Aws_rds_cluster_endpointMapper(r *Aws_rds_cluster_endpoint) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["cluster_endpoint_identifier"] = r.Cluster_endpoint_identifier
    config["cluster_identifier"] = r.Cluster_identifier
    config["custom_endpoint_type"] = r.Custom_endpoint_type
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_rds_cluster_endpointUnmapper(state map[string]interface{}) *Aws_rds_cluster_endpoint {
	r := &Aws_rds_cluster_endpoint{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_rds_cluster_endpoint_id = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["cluster_endpoint_identifier"]; ok {
	r.Cluster_endpoint_identifier = x.(string)
}

if x, ok := state["cluster_identifier"]; ok {
	r.Cluster_identifier = x.(string)
}

if x, ok := state["custom_endpoint_type"]; ok {
	r.Custom_endpoint_type = x.(string)
}
	return r
}


// Aws_rds_cluster_endpointHandler ...
type Aws_rds_cluster_endpointHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_rds_cluster_endpointHandler) Create(desired *Aws_rds_cluster_endpoint) (*Aws_rds_cluster_endpoint, string, error) {
	rState := Aws_rds_cluster_endpointMapper(desired)
	id, err := bridge.Create(h.provider, "aws_rds_cluster_endpoint", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_rds_cluster_endpointHandler) Read(externalID string) (*Aws_rds_cluster_endpoint, error) {
	actual, err := bridge.Read(h.provider, "aws_rds_cluster_endpoint", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_rds_cluster_endpointUnmapper(actual), nil
}

// Delete ...
func (h *Aws_rds_cluster_endpointHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_rds_cluster_endpoint", externalID)
}

type Aws_sfn_activity struct {
     Aws_sfn_activity_id *string
     Name string
     Creation_date *string
     Tags *map[string]string
}


func Aws_sfn_activityMapper(r *Aws_sfn_activity) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Creation_date != nil {
    config["creation_date"] = *r.Creation_date
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sfn_activityUnmapper(state map[string]interface{}) *Aws_sfn_activity {
	r := &Aws_sfn_activity{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sfn_activity_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["creation_date"]; ok {
	x := x.(string)
	r.Creation_date = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_sfn_activityHandler ...
type Aws_sfn_activityHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sfn_activityHandler) Create(desired *Aws_sfn_activity) (*Aws_sfn_activity, string, error) {
	rState := Aws_sfn_activityMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sfn_activity", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sfn_activityHandler) Read(externalID string) (*Aws_sfn_activity, error) {
	actual, err := bridge.Read(h.provider, "aws_sfn_activity", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sfn_activityUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sfn_activityHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sfn_activity", externalID)
}

type Aws_default_subnet struct {
     Aws_default_subnet_id *string
     Ipv6_cidr_block *string
     Availability_zone_id *string
     Arn *string
     Tags *map[string]string
     Vpc_id *string
     Cidr_block *string
     Availability_zone string
     Map_public_ip_on_launch *bool
     Assign_ipv6_address_on_creation *bool
     Ipv6_cidr_block_association_id *string
     Owner_id *string
}


func Aws_default_subnetMapper(r *Aws_default_subnet) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Cidr_block != nil {
    config["cidr_block"] = *r.Cidr_block
}
    config["availability_zone"] = r.Availability_zone
if r.Map_public_ip_on_launch != nil {
    config["map_public_ip_on_launch"] = *r.Map_public_ip_on_launch
}
if r.Assign_ipv6_address_on_creation != nil {
    config["assign_ipv6_address_on_creation"] = *r.Assign_ipv6_address_on_creation
}
if r.Ipv6_cidr_block_association_id != nil {
    config["ipv6_cidr_block_association_id"] = *r.Ipv6_cidr_block_association_id
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Availability_zone_id != nil {
    config["availability_zone_id"] = *r.Availability_zone_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Ipv6_cidr_block != nil {
    config["ipv6_cidr_block"] = *r.Ipv6_cidr_block
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_default_subnetUnmapper(state map[string]interface{}) *Aws_default_subnet {
	r := &Aws_default_subnet{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_default_subnet_id = &x
}

if x, ok := state["availability_zone_id"]; ok {
	x := x.(string)
	r.Availability_zone_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["ipv6_cidr_block"]; ok {
	x := x.(string)
	r.Ipv6_cidr_block = &x
}

if x, ok := state["cidr_block"]; ok {
	x := x.(string)
	r.Cidr_block = &x
}

if x, ok := state["availability_zone"]; ok {
	r.Availability_zone = x.(string)
}

if x, ok := state["map_public_ip_on_launch"]; ok {
	x := x.(bool)
	r.Map_public_ip_on_launch = &x
}

if x, ok := state["assign_ipv6_address_on_creation"]; ok {
	x := x.(bool)
	r.Assign_ipv6_address_on_creation = &x
}

if x, ok := state["ipv6_cidr_block_association_id"]; ok {
	x := x.(string)
	r.Ipv6_cidr_block_association_id = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}
	return r
}


// Aws_default_subnetHandler ...
type Aws_default_subnetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_default_subnetHandler) Create(desired *Aws_default_subnet) (*Aws_default_subnet, string, error) {
	rState := Aws_default_subnetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_default_subnet", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_default_subnetHandler) Read(externalID string) (*Aws_default_subnet, error) {
	actual, err := bridge.Read(h.provider, "aws_default_subnet", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_default_subnetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_default_subnetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_default_subnet", externalID)
}

type Aws_iam_role_policy struct {
     Aws_iam_role_policy_id *string
     Policy string
     Name *string
     Name_prefix *string
     Role string
}


func Aws_iam_role_policyMapper(r *Aws_iam_role_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["policy"] = r.Policy
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["role"] = r.Role
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_role_policyUnmapper(state map[string]interface{}) *Aws_iam_role_policy {
	r := &Aws_iam_role_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_role_policy_id = &x
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["role"]; ok {
	r.Role = x.(string)
}
	return r
}


// Aws_iam_role_policyHandler ...
type Aws_iam_role_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_role_policyHandler) Create(desired *Aws_iam_role_policy) (*Aws_iam_role_policy, string, error) {
	rState := Aws_iam_role_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_role_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_role_policyHandler) Read(externalID string) (*Aws_iam_role_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_role_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_role_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_role_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_role_policy", externalID)
}

type Aws_internet_gateway struct {
     Aws_internet_gateway_id *string
     Vpc_id *string
     Tags *map[string]string
     Owner_id *string
}


func Aws_internet_gatewayMapper(r *Aws_internet_gateway) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_internet_gatewayUnmapper(state map[string]interface{}) *Aws_internet_gateway {
	r := &Aws_internet_gateway{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_internet_gateway_id = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}
	return r
}


// Aws_internet_gatewayHandler ...
type Aws_internet_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_internet_gatewayHandler) Create(desired *Aws_internet_gateway) (*Aws_internet_gateway, string, error) {
	rState := Aws_internet_gatewayMapper(desired)
	id, err := bridge.Create(h.provider, "aws_internet_gateway", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_internet_gatewayHandler) Read(externalID string) (*Aws_internet_gateway, error) {
	actual, err := bridge.Read(h.provider, "aws_internet_gateway", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_internet_gatewayUnmapper(actual), nil
}

// Delete ...
func (h *Aws_internet_gatewayHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_internet_gateway", externalID)
}

type Aws_pinpoint_app struct {
     Aws_pinpoint_app_id *string
     Name_prefix *string
     Application_id *string
     Name *string
}


func Aws_pinpoint_appMapper(r *Aws_pinpoint_app) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Application_id != nil {
    config["application_id"] = *r.Application_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_appUnmapper(state map[string]interface{}) *Aws_pinpoint_app {
	r := &Aws_pinpoint_app{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_app_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["application_id"]; ok {
	x := x.(string)
	r.Application_id = &x
}
	return r
}


// Aws_pinpoint_appHandler ...
type Aws_pinpoint_appHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_appHandler) Create(desired *Aws_pinpoint_app) (*Aws_pinpoint_app, string, error) {
	rState := Aws_pinpoint_appMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_app", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_appHandler) Read(externalID string) (*Aws_pinpoint_app, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_app", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_appUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_appHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_app", externalID)
}

type Aws_guardduty_detector struct {
     Aws_guardduty_detector_id *string
     Enable *bool
     Account_id *string
     Finding_publishing_frequency *string
}


func Aws_guardduty_detectorMapper(r *Aws_guardduty_detector) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Enable != nil {
    config["enable"] = *r.Enable
}
if r.Account_id != nil {
    config["account_id"] = *r.Account_id
}
if r.Finding_publishing_frequency != nil {
    config["finding_publishing_frequency"] = *r.Finding_publishing_frequency
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_guardduty_detectorUnmapper(state map[string]interface{}) *Aws_guardduty_detector {
	r := &Aws_guardduty_detector{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_guardduty_detector_id = &x
}

if x, ok := state["enable"]; ok {
	x := x.(bool)
	r.Enable = &x
}

if x, ok := state["account_id"]; ok {
	x := x.(string)
	r.Account_id = &x
}

if x, ok := state["finding_publishing_frequency"]; ok {
	x := x.(string)
	r.Finding_publishing_frequency = &x
}
	return r
}


// Aws_guardduty_detectorHandler ...
type Aws_guardduty_detectorHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_guardduty_detectorHandler) Create(desired *Aws_guardduty_detector) (*Aws_guardduty_detector, string, error) {
	rState := Aws_guardduty_detectorMapper(desired)
	id, err := bridge.Create(h.provider, "aws_guardduty_detector", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_guardduty_detectorHandler) Read(externalID string) (*Aws_guardduty_detector, error) {
	actual, err := bridge.Read(h.provider, "aws_guardduty_detector", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_guardduty_detectorUnmapper(actual), nil
}

// Delete ...
func (h *Aws_guardduty_detectorHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_guardduty_detector", externalID)
}

type Aws_load_balancer_policy struct {
     Aws_load_balancer_policy_id *string
     Policy_type_name string
     Load_balancer_name string
     Policy_name string
}


func Aws_load_balancer_policyMapper(r *Aws_load_balancer_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["policy_type_name"] = r.Policy_type_name
    config["load_balancer_name"] = r.Load_balancer_name
    config["policy_name"] = r.Policy_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_load_balancer_policyUnmapper(state map[string]interface{}) *Aws_load_balancer_policy {
	r := &Aws_load_balancer_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_load_balancer_policy_id = &x
}

if x, ok := state["load_balancer_name"]; ok {
	r.Load_balancer_name = x.(string)
}

if x, ok := state["policy_name"]; ok {
	r.Policy_name = x.(string)
}

if x, ok := state["policy_type_name"]; ok {
	r.Policy_type_name = x.(string)
}
	return r
}


// Aws_load_balancer_policyHandler ...
type Aws_load_balancer_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_load_balancer_policyHandler) Create(desired *Aws_load_balancer_policy) (*Aws_load_balancer_policy, string, error) {
	rState := Aws_load_balancer_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_load_balancer_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_load_balancer_policyHandler) Read(externalID string) (*Aws_load_balancer_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_load_balancer_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_load_balancer_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_load_balancer_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_load_balancer_policy", externalID)
}

type Aws_service_discovery_private_dns_namespace struct {
     Aws_service_discovery_private_dns_namespace_id *string
     Hosted_zone *string
     Name string
     Description *string
     Vpc string
     Arn *string
}


func Aws_service_discovery_private_dns_namespaceMapper(r *Aws_service_discovery_private_dns_namespace) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
    config["vpc"] = r.Vpc
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Hosted_zone != nil {
    config["hosted_zone"] = *r.Hosted_zone
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_service_discovery_private_dns_namespaceUnmapper(state map[string]interface{}) *Aws_service_discovery_private_dns_namespace {
	r := &Aws_service_discovery_private_dns_namespace{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_service_discovery_private_dns_namespace_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["vpc"]; ok {
	r.Vpc = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["hosted_zone"]; ok {
	x := x.(string)
	r.Hosted_zone = &x
}
	return r
}


// Aws_service_discovery_private_dns_namespaceHandler ...
type Aws_service_discovery_private_dns_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_service_discovery_private_dns_namespaceHandler) Create(desired *Aws_service_discovery_private_dns_namespace) (*Aws_service_discovery_private_dns_namespace, string, error) {
	rState := Aws_service_discovery_private_dns_namespaceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_service_discovery_private_dns_namespace", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_service_discovery_private_dns_namespaceHandler) Read(externalID string) (*Aws_service_discovery_private_dns_namespace, error) {
	actual, err := bridge.Read(h.provider, "aws_service_discovery_private_dns_namespace", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_service_discovery_private_dns_namespaceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_service_discovery_private_dns_namespaceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_service_discovery_private_dns_namespace", externalID)
}

type Aws_lb_target_group_attachment struct {
     Aws_lb_target_group_attachment_id *string
     Target_group_arn string
     Target_id string
     Availability_zone *string
}


func Aws_lb_target_group_attachmentMapper(r *Aws_lb_target_group_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["target_id"] = r.Target_id
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
    config["target_group_arn"] = r.Target_group_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lb_target_group_attachmentUnmapper(state map[string]interface{}) *Aws_lb_target_group_attachment {
	r := &Aws_lb_target_group_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lb_target_group_attachment_id = &x
}

if x, ok := state["target_group_arn"]; ok {
	r.Target_group_arn = x.(string)
}

if x, ok := state["target_id"]; ok {
	r.Target_id = x.(string)
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}
	return r
}


// Aws_lb_target_group_attachmentHandler ...
type Aws_lb_target_group_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lb_target_group_attachmentHandler) Create(desired *Aws_lb_target_group_attachment) (*Aws_lb_target_group_attachment, string, error) {
	rState := Aws_lb_target_group_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lb_target_group_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lb_target_group_attachmentHandler) Read(externalID string) (*Aws_lb_target_group_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_lb_target_group_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lb_target_group_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lb_target_group_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lb_target_group_attachment", externalID)
}

type Aws_elastic_beanstalk_configuration_template struct {
     Aws_elastic_beanstalk_configuration_template_id *string
     Name string
     Application string
     Description *string
     Environment_id *string
     Solution_stack_name *string
}


func Aws_elastic_beanstalk_configuration_templateMapper(r *Aws_elastic_beanstalk_configuration_template) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
if r.Environment_id != nil {
    config["environment_id"] = *r.Environment_id
}
if r.Solution_stack_name != nil {
    config["solution_stack_name"] = *r.Solution_stack_name
}
    config["name"] = r.Name
    config["application"] = r.Application
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elastic_beanstalk_configuration_templateUnmapper(state map[string]interface{}) *Aws_elastic_beanstalk_configuration_template {
	r := &Aws_elastic_beanstalk_configuration_template{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elastic_beanstalk_configuration_template_id = &x
}

if x, ok := state["application"]; ok {
	r.Application = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["environment_id"]; ok {
	x := x.(string)
	r.Environment_id = &x
}

if x, ok := state["solution_stack_name"]; ok {
	x := x.(string)
	r.Solution_stack_name = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_elastic_beanstalk_configuration_templateHandler ...
type Aws_elastic_beanstalk_configuration_templateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elastic_beanstalk_configuration_templateHandler) Create(desired *Aws_elastic_beanstalk_configuration_template) (*Aws_elastic_beanstalk_configuration_template, string, error) {
	rState := Aws_elastic_beanstalk_configuration_templateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elastic_beanstalk_configuration_template", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elastic_beanstalk_configuration_templateHandler) Read(externalID string) (*Aws_elastic_beanstalk_configuration_template, error) {
	actual, err := bridge.Read(h.provider, "aws_elastic_beanstalk_configuration_template", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elastic_beanstalk_configuration_templateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elastic_beanstalk_configuration_templateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elastic_beanstalk_configuration_template", externalID)
}

type Aws_iam_instance_profile struct {
     Aws_iam_instance_profile_id *string
     Path *string
     Role *string
     Arn *string
     Create_date *string
     Unique_id *string
     Name *string
     Name_prefix *string
}


func Aws_iam_instance_profileMapper(r *Aws_iam_instance_profile) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Role != nil {
    config["role"] = *r.Role
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Create_date != nil {
    config["create_date"] = *r.Create_date
}
if r.Unique_id != nil {
    config["unique_id"] = *r.Unique_id
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Path != nil {
    config["path"] = *r.Path
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_instance_profileUnmapper(state map[string]interface{}) *Aws_iam_instance_profile {
	r := &Aws_iam_instance_profile{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_instance_profile_id = &x
}

if x, ok := state["unique_id"]; ok {
	x := x.(string)
	r.Unique_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["path"]; ok {
	x := x.(string)
	r.Path = &x
}

if x, ok := state["role"]; ok {
	x := x.(string)
	r.Role = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["create_date"]; ok {
	x := x.(string)
	r.Create_date = &x
}
	return r
}


// Aws_iam_instance_profileHandler ...
type Aws_iam_instance_profileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_instance_profileHandler) Create(desired *Aws_iam_instance_profile) (*Aws_iam_instance_profile, string, error) {
	rState := Aws_iam_instance_profileMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_instance_profile", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_instance_profileHandler) Read(externalID string) (*Aws_iam_instance_profile, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_instance_profile", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_instance_profileUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_instance_profileHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_instance_profile", externalID)
}

type Aws_rds_global_cluster struct {
     Aws_rds_global_cluster_id *string
     Database_name *string
     Deletion_protection *bool
     Engine *string
     Engine_version *string
     Global_cluster_identifier string
     Global_cluster_resource_id *string
     Storage_encrypted *bool
     Arn *string
}


func Aws_rds_global_clusterMapper(r *Aws_rds_global_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Database_name != nil {
    config["database_name"] = *r.Database_name
}
if r.Deletion_protection != nil {
    config["deletion_protection"] = *r.Deletion_protection
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
    config["global_cluster_identifier"] = r.Global_cluster_identifier
if r.Global_cluster_resource_id != nil {
    config["global_cluster_resource_id"] = *r.Global_cluster_resource_id
}
if r.Storage_encrypted != nil {
    config["storage_encrypted"] = *r.Storage_encrypted
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_rds_global_clusterUnmapper(state map[string]interface{}) *Aws_rds_global_cluster {
	r := &Aws_rds_global_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_rds_global_cluster_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["database_name"]; ok {
	x := x.(string)
	r.Database_name = &x
}

if x, ok := state["deletion_protection"]; ok {
	x := x.(bool)
	r.Deletion_protection = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["global_cluster_identifier"]; ok {
	r.Global_cluster_identifier = x.(string)
}

if x, ok := state["global_cluster_resource_id"]; ok {
	x := x.(string)
	r.Global_cluster_resource_id = &x
}

if x, ok := state["storage_encrypted"]; ok {
	x := x.(bool)
	r.Storage_encrypted = &x
}
	return r
}


// Aws_rds_global_clusterHandler ...
type Aws_rds_global_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_rds_global_clusterHandler) Create(desired *Aws_rds_global_cluster) (*Aws_rds_global_cluster, string, error) {
	rState := Aws_rds_global_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_rds_global_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_rds_global_clusterHandler) Read(externalID string) (*Aws_rds_global_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_rds_global_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_rds_global_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_rds_global_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_rds_global_cluster", externalID)
}

type Aws_lightsail_instance struct {
     Aws_lightsail_instance_id *string
     Availability_zone string
     Arn *string
     Ipv6_address *string
     Blueprint_id string
     User_data *string
     Private_ip_address *string
     Username *string
     Key_pair_name *string
     Created_at *string
     Name string
     Bundle_id string
     Is_static_ip *bool
     Public_ip_address *string
}


func Aws_lightsail_instanceMapper(r *Aws_lightsail_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["availability_zone"] = r.Availability_zone
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Ipv6_address != nil {
    config["ipv6_address"] = *r.Ipv6_address
}
    config["blueprint_id"] = r.Blueprint_id
if r.User_data != nil {
    config["user_data"] = *r.User_data
}
if r.Private_ip_address != nil {
    config["private_ip_address"] = *r.Private_ip_address
}
if r.Username != nil {
    config["username"] = *r.Username
}
if r.Key_pair_name != nil {
    config["key_pair_name"] = *r.Key_pair_name
}
if r.Created_at != nil {
    config["created_at"] = *r.Created_at
}
    config["name"] = r.Name
    config["bundle_id"] = r.Bundle_id
if r.Is_static_ip != nil {
    config["is_static_ip"] = *r.Is_static_ip
}
if r.Public_ip_address != nil {
    config["public_ip_address"] = *r.Public_ip_address
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lightsail_instanceUnmapper(state map[string]interface{}) *Aws_lightsail_instance {
	r := &Aws_lightsail_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lightsail_instance_id = &x
}

if x, ok := state["availability_zone"]; ok {
	r.Availability_zone = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["ipv6_address"]; ok {
	x := x.(string)
	r.Ipv6_address = &x
}

if x, ok := state["blueprint_id"]; ok {
	r.Blueprint_id = x.(string)
}

if x, ok := state["user_data"]; ok {
	x := x.(string)
	r.User_data = &x
}

if x, ok := state["private_ip_address"]; ok {
	x := x.(string)
	r.Private_ip_address = &x
}

if x, ok := state["username"]; ok {
	x := x.(string)
	r.Username = &x
}

if x, ok := state["key_pair_name"]; ok {
	x := x.(string)
	r.Key_pair_name = &x
}

if x, ok := state["created_at"]; ok {
	x := x.(string)
	r.Created_at = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["bundle_id"]; ok {
	r.Bundle_id = x.(string)
}

if x, ok := state["is_static_ip"]; ok {
	x := x.(bool)
	r.Is_static_ip = &x
}

if x, ok := state["public_ip_address"]; ok {
	x := x.(string)
	r.Public_ip_address = &x
}
	return r
}


// Aws_lightsail_instanceHandler ...
type Aws_lightsail_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lightsail_instanceHandler) Create(desired *Aws_lightsail_instance) (*Aws_lightsail_instance, string, error) {
	rState := Aws_lightsail_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lightsail_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lightsail_instanceHandler) Read(externalID string) (*Aws_lightsail_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_lightsail_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lightsail_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lightsail_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lightsail_instance", externalID)
}

type Aws_lb_ssl_negotiation_policy struct {
     Aws_lb_ssl_negotiation_policy_id *string
     Name string
     Load_balancer string
}


func Aws_lb_ssl_negotiation_policyMapper(r *Aws_lb_ssl_negotiation_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["load_balancer"] = r.Load_balancer
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lb_ssl_negotiation_policyUnmapper(state map[string]interface{}) *Aws_lb_ssl_negotiation_policy {
	r := &Aws_lb_ssl_negotiation_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lb_ssl_negotiation_policy_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["load_balancer"]; ok {
	r.Load_balancer = x.(string)
}
	return r
}


// Aws_lb_ssl_negotiation_policyHandler ...
type Aws_lb_ssl_negotiation_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lb_ssl_negotiation_policyHandler) Create(desired *Aws_lb_ssl_negotiation_policy) (*Aws_lb_ssl_negotiation_policy, string, error) {
	rState := Aws_lb_ssl_negotiation_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lb_ssl_negotiation_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lb_ssl_negotiation_policyHandler) Read(externalID string) (*Aws_lb_ssl_negotiation_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_lb_ssl_negotiation_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lb_ssl_negotiation_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lb_ssl_negotiation_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lb_ssl_negotiation_policy", externalID)
}

type Aws_cloudwatch_log_metric_filter struct {
     Aws_cloudwatch_log_metric_filter_id *string
     Name string
     Pattern string
     Log_group_name string
}


func Aws_cloudwatch_log_metric_filterMapper(r *Aws_cloudwatch_log_metric_filter) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["pattern"] = r.Pattern
    config["log_group_name"] = r.Log_group_name
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_log_metric_filterUnmapper(state map[string]interface{}) *Aws_cloudwatch_log_metric_filter {
	r := &Aws_cloudwatch_log_metric_filter{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_log_metric_filter_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["pattern"]; ok {
	r.Pattern = x.(string)
}

if x, ok := state["log_group_name"]; ok {
	r.Log_group_name = x.(string)
}
	return r
}


// Aws_cloudwatch_log_metric_filterHandler ...
type Aws_cloudwatch_log_metric_filterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_log_metric_filterHandler) Create(desired *Aws_cloudwatch_log_metric_filter) (*Aws_cloudwatch_log_metric_filter, string, error) {
	rState := Aws_cloudwatch_log_metric_filterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_log_metric_filter", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_log_metric_filterHandler) Read(externalID string) (*Aws_cloudwatch_log_metric_filter, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_log_metric_filter", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_log_metric_filterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_log_metric_filterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_log_metric_filter", externalID)
}

type Aws_rds_cluster_instance struct {
     Aws_rds_cluster_instance_id *string
     Dbi_resource_id *string
     Auto_minor_version_upgrade *bool
     Engine *string
     Storage_encrypted *bool
     Tags *map[string]string
     Identifier *string
     Instance_class string
     Db_subnet_group_name *string
     Kms_key_id *string
     Preferred_backup_window *string
     Engine_version *string
     Db_parameter_group_name *string
     Apply_immediately *bool
     Availability_zone *string
     Performance_insights_enabled *bool
     Identifier_prefix *string
     Publicly_accessible *bool
     Endpoint *string
     Copy_tags_to_snapshot *bool
     Performance_insights_kms_key_id *string
     Arn *string
     Monitoring_role_arn *string
     Preferred_maintenance_window *string
     Writer *bool
     Cluster_identifier string
}


func Aws_rds_cluster_instanceMapper(r *Aws_rds_cluster_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Monitoring_role_arn != nil {
    config["monitoring_role_arn"] = *r.Monitoring_role_arn
}
if r.Performance_insights_kms_key_id != nil {
    config["performance_insights_kms_key_id"] = *r.Performance_insights_kms_key_id
}
if r.Writer != nil {
    config["writer"] = *r.Writer
}
    config["cluster_identifier"] = r.Cluster_identifier
if r.Preferred_maintenance_window != nil {
    config["preferred_maintenance_window"] = *r.Preferred_maintenance_window
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Storage_encrypted != nil {
    config["storage_encrypted"] = *r.Storage_encrypted
}
if r.Dbi_resource_id != nil {
    config["dbi_resource_id"] = *r.Dbi_resource_id
}
if r.Auto_minor_version_upgrade != nil {
    config["auto_minor_version_upgrade"] = *r.Auto_minor_version_upgrade
}
if r.Identifier != nil {
    config["identifier"] = *r.Identifier
}
    config["instance_class"] = r.Instance_class
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Db_subnet_group_name != nil {
    config["db_subnet_group_name"] = *r.Db_subnet_group_name
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Preferred_backup_window != nil {
    config["preferred_backup_window"] = *r.Preferred_backup_window
}
if r.Apply_immediately != nil {
    config["apply_immediately"] = *r.Apply_immediately
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Performance_insights_enabled != nil {
    config["performance_insights_enabled"] = *r.Performance_insights_enabled
}
if r.Identifier_prefix != nil {
    config["identifier_prefix"] = *r.Identifier_prefix
}
if r.Publicly_accessible != nil {
    config["publicly_accessible"] = *r.Publicly_accessible
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Db_parameter_group_name != nil {
    config["db_parameter_group_name"] = *r.Db_parameter_group_name
}
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
if r.Copy_tags_to_snapshot != nil {
    config["copy_tags_to_snapshot"] = *r.Copy_tags_to_snapshot
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_rds_cluster_instanceUnmapper(state map[string]interface{}) *Aws_rds_cluster_instance {
	r := &Aws_rds_cluster_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_rds_cluster_instance_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["monitoring_role_arn"]; ok {
	x := x.(string)
	r.Monitoring_role_arn = &x
}

if x, ok := state["performance_insights_kms_key_id"]; ok {
	x := x.(string)
	r.Performance_insights_kms_key_id = &x
}

if x, ok := state["writer"]; ok {
	x := x.(bool)
	r.Writer = &x
}

if x, ok := state["cluster_identifier"]; ok {
	r.Cluster_identifier = x.(string)
}

if x, ok := state["preferred_maintenance_window"]; ok {
	x := x.(string)
	r.Preferred_maintenance_window = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["storage_encrypted"]; ok {
	x := x.(bool)
	r.Storage_encrypted = &x
}

if x, ok := state["dbi_resource_id"]; ok {
	x := x.(string)
	r.Dbi_resource_id = &x
}

if x, ok := state["auto_minor_version_upgrade"]; ok {
	x := x.(bool)
	r.Auto_minor_version_upgrade = &x
}

if x, ok := state["identifier"]; ok {
	x := x.(string)
	r.Identifier = &x
}

if x, ok := state["instance_class"]; ok {
	r.Instance_class = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["db_subnet_group_name"]; ok {
	x := x.(string)
	r.Db_subnet_group_name = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["preferred_backup_window"]; ok {
	x := x.(string)
	r.Preferred_backup_window = &x
}

if x, ok := state["performance_insights_enabled"]; ok {
	x := x.(bool)
	r.Performance_insights_enabled = &x
}

if x, ok := state["identifier_prefix"]; ok {
	x := x.(string)
	r.Identifier_prefix = &x
}

if x, ok := state["publicly_accessible"]; ok {
	x := x.(bool)
	r.Publicly_accessible = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["db_parameter_group_name"]; ok {
	x := x.(string)
	r.Db_parameter_group_name = &x
}

if x, ok := state["apply_immediately"]; ok {
	x := x.(bool)
	r.Apply_immediately = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["copy_tags_to_snapshot"]; ok {
	x := x.(bool)
	r.Copy_tags_to_snapshot = &x
}
	return r
}


// Aws_rds_cluster_instanceHandler ...
type Aws_rds_cluster_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_rds_cluster_instanceHandler) Create(desired *Aws_rds_cluster_instance) (*Aws_rds_cluster_instance, string, error) {
	rState := Aws_rds_cluster_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_rds_cluster_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_rds_cluster_instanceHandler) Read(externalID string) (*Aws_rds_cluster_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_rds_cluster_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_rds_cluster_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_rds_cluster_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_rds_cluster_instance", externalID)
}

type Aws_waf_rule struct {
     Aws_waf_rule_id *string
     Name string
     Metric_name string
}


func Aws_waf_ruleMapper(r *Aws_waf_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["metric_name"] = r.Metric_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_ruleUnmapper(state map[string]interface{}) *Aws_waf_rule {
	r := &Aws_waf_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_rule_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["metric_name"]; ok {
	r.Metric_name = x.(string)
}
	return r
}


// Aws_waf_ruleHandler ...
type Aws_waf_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_ruleHandler) Create(desired *Aws_waf_rule) (*Aws_waf_rule, string, error) {
	rState := Aws_waf_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_ruleHandler) Read(externalID string) (*Aws_waf_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_rule", externalID)
}

type Aws_api_gateway_deployment struct {
     Aws_api_gateway_deployment_id *string
     Variables *map[string]string
     Created_date *string
     Invoke_url *string
     Execution_arn *string
     Rest_api_id string
     Stage_name string
     Description *string
     Stage_description *string
}


func Aws_api_gateway_deploymentMapper(r *Aws_api_gateway_deployment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
if r.Stage_description != nil {
    config["stage_description"] = *r.Stage_description
}
if r.Variables != nil {
    config["variables"] = *r.Variables
}
if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
if r.Invoke_url != nil {
    config["invoke_url"] = *r.Invoke_url
}
if r.Execution_arn != nil {
    config["execution_arn"] = *r.Execution_arn
}
    config["rest_api_id"] = r.Rest_api_id
    config["stage_name"] = r.Stage_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_deploymentUnmapper(state map[string]interface{}) *Aws_api_gateway_deployment {
	r := &Aws_api_gateway_deployment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_deployment_id = &x
}

if x, ok := state["stage_description"]; ok {
	x := x.(string)
	r.Stage_description = &x
}

if x, ok := state["variables"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Variables = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}

if x, ok := state["invoke_url"]; ok {
	x := x.(string)
	r.Invoke_url = &x
}

if x, ok := state["execution_arn"]; ok {
	x := x.(string)
	r.Execution_arn = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["stage_name"]; ok {
	r.Stage_name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_api_gateway_deploymentHandler ...
type Aws_api_gateway_deploymentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_deploymentHandler) Create(desired *Aws_api_gateway_deployment) (*Aws_api_gateway_deployment, string, error) {
	rState := Aws_api_gateway_deploymentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_deployment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_deploymentHandler) Read(externalID string) (*Aws_api_gateway_deployment, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_deployment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_deploymentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_deploymentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_deployment", externalID)
}

type Aws_api_gateway_integration struct {
     Aws_api_gateway_integration_id *string
     Rest_api_id string
     Resource_id string
     Request_parameters *map[string]string
     Connection_type *string
     Integration_http_method *string
     Cache_namespace *string
     Connection_id *string
     Uri *string
     Request_templates *map[string]string
     Request_parameters_in_json *string
     Content_handling *string
     Passthrough_behavior *string
     Http_method string
     Resource_type string
     Credentials *string
}


func Aws_api_gateway_integrationMapper(r *Aws_api_gateway_integration) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Passthrough_behavior != nil {
    config["passthrough_behavior"] = *r.Passthrough_behavior
}
if r.Connection_id != nil {
    config["connection_id"] = *r.Connection_id
}
if r.Uri != nil {
    config["uri"] = *r.Uri
}
if r.Request_templates != nil {
    config["request_templates"] = *r.Request_templates
}
if r.Request_parameters_in_json != nil {
    config["request_parameters_in_json"] = *r.Request_parameters_in_json
}
if r.Content_handling != nil {
    config["content_handling"] = *r.Content_handling
}
    config["http_method"] = r.Http_method
    config["resource_type"] = r.Resource_type
if r.Credentials != nil {
    config["credentials"] = *r.Credentials
}
    config["rest_api_id"] = r.Rest_api_id
    config["resource_id"] = r.Resource_id
if r.Request_parameters != nil {
    config["request_parameters"] = *r.Request_parameters
}
if r.Connection_type != nil {
    config["connection_type"] = *r.Connection_type
}
if r.Integration_http_method != nil {
    config["integration_http_method"] = *r.Integration_http_method
}
if r.Cache_namespace != nil {
    config["cache_namespace"] = *r.Cache_namespace
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_integrationUnmapper(state map[string]interface{}) *Aws_api_gateway_integration {
	r := &Aws_api_gateway_integration{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_integration_id = &x
}

if x, ok := state["connection_type"]; ok {
	x := x.(string)
	r.Connection_type = &x
}

if x, ok := state["integration_http_method"]; ok {
	x := x.(string)
	r.Integration_http_method = &x
}

if x, ok := state["cache_namespace"]; ok {
	x := x.(string)
	r.Cache_namespace = &x
}

if x, ok := state["connection_id"]; ok {
	x := x.(string)
	r.Connection_id = &x
}

if x, ok := state["uri"]; ok {
	x := x.(string)
	r.Uri = &x
}

if x, ok := state["request_templates"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Request_templates = &x
}

if x, ok := state["request_parameters_in_json"]; ok {
	x := x.(string)
	r.Request_parameters_in_json = &x
}

if x, ok := state["content_handling"]; ok {
	x := x.(string)
	r.Content_handling = &x
}

if x, ok := state["passthrough_behavior"]; ok {
	x := x.(string)
	r.Passthrough_behavior = &x
}

if x, ok := state["http_method"]; ok {
	r.Http_method = x.(string)
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["credentials"]; ok {
	x := x.(string)
	r.Credentials = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["resource_id"]; ok {
	r.Resource_id = x.(string)
}

if x, ok := state["request_parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Request_parameters = &x
}
	return r
}


// Aws_api_gateway_integrationHandler ...
type Aws_api_gateway_integrationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_integrationHandler) Create(desired *Aws_api_gateway_integration) (*Aws_api_gateway_integration, string, error) {
	rState := Aws_api_gateway_integrationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_integration", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_integrationHandler) Read(externalID string) (*Aws_api_gateway_integration, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_integration", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_integrationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_integrationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_integration", externalID)
}

type Aws_ses_receipt_rule struct {
     Aws_ses_receipt_rule_id *string
     Scan_enabled *bool
     Tls_policy *string
     Enabled *bool
     Name string
     Rule_set_name string
     After *string
}


func Aws_ses_receipt_ruleMapper(r *Aws_ses_receipt_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.After != nil {
    config["after"] = *r.After
}
if r.Scan_enabled != nil {
    config["scan_enabled"] = *r.Scan_enabled
}
if r.Tls_policy != nil {
    config["tls_policy"] = *r.Tls_policy
}
    config["name"] = r.Name
    config["rule_set_name"] = r.Rule_set_name
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_receipt_ruleUnmapper(state map[string]interface{}) *Aws_ses_receipt_rule {
	r := &Aws_ses_receipt_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_receipt_rule_id = &x
}

if x, ok := state["after"]; ok {
	x := x.(string)
	r.After = &x
}

if x, ok := state["tls_policy"]; ok {
	x := x.(string)
	r.Tls_policy = &x
}

if x, ok := state["scan_enabled"]; ok {
	x := x.(bool)
	r.Scan_enabled = &x
}

if x, ok := state["rule_set_name"]; ok {
	r.Rule_set_name = x.(string)
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_ses_receipt_ruleHandler ...
type Aws_ses_receipt_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_receipt_ruleHandler) Create(desired *Aws_ses_receipt_rule) (*Aws_ses_receipt_rule, string, error) {
	rState := Aws_ses_receipt_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_receipt_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_receipt_ruleHandler) Read(externalID string) (*Aws_ses_receipt_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_receipt_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_receipt_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_receipt_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_receipt_rule", externalID)
}

type Aws_ses_configuration_set struct {
     Aws_ses_configuration_set_id *string
     Name string
}


func Aws_ses_configuration_setMapper(r *Aws_ses_configuration_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_configuration_setUnmapper(state map[string]interface{}) *Aws_ses_configuration_set {
	r := &Aws_ses_configuration_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_configuration_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_ses_configuration_setHandler ...
type Aws_ses_configuration_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_configuration_setHandler) Create(desired *Aws_ses_configuration_set) (*Aws_ses_configuration_set, string, error) {
	rState := Aws_ses_configuration_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_configuration_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_configuration_setHandler) Read(externalID string) (*Aws_ses_configuration_set, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_configuration_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_configuration_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_configuration_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_configuration_set", externalID)
}

type Aws_db_security_group struct {
     Aws_db_security_group_id *string
     Tags *map[string]string
     Arn *string
     Name string
     Description *string
}


func Aws_db_security_groupMapper(r *Aws_db_security_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_db_security_groupUnmapper(state map[string]interface{}) *Aws_db_security_group {
	r := &Aws_db_security_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_db_security_group_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_db_security_groupHandler ...
type Aws_db_security_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_db_security_groupHandler) Create(desired *Aws_db_security_group) (*Aws_db_security_group, string, error) {
	rState := Aws_db_security_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_db_security_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_db_security_groupHandler) Read(externalID string) (*Aws_db_security_group, error) {
	actual, err := bridge.Read(h.provider, "aws_db_security_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_db_security_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_db_security_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_db_security_group", externalID)
}

type Aws_dx_hosted_public_virtual_interface struct {
     Aws_dx_hosted_public_virtual_interface_id *string
     Bgp_auth_key *string
     Amazon_address *string
     Owner_account_id string
     Connection_id string
     Address_family string
     Customer_address *string
     Arn *string
     Name string
}


func Aws_dx_hosted_public_virtual_interfaceMapper(r *Aws_dx_hosted_public_virtual_interface) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Customer_address != nil {
    config["customer_address"] = *r.Customer_address
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
    config["address_family"] = r.Address_family
    config["owner_account_id"] = r.Owner_account_id
    config["connection_id"] = r.Connection_id
if r.Bgp_auth_key != nil {
    config["bgp_auth_key"] = *r.Bgp_auth_key
}
if r.Amazon_address != nil {
    config["amazon_address"] = *r.Amazon_address
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_hosted_public_virtual_interfaceUnmapper(state map[string]interface{}) *Aws_dx_hosted_public_virtual_interface {
	r := &Aws_dx_hosted_public_virtual_interface{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_hosted_public_virtual_interface_id = &x
}

if x, ok := state["address_family"]; ok {
	r.Address_family = x.(string)
}

if x, ok := state["customer_address"]; ok {
	x := x.(string)
	r.Customer_address = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["bgp_auth_key"]; ok {
	x := x.(string)
	r.Bgp_auth_key = &x
}

if x, ok := state["amazon_address"]; ok {
	x := x.(string)
	r.Amazon_address = &x
}

if x, ok := state["owner_account_id"]; ok {
	r.Owner_account_id = x.(string)
}

if x, ok := state["connection_id"]; ok {
	r.Connection_id = x.(string)
}
	return r
}


// Aws_dx_hosted_public_virtual_interfaceHandler ...
type Aws_dx_hosted_public_virtual_interfaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_hosted_public_virtual_interfaceHandler) Create(desired *Aws_dx_hosted_public_virtual_interface) (*Aws_dx_hosted_public_virtual_interface, string, error) {
	rState := Aws_dx_hosted_public_virtual_interfaceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_hosted_public_virtual_interface", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_hosted_public_virtual_interfaceHandler) Read(externalID string) (*Aws_dx_hosted_public_virtual_interface, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_hosted_public_virtual_interface", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_hosted_public_virtual_interfaceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_hosted_public_virtual_interfaceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_hosted_public_virtual_interface", externalID)
}

type Aws_mq_configuration struct {
     Aws_mq_configuration_id *string
     Name string
     Arn *string
     Data string
     Description *string
     Engine_type string
     Engine_version string
}


func Aws_mq_configurationMapper(r *Aws_mq_configuration) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["engine_type"] = r.Engine_type
    config["engine_version"] = r.Engine_version
    config["name"] = r.Name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["data"] = r.Data
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_mq_configurationUnmapper(state map[string]interface{}) *Aws_mq_configuration {
	r := &Aws_mq_configuration{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_mq_configuration_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["data"]; ok {
	r.Data = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["engine_type"]; ok {
	r.Engine_type = x.(string)
}

if x, ok := state["engine_version"]; ok {
	r.Engine_version = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_mq_configurationHandler ...
type Aws_mq_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_mq_configurationHandler) Create(desired *Aws_mq_configuration) (*Aws_mq_configuration, string, error) {
	rState := Aws_mq_configurationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_mq_configuration", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_mq_configurationHandler) Read(externalID string) (*Aws_mq_configuration, error) {
	actual, err := bridge.Read(h.provider, "aws_mq_configuration", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_mq_configurationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_mq_configurationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_mq_configuration", externalID)
}

type Aws_wafregional_web_acl struct {
     Aws_wafregional_web_acl_id *string
     Name string
     Metric_name string
}


func Aws_wafregional_web_aclMapper(r *Aws_wafregional_web_acl) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["metric_name"] = r.Metric_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_web_aclUnmapper(state map[string]interface{}) *Aws_wafregional_web_acl {
	r := &Aws_wafregional_web_acl{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_web_acl_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["metric_name"]; ok {
	r.Metric_name = x.(string)
}
	return r
}


// Aws_wafregional_web_aclHandler ...
type Aws_wafregional_web_aclHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_web_aclHandler) Create(desired *Aws_wafregional_web_acl) (*Aws_wafregional_web_acl, string, error) {
	rState := Aws_wafregional_web_aclMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_web_acl", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_web_aclHandler) Read(externalID string) (*Aws_wafregional_web_acl, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_web_acl", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_web_aclUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_web_aclHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_web_acl", externalID)
}

type Aws_ecr_lifecycle_policy struct {
     Aws_ecr_lifecycle_policy_id *string
     Repository string
     Policy string
     Registry_id *string
}


func Aws_ecr_lifecycle_policyMapper(r *Aws_ecr_lifecycle_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Registry_id != nil {
    config["registry_id"] = *r.Registry_id
}
    config["repository"] = r.Repository
    config["policy"] = r.Policy
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ecr_lifecycle_policyUnmapper(state map[string]interface{}) *Aws_ecr_lifecycle_policy {
	r := &Aws_ecr_lifecycle_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ecr_lifecycle_policy_id = &x
}

if x, ok := state["repository"]; ok {
	r.Repository = x.(string)
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}

if x, ok := state["registry_id"]; ok {
	x := x.(string)
	r.Registry_id = &x
}
	return r
}


// Aws_ecr_lifecycle_policyHandler ...
type Aws_ecr_lifecycle_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ecr_lifecycle_policyHandler) Create(desired *Aws_ecr_lifecycle_policy) (*Aws_ecr_lifecycle_policy, string, error) {
	rState := Aws_ecr_lifecycle_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ecr_lifecycle_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ecr_lifecycle_policyHandler) Read(externalID string) (*Aws_ecr_lifecycle_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_ecr_lifecycle_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ecr_lifecycle_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ecr_lifecycle_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ecr_lifecycle_policy", externalID)
}

type Aws_lightsail_static_ip_attachment struct {
     Aws_lightsail_static_ip_attachment_id *string
     Static_ip_name string
     Instance_name string
}


func Aws_lightsail_static_ip_attachmentMapper(r *Aws_lightsail_static_ip_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["static_ip_name"] = r.Static_ip_name
    config["instance_name"] = r.Instance_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lightsail_static_ip_attachmentUnmapper(state map[string]interface{}) *Aws_lightsail_static_ip_attachment {
	r := &Aws_lightsail_static_ip_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lightsail_static_ip_attachment_id = &x
}

if x, ok := state["static_ip_name"]; ok {
	r.Static_ip_name = x.(string)
}

if x, ok := state["instance_name"]; ok {
	r.Instance_name = x.(string)
}
	return r
}


// Aws_lightsail_static_ip_attachmentHandler ...
type Aws_lightsail_static_ip_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lightsail_static_ip_attachmentHandler) Create(desired *Aws_lightsail_static_ip_attachment) (*Aws_lightsail_static_ip_attachment, string, error) {
	rState := Aws_lightsail_static_ip_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lightsail_static_ip_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lightsail_static_ip_attachmentHandler) Read(externalID string) (*Aws_lightsail_static_ip_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_lightsail_static_ip_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lightsail_static_ip_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lightsail_static_ip_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lightsail_static_ip_attachment", externalID)
}

type Aws_db_instance struct {
     Aws_db_instance_id *string
     Arn *string
     Domain_iam_role_name *string
     Parameter_group_name *string
     Endpoint *string
     Status *string
     Identifier *string
     Timezone *string
     Name *string
     Copy_tags_to_snapshot *bool
     License_model *string
     Tags *map[string]string
     Kms_key_id *string
     Ca_cert_identifier *string
     Storage_type *string
     Hosted_zone_id *string
     Replicate_source_db *string
     Deletion_protection *bool
     Backup_window *string
     Skip_final_snapshot *bool
     Availability_zone *string
     Auto_minor_version_upgrade *bool
     Iam_database_authentication_enabled *bool
     Username *string
     Engine_version *string
     Instance_class string
     Character_set_name *string
     Db_subnet_group_name *string
     Allow_major_version_upgrade *bool
     Apply_immediately *bool
     Option_group_name *string
     Identifier_prefix *string
     Maintenance_window *string
     Publicly_accessible *bool
     Final_snapshot_identifier *string
     Address *string
     Password *string
     Engine *string
     Storage_encrypted *bool
     Domain *string
     Snapshot_identifier *string
     Resource_id *string
     Multi_az *bool
     Monitoring_role_arn *string
}


func Aws_db_instanceMapper(r *Aws_db_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Copy_tags_to_snapshot != nil {
    config["copy_tags_to_snapshot"] = *r.Copy_tags_to_snapshot
}
if r.License_model != nil {
    config["license_model"] = *r.License_model
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Hosted_zone_id != nil {
    config["hosted_zone_id"] = *r.Hosted_zone_id
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Ca_cert_identifier != nil {
    config["ca_cert_identifier"] = *r.Ca_cert_identifier
}
if r.Storage_type != nil {
    config["storage_type"] = *r.Storage_type
}
if r.Replicate_source_db != nil {
    config["replicate_source_db"] = *r.Replicate_source_db
}
if r.Deletion_protection != nil {
    config["deletion_protection"] = *r.Deletion_protection
}
if r.Backup_window != nil {
    config["backup_window"] = *r.Backup_window
}
if r.Skip_final_snapshot != nil {
    config["skip_final_snapshot"] = *r.Skip_final_snapshot
}
    config["instance_class"] = r.Instance_class
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Auto_minor_version_upgrade != nil {
    config["auto_minor_version_upgrade"] = *r.Auto_minor_version_upgrade
}
if r.Iam_database_authentication_enabled != nil {
    config["iam_database_authentication_enabled"] = *r.Iam_database_authentication_enabled
}
if r.Username != nil {
    config["username"] = *r.Username
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Allow_major_version_upgrade != nil {
    config["allow_major_version_upgrade"] = *r.Allow_major_version_upgrade
}
if r.Character_set_name != nil {
    config["character_set_name"] = *r.Character_set_name
}
if r.Db_subnet_group_name != nil {
    config["db_subnet_group_name"] = *r.Db_subnet_group_name
}
if r.Apply_immediately != nil {
    config["apply_immediately"] = *r.Apply_immediately
}
if r.Option_group_name != nil {
    config["option_group_name"] = *r.Option_group_name
}
if r.Identifier_prefix != nil {
    config["identifier_prefix"] = *r.Identifier_prefix
}
if r.Maintenance_window != nil {
    config["maintenance_window"] = *r.Maintenance_window
}
if r.Storage_encrypted != nil {
    config["storage_encrypted"] = *r.Storage_encrypted
}
if r.Publicly_accessible != nil {
    config["publicly_accessible"] = *r.Publicly_accessible
}
if r.Final_snapshot_identifier != nil {
    config["final_snapshot_identifier"] = *r.Final_snapshot_identifier
}
if r.Address != nil {
    config["address"] = *r.Address
}
if r.Password != nil {
    config["password"] = *r.Password
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Domain != nil {
    config["domain"] = *r.Domain
}
if r.Snapshot_identifier != nil {
    config["snapshot_identifier"] = *r.Snapshot_identifier
}
if r.Resource_id != nil {
    config["resource_id"] = *r.Resource_id
}
if r.Multi_az != nil {
    config["multi_az"] = *r.Multi_az
}
if r.Monitoring_role_arn != nil {
    config["monitoring_role_arn"] = *r.Monitoring_role_arn
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Domain_iam_role_name != nil {
    config["domain_iam_role_name"] = *r.Domain_iam_role_name
}
if r.Parameter_group_name != nil {
    config["parameter_group_name"] = *r.Parameter_group_name
}
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
if r.Identifier != nil {
    config["identifier"] = *r.Identifier
}
if r.Timezone != nil {
    config["timezone"] = *r.Timezone
}
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_db_instanceUnmapper(state map[string]interface{}) *Aws_db_instance {
	r := &Aws_db_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_db_instance_id = &x
}

if x, ok := state["license_model"]; ok {
	x := x.(string)
	r.License_model = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["ca_cert_identifier"]; ok {
	x := x.(string)
	r.Ca_cert_identifier = &x
}

if x, ok := state["storage_type"]; ok {
	x := x.(string)
	r.Storage_type = &x
}

if x, ok := state["hosted_zone_id"]; ok {
	x := x.(string)
	r.Hosted_zone_id = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["replicate_source_db"]; ok {
	x := x.(string)
	r.Replicate_source_db = &x
}

if x, ok := state["deletion_protection"]; ok {
	x := x.(bool)
	r.Deletion_protection = &x
}

if x, ok := state["backup_window"]; ok {
	x := x.(string)
	r.Backup_window = &x
}

if x, ok := state["skip_final_snapshot"]; ok {
	x := x.(bool)
	r.Skip_final_snapshot = &x
}

if x, ok := state["auto_minor_version_upgrade"]; ok {
	x := x.(bool)
	r.Auto_minor_version_upgrade = &x
}

if x, ok := state["iam_database_authentication_enabled"]; ok {
	x := x.(bool)
	r.Iam_database_authentication_enabled = &x
}

if x, ok := state["username"]; ok {
	x := x.(string)
	r.Username = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["instance_class"]; ok {
	r.Instance_class = x.(string)
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["character_set_name"]; ok {
	x := x.(string)
	r.Character_set_name = &x
}

if x, ok := state["db_subnet_group_name"]; ok {
	x := x.(string)
	r.Db_subnet_group_name = &x
}

if x, ok := state["allow_major_version_upgrade"]; ok {
	x := x.(bool)
	r.Allow_major_version_upgrade = &x
}

if x, ok := state["option_group_name"]; ok {
	x := x.(string)
	r.Option_group_name = &x
}

if x, ok := state["identifier_prefix"]; ok {
	x := x.(string)
	r.Identifier_prefix = &x
}

if x, ok := state["maintenance_window"]; ok {
	x := x.(string)
	r.Maintenance_window = &x
}

if x, ok := state["apply_immediately"]; ok {
	x := x.(bool)
	r.Apply_immediately = &x
}

if x, ok := state["publicly_accessible"]; ok {
	x := x.(bool)
	r.Publicly_accessible = &x
}

if x, ok := state["final_snapshot_identifier"]; ok {
	x := x.(string)
	r.Final_snapshot_identifier = &x
}

if x, ok := state["address"]; ok {
	x := x.(string)
	r.Address = &x
}

if x, ok := state["password"]; ok {
	x := x.(string)
	r.Password = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["storage_encrypted"]; ok {
	x := x.(bool)
	r.Storage_encrypted = &x
}

if x, ok := state["domain"]; ok {
	x := x.(string)
	r.Domain = &x
}

if x, ok := state["snapshot_identifier"]; ok {
	x := x.(string)
	r.Snapshot_identifier = &x
}

if x, ok := state["resource_id"]; ok {
	x := x.(string)
	r.Resource_id = &x
}

if x, ok := state["multi_az"]; ok {
	x := x.(bool)
	r.Multi_az = &x
}

if x, ok := state["monitoring_role_arn"]; ok {
	x := x.(string)
	r.Monitoring_role_arn = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["parameter_group_name"]; ok {
	x := x.(string)
	r.Parameter_group_name = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["domain_iam_role_name"]; ok {
	x := x.(string)
	r.Domain_iam_role_name = &x
}

if x, ok := state["identifier"]; ok {
	x := x.(string)
	r.Identifier = &x
}

if x, ok := state["timezone"]; ok {
	x := x.(string)
	r.Timezone = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["copy_tags_to_snapshot"]; ok {
	x := x.(bool)
	r.Copy_tags_to_snapshot = &x
}
	return r
}


// Aws_db_instanceHandler ...
type Aws_db_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_db_instanceHandler) Create(desired *Aws_db_instance) (*Aws_db_instance, string, error) {
	rState := Aws_db_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_db_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_db_instanceHandler) Read(externalID string) (*Aws_db_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_db_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_db_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_db_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_db_instance", externalID)
}

type Aws_dx_gateway struct {
     Aws_dx_gateway_id *string
     Amazon_side_asn string
     Name string
}


func Aws_dx_gatewayMapper(r *Aws_dx_gateway) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["amazon_side_asn"] = r.Amazon_side_asn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_gatewayUnmapper(state map[string]interface{}) *Aws_dx_gateway {
	r := &Aws_dx_gateway{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_gateway_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["amazon_side_asn"]; ok {
	r.Amazon_side_asn = x.(string)
}
	return r
}


// Aws_dx_gatewayHandler ...
type Aws_dx_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_gatewayHandler) Create(desired *Aws_dx_gateway) (*Aws_dx_gateway, string, error) {
	rState := Aws_dx_gatewayMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_gateway", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_gatewayHandler) Read(externalID string) (*Aws_dx_gateway, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_gateway", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_gatewayUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_gatewayHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_gateway", externalID)
}

type Aws_security_group_rule struct {
     Aws_security_group_rule_id *string
     Resource_type string
     Description *string
     Security_group_id string
     Source_security_group_id *string
     Self *bool
     Protocol string
}


func Aws_security_group_ruleMapper(r *Aws_security_group_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["protocol"] = r.Protocol
    config["security_group_id"] = r.Security_group_id
if r.Source_security_group_id != nil {
    config["source_security_group_id"] = *r.Source_security_group_id
}
if r.Self != nil {
    config["self"] = *r.Self
}
    config["resource_type"] = r.Resource_type
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_security_group_ruleUnmapper(state map[string]interface{}) *Aws_security_group_rule {
	r := &Aws_security_group_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_security_group_rule_id = &x
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["security_group_id"]; ok {
	r.Security_group_id = x.(string)
}

if x, ok := state["source_security_group_id"]; ok {
	x := x.(string)
	r.Source_security_group_id = &x
}

if x, ok := state["self"]; ok {
	x := x.(bool)
	r.Self = &x
}

if x, ok := state["protocol"]; ok {
	r.Protocol = x.(string)
}
	return r
}


// Aws_security_group_ruleHandler ...
type Aws_security_group_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_security_group_ruleHandler) Create(desired *Aws_security_group_rule) (*Aws_security_group_rule, string, error) {
	rState := Aws_security_group_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_security_group_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_security_group_ruleHandler) Read(externalID string) (*Aws_security_group_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_security_group_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_security_group_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_security_group_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_security_group_rule", externalID)
}

type Aws_lb struct {
     Aws_lb_id *string
     Ip_address_type *string
     Tags *map[string]string
     Name_prefix *string
     Internal *bool
     Load_balancer_type *string
     Arn_suffix *string
     Name *string
     Enable_deletion_protection *bool
     Vpc_id *string
     Arn *string
     Zone_id *string
     Dns_name *string
     Enable_cross_zone_load_balancing *bool
     Enable_http2 *bool
}


func Aws_lbMapper(r *Aws_lb) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Enable_cross_zone_load_balancing != nil {
    config["enable_cross_zone_load_balancing"] = *r.Enable_cross_zone_load_balancing
}
if r.Enable_http2 != nil {
    config["enable_http2"] = *r.Enable_http2
}
if r.Dns_name != nil {
    config["dns_name"] = *r.Dns_name
}
if r.Load_balancer_type != nil {
    config["load_balancer_type"] = *r.Load_balancer_type
}
if r.Ip_address_type != nil {
    config["ip_address_type"] = *r.Ip_address_type
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Internal != nil {
    config["internal"] = *r.Internal
}
if r.Enable_deletion_protection != nil {
    config["enable_deletion_protection"] = *r.Enable_deletion_protection
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Arn_suffix != nil {
    config["arn_suffix"] = *r.Arn_suffix
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Zone_id != nil {
    config["zone_id"] = *r.Zone_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lbUnmapper(state map[string]interface{}) *Aws_lb {
	r := &Aws_lb{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lb_id = &x
}

if x, ok := state["dns_name"]; ok {
	x := x.(string)
	r.Dns_name = &x
}

if x, ok := state["enable_cross_zone_load_balancing"]; ok {
	x := x.(bool)
	r.Enable_cross_zone_load_balancing = &x
}

if x, ok := state["enable_http2"]; ok {
	x := x.(bool)
	r.Enable_http2 = &x
}

if x, ok := state["ip_address_type"]; ok {
	x := x.(string)
	r.Ip_address_type = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["internal"]; ok {
	x := x.(bool)
	r.Internal = &x
}

if x, ok := state["load_balancer_type"]; ok {
	x := x.(string)
	r.Load_balancer_type = &x
}

if x, ok := state["arn_suffix"]; ok {
	x := x.(string)
	r.Arn_suffix = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["enable_deletion_protection"]; ok {
	x := x.(bool)
	r.Enable_deletion_protection = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["zone_id"]; ok {
	x := x.(string)
	r.Zone_id = &x
}
	return r
}


// Aws_lbHandler ...
type Aws_lbHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lbHandler) Create(desired *Aws_lb) (*Aws_lb, string, error) {
	rState := Aws_lbMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lb", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lbHandler) Read(externalID string) (*Aws_lb, error) {
	actual, err := bridge.Read(h.provider, "aws_lb", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lbUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lbHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lb", externalID)
}

type Aws_api_gateway_usage_plan_key struct {
     Aws_api_gateway_usage_plan_key_id *string
     Key_id string
     Key_type string
     Usage_plan_id string
     Name *string
     Value *string
}


func Aws_api_gateway_usage_plan_keyMapper(r *Aws_api_gateway_usage_plan_key) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["key_id"] = r.Key_id
    config["key_type"] = r.Key_type
    config["usage_plan_id"] = r.Usage_plan_id
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Value != nil {
    config["value"] = *r.Value
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_usage_plan_keyUnmapper(state map[string]interface{}) *Aws_api_gateway_usage_plan_key {
	r := &Aws_api_gateway_usage_plan_key{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_usage_plan_key_id = &x
}

if x, ok := state["key_id"]; ok {
	r.Key_id = x.(string)
}

if x, ok := state["key_type"]; ok {
	r.Key_type = x.(string)
}

if x, ok := state["usage_plan_id"]; ok {
	r.Usage_plan_id = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["value"]; ok {
	x := x.(string)
	r.Value = &x
}
	return r
}


// Aws_api_gateway_usage_plan_keyHandler ...
type Aws_api_gateway_usage_plan_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_usage_plan_keyHandler) Create(desired *Aws_api_gateway_usage_plan_key) (*Aws_api_gateway_usage_plan_key, string, error) {
	rState := Aws_api_gateway_usage_plan_keyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_usage_plan_key", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_usage_plan_keyHandler) Read(externalID string) (*Aws_api_gateway_usage_plan_key, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_usage_plan_key", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_usage_plan_keyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_usage_plan_keyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_usage_plan_key", externalID)
}

type Aws_codebuild_webhook struct {
     Aws_codebuild_webhook_id *string
     Project_name string
     Branch_filter *string
     Payload_url *string
     Secret *string
     Url *string
}


func Aws_codebuild_webhookMapper(r *Aws_codebuild_webhook) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Secret != nil {
    config["secret"] = *r.Secret
}
if r.Url != nil {
    config["url"] = *r.Url
}
    config["project_name"] = r.Project_name
if r.Branch_filter != nil {
    config["branch_filter"] = *r.Branch_filter
}
if r.Payload_url != nil {
    config["payload_url"] = *r.Payload_url
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_codebuild_webhookUnmapper(state map[string]interface{}) *Aws_codebuild_webhook {
	r := &Aws_codebuild_webhook{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_codebuild_webhook_id = &x
}

if x, ok := state["project_name"]; ok {
	r.Project_name = x.(string)
}

if x, ok := state["branch_filter"]; ok {
	x := x.(string)
	r.Branch_filter = &x
}

if x, ok := state["payload_url"]; ok {
	x := x.(string)
	r.Payload_url = &x
}

if x, ok := state["secret"]; ok {
	x := x.(string)
	r.Secret = &x
}

if x, ok := state["url"]; ok {
	x := x.(string)
	r.Url = &x
}
	return r
}


// Aws_codebuild_webhookHandler ...
type Aws_codebuild_webhookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_codebuild_webhookHandler) Create(desired *Aws_codebuild_webhook) (*Aws_codebuild_webhook, string, error) {
	rState := Aws_codebuild_webhookMapper(desired)
	id, err := bridge.Create(h.provider, "aws_codebuild_webhook", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_codebuild_webhookHandler) Read(externalID string) (*Aws_codebuild_webhook, error) {
	actual, err := bridge.Read(h.provider, "aws_codebuild_webhook", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_codebuild_webhookUnmapper(actual), nil
}

// Delete ...
func (h *Aws_codebuild_webhookHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_codebuild_webhook", externalID)
}

type Aws_ssm_resource_data_sync struct {
     Aws_ssm_resource_data_sync_id *string
     Name string
}


func Aws_ssm_resource_data_syncMapper(r *Aws_ssm_resource_data_sync) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_resource_data_syncUnmapper(state map[string]interface{}) *Aws_ssm_resource_data_sync {
	r := &Aws_ssm_resource_data_sync{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_resource_data_sync_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_ssm_resource_data_syncHandler ...
type Aws_ssm_resource_data_syncHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_resource_data_syncHandler) Create(desired *Aws_ssm_resource_data_sync) (*Aws_ssm_resource_data_sync, string, error) {
	rState := Aws_ssm_resource_data_syncMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_resource_data_sync", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_resource_data_syncHandler) Read(externalID string) (*Aws_ssm_resource_data_sync, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_resource_data_sync", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_resource_data_syncUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_resource_data_syncHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_resource_data_sync", externalID)
}

type Aws_vpc_dhcp_options_association struct {
     Aws_vpc_dhcp_options_association_id *string
     Vpc_id string
     Dhcp_options_id string
}


func Aws_vpc_dhcp_options_associationMapper(r *Aws_vpc_dhcp_options_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_id"] = r.Vpc_id
    config["dhcp_options_id"] = r.Dhcp_options_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_dhcp_options_associationUnmapper(state map[string]interface{}) *Aws_vpc_dhcp_options_association {
	r := &Aws_vpc_dhcp_options_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_dhcp_options_association_id = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["dhcp_options_id"]; ok {
	r.Dhcp_options_id = x.(string)
}
	return r
}


// Aws_vpc_dhcp_options_associationHandler ...
type Aws_vpc_dhcp_options_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_dhcp_options_associationHandler) Create(desired *Aws_vpc_dhcp_options_association) (*Aws_vpc_dhcp_options_association, string, error) {
	rState := Aws_vpc_dhcp_options_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_dhcp_options_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_dhcp_options_associationHandler) Read(externalID string) (*Aws_vpc_dhcp_options_association, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_dhcp_options_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_dhcp_options_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_dhcp_options_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_dhcp_options_association", externalID)
}

type Aws_efs_file_system struct {
     Aws_efs_file_system_id *string
     Kms_key_id *string
     Tags *map[string]string
     Reference_name *string
     Creation_token *string
     Performance_mode *string
     Encrypted *bool
     Dns_name *string
     Throughput_mode *string
     Arn *string
}


func Aws_efs_file_systemMapper(r *Aws_efs_file_system) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Reference_name != nil {
    config["reference_name"] = *r.Reference_name
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Performance_mode != nil {
    config["performance_mode"] = *r.Performance_mode
}
if r.Encrypted != nil {
    config["encrypted"] = *r.Encrypted
}
if r.Dns_name != nil {
    config["dns_name"] = *r.Dns_name
}
if r.Throughput_mode != nil {
    config["throughput_mode"] = *r.Throughput_mode
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Creation_token != nil {
    config["creation_token"] = *r.Creation_token
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_efs_file_systemUnmapper(state map[string]interface{}) *Aws_efs_file_system {
	r := &Aws_efs_file_system{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_efs_file_system_id = &x
}

if x, ok := state["reference_name"]; ok {
	x := x.(string)
	r.Reference_name = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["throughput_mode"]; ok {
	x := x.(string)
	r.Throughput_mode = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["creation_token"]; ok {
	x := x.(string)
	r.Creation_token = &x
}

if x, ok := state["performance_mode"]; ok {
	x := x.(string)
	r.Performance_mode = &x
}

if x, ok := state["encrypted"]; ok {
	x := x.(bool)
	r.Encrypted = &x
}

if x, ok := state["dns_name"]; ok {
	x := x.(string)
	r.Dns_name = &x
}
	return r
}


// Aws_efs_file_systemHandler ...
type Aws_efs_file_systemHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_efs_file_systemHandler) Create(desired *Aws_efs_file_system) (*Aws_efs_file_system, string, error) {
	rState := Aws_efs_file_systemMapper(desired)
	id, err := bridge.Create(h.provider, "aws_efs_file_system", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_efs_file_systemHandler) Read(externalID string) (*Aws_efs_file_system, error) {
	actual, err := bridge.Read(h.provider, "aws_efs_file_system", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_efs_file_systemUnmapper(actual), nil
}

// Delete ...
func (h *Aws_efs_file_systemHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_efs_file_system", externalID)
}

type Aws_iam_server_certificate struct {
     Aws_iam_server_certificate_id *string
     Private_key string
     Name *string
     Name_prefix *string
     Arn *string
     Certificate_body string
     Certificate_chain *string
     Path *string
}


func Aws_iam_server_certificateMapper(r *Aws_iam_server_certificate) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["certificate_body"] = r.Certificate_body
if r.Certificate_chain != nil {
    config["certificate_chain"] = *r.Certificate_chain
}
if r.Path != nil {
    config["path"] = *r.Path
}
    config["private_key"] = r.Private_key
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_server_certificateUnmapper(state map[string]interface{}) *Aws_iam_server_certificate {
	r := &Aws_iam_server_certificate{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_server_certificate_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["certificate_body"]; ok {
	r.Certificate_body = x.(string)
}

if x, ok := state["certificate_chain"]; ok {
	x := x.(string)
	r.Certificate_chain = &x
}

if x, ok := state["path"]; ok {
	x := x.(string)
	r.Path = &x
}

if x, ok := state["private_key"]; ok {
	r.Private_key = x.(string)
}
	return r
}


// Aws_iam_server_certificateHandler ...
type Aws_iam_server_certificateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_server_certificateHandler) Create(desired *Aws_iam_server_certificate) (*Aws_iam_server_certificate, string, error) {
	rState := Aws_iam_server_certificateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_server_certificate", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_server_certificateHandler) Read(externalID string) (*Aws_iam_server_certificate, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_server_certificate", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_server_certificateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_server_certificateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_server_certificate", externalID)
}

type Aws_iam_policy struct {
     Aws_iam_policy_id *string
     Description *string
     Path *string
     Policy string
     Name *string
     Name_prefix *string
     Arn *string
}


func Aws_iam_policyMapper(r *Aws_iam_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Path != nil {
    config["path"] = *r.Path
}
    config["policy"] = r.Policy
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_policyUnmapper(state map[string]interface{}) *Aws_iam_policy {
	r := &Aws_iam_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_policy_id = &x
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["path"]; ok {
	x := x.(string)
	r.Path = &x
}
	return r
}


// Aws_iam_policyHandler ...
type Aws_iam_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_policyHandler) Create(desired *Aws_iam_policy) (*Aws_iam_policy, string, error) {
	rState := Aws_iam_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_policyHandler) Read(externalID string) (*Aws_iam_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_policy", externalID)
}

type Aws_secretsmanager_secret_version struct {
     Aws_secretsmanager_secret_version_id *string
     Version_id *string
     Arn *string
     Secret_id string
     Secret_string *string
     Secret_binary *string
}


func Aws_secretsmanager_secret_versionMapper(r *Aws_secretsmanager_secret_version) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["secret_id"] = r.Secret_id
if r.Secret_string != nil {
    config["secret_string"] = *r.Secret_string
}
if r.Secret_binary != nil {
    config["secret_binary"] = *r.Secret_binary
}
if r.Version_id != nil {
    config["version_id"] = *r.Version_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_secretsmanager_secret_versionUnmapper(state map[string]interface{}) *Aws_secretsmanager_secret_version {
	r := &Aws_secretsmanager_secret_version{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_secretsmanager_secret_version_id = &x
}

if x, ok := state["secret_string"]; ok {
	x := x.(string)
	r.Secret_string = &x
}

if x, ok := state["secret_binary"]; ok {
	x := x.(string)
	r.Secret_binary = &x
}

if x, ok := state["version_id"]; ok {
	x := x.(string)
	r.Version_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["secret_id"]; ok {
	r.Secret_id = x.(string)
}
	return r
}


// Aws_secretsmanager_secret_versionHandler ...
type Aws_secretsmanager_secret_versionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_secretsmanager_secret_versionHandler) Create(desired *Aws_secretsmanager_secret_version) (*Aws_secretsmanager_secret_version, string, error) {
	rState := Aws_secretsmanager_secret_versionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_secretsmanager_secret_version", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_secretsmanager_secret_versionHandler) Read(externalID string) (*Aws_secretsmanager_secret_version, error) {
	actual, err := bridge.Read(h.provider, "aws_secretsmanager_secret_version", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_secretsmanager_secret_versionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_secretsmanager_secret_versionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_secretsmanager_secret_version", externalID)
}

type Aws_cloudwatch_log_destination struct {
     Aws_cloudwatch_log_destination_id *string
     Name string
     Role_arn string
     Target_arn string
     Arn *string
}


func Aws_cloudwatch_log_destinationMapper(r *Aws_cloudwatch_log_destination) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["target_arn"] = r.Target_arn
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
    config["role_arn"] = r.Role_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_log_destinationUnmapper(state map[string]interface{}) *Aws_cloudwatch_log_destination {
	r := &Aws_cloudwatch_log_destination{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_log_destination_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}

if x, ok := state["target_arn"]; ok {
	r.Target_arn = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_cloudwatch_log_destinationHandler ...
type Aws_cloudwatch_log_destinationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_log_destinationHandler) Create(desired *Aws_cloudwatch_log_destination) (*Aws_cloudwatch_log_destination, string, error) {
	rState := Aws_cloudwatch_log_destinationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_log_destination", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_log_destinationHandler) Read(externalID string) (*Aws_cloudwatch_log_destination, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_log_destination", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_log_destinationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_log_destinationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_log_destination", externalID)
}

type Aws_globalaccelerator_accelerator struct {
     Aws_globalaccelerator_accelerator_id *string
     Name string
     Ip_address_type *string
     Enabled *bool
}


func Aws_globalaccelerator_acceleratorMapper(r *Aws_globalaccelerator_accelerator) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Ip_address_type != nil {
    config["ip_address_type"] = *r.Ip_address_type
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_globalaccelerator_acceleratorUnmapper(state map[string]interface{}) *Aws_globalaccelerator_accelerator {
	r := &Aws_globalaccelerator_accelerator{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_globalaccelerator_accelerator_id = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["ip_address_type"]; ok {
	x := x.(string)
	r.Ip_address_type = &x
}
	return r
}


// Aws_globalaccelerator_acceleratorHandler ...
type Aws_globalaccelerator_acceleratorHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_globalaccelerator_acceleratorHandler) Create(desired *Aws_globalaccelerator_accelerator) (*Aws_globalaccelerator_accelerator, string, error) {
	rState := Aws_globalaccelerator_acceleratorMapper(desired)
	id, err := bridge.Create(h.provider, "aws_globalaccelerator_accelerator", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_globalaccelerator_acceleratorHandler) Read(externalID string) (*Aws_globalaccelerator_accelerator, error) {
	actual, err := bridge.Read(h.provider, "aws_globalaccelerator_accelerator", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_globalaccelerator_acceleratorUnmapper(actual), nil
}

// Delete ...
func (h *Aws_globalaccelerator_acceleratorHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_globalaccelerator_accelerator", externalID)
}

type Aws_waf_ipset struct {
     Aws_waf_ipset_id *string
     Name string
     Arn *string
}


func Aws_waf_ipsetMapper(r *Aws_waf_ipset) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_ipsetUnmapper(state map[string]interface{}) *Aws_waf_ipset {
	r := &Aws_waf_ipset{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_ipset_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_waf_ipsetHandler ...
type Aws_waf_ipsetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_ipsetHandler) Create(desired *Aws_waf_ipset) (*Aws_waf_ipset, string, error) {
	rState := Aws_waf_ipsetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_ipset", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_ipsetHandler) Read(externalID string) (*Aws_waf_ipset, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_ipset", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_ipsetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_ipsetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_ipset", externalID)
}

type Aws_route53_zone_association struct {
     Aws_route53_zone_association_id *string
     Zone_id string
     Vpc_id string
     Vpc_region *string
}


func Aws_route53_zone_associationMapper(r *Aws_route53_zone_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["zone_id"] = r.Zone_id
    config["vpc_id"] = r.Vpc_id
if r.Vpc_region != nil {
    config["vpc_region"] = *r.Vpc_region
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_route53_zone_associationUnmapper(state map[string]interface{}) *Aws_route53_zone_association {
	r := &Aws_route53_zone_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_route53_zone_association_id = &x
}

if x, ok := state["zone_id"]; ok {
	r.Zone_id = x.(string)
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["vpc_region"]; ok {
	x := x.(string)
	r.Vpc_region = &x
}
	return r
}


// Aws_route53_zone_associationHandler ...
type Aws_route53_zone_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_route53_zone_associationHandler) Create(desired *Aws_route53_zone_association) (*Aws_route53_zone_association, string, error) {
	rState := Aws_route53_zone_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_route53_zone_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_route53_zone_associationHandler) Read(externalID string) (*Aws_route53_zone_association, error) {
	actual, err := bridge.Read(h.provider, "aws_route53_zone_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_route53_zone_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_route53_zone_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_route53_zone_association", externalID)
}

type Aws_securityhub_account struct {
     Aws_securityhub_account_id *string
}


func Aws_securityhub_accountMapper(r *Aws_securityhub_account) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_securityhub_accountUnmapper(state map[string]interface{}) *Aws_securityhub_account {
	r := &Aws_securityhub_account{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_securityhub_account_id = &x
}
	return r
}


// Aws_securityhub_accountHandler ...
type Aws_securityhub_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_securityhub_accountHandler) Create(desired *Aws_securityhub_account) (*Aws_securityhub_account, string, error) {
	rState := Aws_securityhub_accountMapper(desired)
	id, err := bridge.Create(h.provider, "aws_securityhub_account", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_securityhub_accountHandler) Read(externalID string) (*Aws_securityhub_account, error) {
	actual, err := bridge.Read(h.provider, "aws_securityhub_account", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_securityhub_accountUnmapper(actual), nil
}

// Delete ...
func (h *Aws_securityhub_accountHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_securityhub_account", externalID)
}

type Aws_load_balancer_listener_policy struct {
     Aws_load_balancer_listener_policy_id *string
     Load_balancer_name string
}


func Aws_load_balancer_listener_policyMapper(r *Aws_load_balancer_listener_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["load_balancer_name"] = r.Load_balancer_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_load_balancer_listener_policyUnmapper(state map[string]interface{}) *Aws_load_balancer_listener_policy {
	r := &Aws_load_balancer_listener_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_load_balancer_listener_policy_id = &x
}

if x, ok := state["load_balancer_name"]; ok {
	r.Load_balancer_name = x.(string)
}
	return r
}


// Aws_load_balancer_listener_policyHandler ...
type Aws_load_balancer_listener_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_load_balancer_listener_policyHandler) Create(desired *Aws_load_balancer_listener_policy) (*Aws_load_balancer_listener_policy, string, error) {
	rState := Aws_load_balancer_listener_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_load_balancer_listener_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_load_balancer_listener_policyHandler) Read(externalID string) (*Aws_load_balancer_listener_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_load_balancer_listener_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_load_balancer_listener_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_load_balancer_listener_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_load_balancer_listener_policy", externalID)
}

type Aws_vpc_peering_connection struct {
     Aws_vpc_peering_connection_id *string
     Peer_owner_id *string
     Auto_accept *bool
     Peer_region *string
     Peer_vpc_id string
     Vpc_id string
     Accept_status *string
     Tags *map[string]string
}


func Aws_vpc_peering_connectionMapper(r *Aws_vpc_peering_connection) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["peer_vpc_id"] = r.Peer_vpc_id
    config["vpc_id"] = r.Vpc_id
if r.Accept_status != nil {
    config["accept_status"] = *r.Accept_status
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Peer_owner_id != nil {
    config["peer_owner_id"] = *r.Peer_owner_id
}
if r.Auto_accept != nil {
    config["auto_accept"] = *r.Auto_accept
}
if r.Peer_region != nil {
    config["peer_region"] = *r.Peer_region
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_peering_connectionUnmapper(state map[string]interface{}) *Aws_vpc_peering_connection {
	r := &Aws_vpc_peering_connection{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_peering_connection_id = &x
}

if x, ok := state["peer_vpc_id"]; ok {
	r.Peer_vpc_id = x.(string)
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["accept_status"]; ok {
	x := x.(string)
	r.Accept_status = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["peer_owner_id"]; ok {
	x := x.(string)
	r.Peer_owner_id = &x
}

if x, ok := state["auto_accept"]; ok {
	x := x.(bool)
	r.Auto_accept = &x
}

if x, ok := state["peer_region"]; ok {
	x := x.(string)
	r.Peer_region = &x
}
	return r
}


// Aws_vpc_peering_connectionHandler ...
type Aws_vpc_peering_connectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_peering_connectionHandler) Create(desired *Aws_vpc_peering_connection) (*Aws_vpc_peering_connection, string, error) {
	rState := Aws_vpc_peering_connectionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_peering_connection", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_peering_connectionHandler) Read(externalID string) (*Aws_vpc_peering_connection, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_peering_connection", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_peering_connectionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_peering_connectionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_peering_connection", externalID)
}

type Aws_pinpoint_event_stream struct {
     Aws_pinpoint_event_stream_id *string
     Role_arn string
     Application_id string
     Destination_stream_arn string
}


func Aws_pinpoint_event_streamMapper(r *Aws_pinpoint_event_stream) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["application_id"] = r.Application_id
    config["destination_stream_arn"] = r.Destination_stream_arn
    config["role_arn"] = r.Role_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_event_streamUnmapper(state map[string]interface{}) *Aws_pinpoint_event_stream {
	r := &Aws_pinpoint_event_stream{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_event_stream_id = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["destination_stream_arn"]; ok {
	r.Destination_stream_arn = x.(string)
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}
	return r
}


// Aws_pinpoint_event_streamHandler ...
type Aws_pinpoint_event_streamHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_event_streamHandler) Create(desired *Aws_pinpoint_event_stream) (*Aws_pinpoint_event_stream, string, error) {
	rState := Aws_pinpoint_event_streamMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_event_stream", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_event_streamHandler) Read(externalID string) (*Aws_pinpoint_event_stream, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_event_stream", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_event_streamUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_event_streamHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_event_stream", externalID)
}

type Aws_cloudfront_distribution struct {
     Aws_cloudfront_distribution_id *string
     Http_version *string
     Caller_reference *string
     Arn *string
     Comment *string
     Default_root_object *string
     Enabled bool
     Price_class *string
     Etag *string
     Tags *map[string]string
     Status *string
     Active_trusted_signers *map[string]string
     Is_ipv6_enabled *bool
     Last_modified_time *string
     Web_acl_id *string
     Domain_name *string
     Hosted_zone_id *string
     Retain_on_delete *bool
}


func Aws_cloudfront_distributionMapper(r *Aws_cloudfront_distribution) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Default_root_object != nil {
    config["default_root_object"] = *r.Default_root_object
}
    config["enabled"] = r.Enabled
if r.Price_class != nil {
    config["price_class"] = *r.Price_class
}
if r.Etag != nil {
    config["etag"] = *r.Etag
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Active_trusted_signers != nil {
    config["active_trusted_signers"] = *r.Active_trusted_signers
}
if r.Is_ipv6_enabled != nil {
    config["is_ipv6_enabled"] = *r.Is_ipv6_enabled
}
if r.Last_modified_time != nil {
    config["last_modified_time"] = *r.Last_modified_time
}
if r.Web_acl_id != nil {
    config["web_acl_id"] = *r.Web_acl_id
}
if r.Domain_name != nil {
    config["domain_name"] = *r.Domain_name
}
if r.Hosted_zone_id != nil {
    config["hosted_zone_id"] = *r.Hosted_zone_id
}
if r.Retain_on_delete != nil {
    config["retain_on_delete"] = *r.Retain_on_delete
}
if r.Http_version != nil {
    config["http_version"] = *r.Http_version
}
if r.Caller_reference != nil {
    config["caller_reference"] = *r.Caller_reference
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Comment != nil {
    config["comment"] = *r.Comment
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudfront_distributionUnmapper(state map[string]interface{}) *Aws_cloudfront_distribution {
	r := &Aws_cloudfront_distribution{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudfront_distribution_id = &x
}

if x, ok := state["comment"]; ok {
	x := x.(string)
	r.Comment = &x
}

if x, ok := state["http_version"]; ok {
	x := x.(string)
	r.Http_version = &x
}

if x, ok := state["caller_reference"]; ok {
	x := x.(string)
	r.Caller_reference = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["enabled"]; ok {
	r.Enabled = x.(bool)
}

if x, ok := state["price_class"]; ok {
	x := x.(string)
	r.Price_class = &x
}

if x, ok := state["default_root_object"]; ok {
	x := x.(string)
	r.Default_root_object = &x
}

if x, ok := state["etag"]; ok {
	x := x.(string)
	r.Etag = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["is_ipv6_enabled"]; ok {
	x := x.(bool)
	r.Is_ipv6_enabled = &x
}

if x, ok := state["active_trusted_signers"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Active_trusted_signers = &x
}

if x, ok := state["last_modified_time"]; ok {
	x := x.(string)
	r.Last_modified_time = &x
}

if x, ok := state["domain_name"]; ok {
	x := x.(string)
	r.Domain_name = &x
}

if x, ok := state["web_acl_id"]; ok {
	x := x.(string)
	r.Web_acl_id = &x
}

if x, ok := state["hosted_zone_id"]; ok {
	x := x.(string)
	r.Hosted_zone_id = &x
}

if x, ok := state["retain_on_delete"]; ok {
	x := x.(bool)
	r.Retain_on_delete = &x
}
	return r
}


// Aws_cloudfront_distributionHandler ...
type Aws_cloudfront_distributionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudfront_distributionHandler) Create(desired *Aws_cloudfront_distribution) (*Aws_cloudfront_distribution, string, error) {
	rState := Aws_cloudfront_distributionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudfront_distribution", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudfront_distributionHandler) Read(externalID string) (*Aws_cloudfront_distribution, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudfront_distribution", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudfront_distributionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudfront_distributionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudfront_distribution", externalID)
}

type Aws_inspector_assessment_template struct {
     Aws_inspector_assessment_template_id *string
     Name string
     Target_arn string
     Arn *string
}


func Aws_inspector_assessment_templateMapper(r *Aws_inspector_assessment_template) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
    config["target_arn"] = r.Target_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_inspector_assessment_templateUnmapper(state map[string]interface{}) *Aws_inspector_assessment_template {
	r := &Aws_inspector_assessment_template{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_inspector_assessment_template_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["target_arn"]; ok {
	r.Target_arn = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_inspector_assessment_templateHandler ...
type Aws_inspector_assessment_templateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_inspector_assessment_templateHandler) Create(desired *Aws_inspector_assessment_template) (*Aws_inspector_assessment_template, string, error) {
	rState := Aws_inspector_assessment_templateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_inspector_assessment_template", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_inspector_assessment_templateHandler) Read(externalID string) (*Aws_inspector_assessment_template, error) {
	actual, err := bridge.Read(h.provider, "aws_inspector_assessment_template", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_inspector_assessment_templateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_inspector_assessment_templateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_inspector_assessment_template", externalID)
}

type Aws_storagegateway_nfs_file_share struct {
     Aws_storagegateway_nfs_file_share_id *string
     Location_arn string
     Object_acl *string
     Arn *string
     Gateway_arn string
     Guess_mime_type_enabled *bool
     Kms_encrypted *bool
     Default_storage_class *string
     Read_only *bool
     Squash *string
     Fileshare_id *string
     Kms_key_arn *string
     Requester_pays *bool
     Role_arn string
}


func Aws_storagegateway_nfs_file_shareMapper(r *Aws_storagegateway_nfs_file_share) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["location_arn"] = r.Location_arn
if r.Object_acl != nil {
    config["object_acl"] = *r.Object_acl
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["gateway_arn"] = r.Gateway_arn
if r.Guess_mime_type_enabled != nil {
    config["guess_mime_type_enabled"] = *r.Guess_mime_type_enabled
}
if r.Kms_encrypted != nil {
    config["kms_encrypted"] = *r.Kms_encrypted
}
if r.Default_storage_class != nil {
    config["default_storage_class"] = *r.Default_storage_class
}
if r.Read_only != nil {
    config["read_only"] = *r.Read_only
}
if r.Squash != nil {
    config["squash"] = *r.Squash
}
if r.Fileshare_id != nil {
    config["fileshare_id"] = *r.Fileshare_id
}
if r.Kms_key_arn != nil {
    config["kms_key_arn"] = *r.Kms_key_arn
}
if r.Requester_pays != nil {
    config["requester_pays"] = *r.Requester_pays
}
    config["role_arn"] = r.Role_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_storagegateway_nfs_file_shareUnmapper(state map[string]interface{}) *Aws_storagegateway_nfs_file_share {
	r := &Aws_storagegateway_nfs_file_share{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_storagegateway_nfs_file_share_id = &x
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}

if x, ok := state["fileshare_id"]; ok {
	x := x.(string)
	r.Fileshare_id = &x
}

if x, ok := state["kms_key_arn"]; ok {
	x := x.(string)
	r.Kms_key_arn = &x
}

if x, ok := state["requester_pays"]; ok {
	x := x.(bool)
	r.Requester_pays = &x
}

if x, ok := state["location_arn"]; ok {
	r.Location_arn = x.(string)
}

if x, ok := state["guess_mime_type_enabled"]; ok {
	x := x.(bool)
	r.Guess_mime_type_enabled = &x
}

if x, ok := state["kms_encrypted"]; ok {
	x := x.(bool)
	r.Kms_encrypted = &x
}

if x, ok := state["object_acl"]; ok {
	x := x.(string)
	r.Object_acl = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["gateway_arn"]; ok {
	r.Gateway_arn = x.(string)
}

if x, ok := state["default_storage_class"]; ok {
	x := x.(string)
	r.Default_storage_class = &x
}

if x, ok := state["read_only"]; ok {
	x := x.(bool)
	r.Read_only = &x
}

if x, ok := state["squash"]; ok {
	x := x.(string)
	r.Squash = &x
}
	return r
}


// Aws_storagegateway_nfs_file_shareHandler ...
type Aws_storagegateway_nfs_file_shareHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_storagegateway_nfs_file_shareHandler) Create(desired *Aws_storagegateway_nfs_file_share) (*Aws_storagegateway_nfs_file_share, string, error) {
	rState := Aws_storagegateway_nfs_file_shareMapper(desired)
	id, err := bridge.Create(h.provider, "aws_storagegateway_nfs_file_share", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_storagegateway_nfs_file_shareHandler) Read(externalID string) (*Aws_storagegateway_nfs_file_share, error) {
	actual, err := bridge.Read(h.provider, "aws_storagegateway_nfs_file_share", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_storagegateway_nfs_file_shareUnmapper(actual), nil
}

// Delete ...
func (h *Aws_storagegateway_nfs_file_shareHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_storagegateway_nfs_file_share", externalID)
}

type Aws_waf_rate_based_rule struct {
     Aws_waf_rate_based_rule_id *string
     Name string
     Metric_name string
     Rate_key string
}


func Aws_waf_rate_based_ruleMapper(r *Aws_waf_rate_based_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["metric_name"] = r.Metric_name
    config["rate_key"] = r.Rate_key
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_rate_based_ruleUnmapper(state map[string]interface{}) *Aws_waf_rate_based_rule {
	r := &Aws_waf_rate_based_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_rate_based_rule_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["metric_name"]; ok {
	r.Metric_name = x.(string)
}

if x, ok := state["rate_key"]; ok {
	r.Rate_key = x.(string)
}
	return r
}


// Aws_waf_rate_based_ruleHandler ...
type Aws_waf_rate_based_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_rate_based_ruleHandler) Create(desired *Aws_waf_rate_based_rule) (*Aws_waf_rate_based_rule, string, error) {
	rState := Aws_waf_rate_based_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_rate_based_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_rate_based_ruleHandler) Read(externalID string) (*Aws_waf_rate_based_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_rate_based_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_rate_based_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_rate_based_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_rate_based_rule", externalID)
}

type Aws_glue_connection struct {
     Aws_glue_connection_id *string
     Connection_properties map[string]string
     Connection_type *string
     Description *string
     Name string
     Catalog_id *string
}


func Aws_glue_connectionMapper(r *Aws_glue_connection) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Catalog_id != nil {
    config["catalog_id"] = *r.Catalog_id
}
    config["connection_properties"] = r.Connection_properties
if r.Connection_type != nil {
    config["connection_type"] = *r.Connection_type
}
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glue_connectionUnmapper(state map[string]interface{}) *Aws_glue_connection {
	r := &Aws_glue_connection{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glue_connection_id = &x
}

if x, ok := state["catalog_id"]; ok {
	x := x.(string)
	r.Catalog_id = &x
}

if x, ok := state["connection_properties"]; ok {
	r.Connection_properties = x.(map[string]string)
}

if x, ok := state["connection_type"]; ok {
	x := x.(string)
	r.Connection_type = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_glue_connectionHandler ...
type Aws_glue_connectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glue_connectionHandler) Create(desired *Aws_glue_connection) (*Aws_glue_connection, string, error) {
	rState := Aws_glue_connectionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glue_connection", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glue_connectionHandler) Read(externalID string) (*Aws_glue_connection, error) {
	actual, err := bridge.Read(h.provider, "aws_glue_connection", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glue_connectionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glue_connectionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glue_connection", externalID)
}

type Aws_guardduty_threatintelset struct {
     Aws_guardduty_threatintelset_id *string
     Detector_id string
     Name string
     Format string
     Location string
     Activate bool
}


func Aws_guardduty_threatintelsetMapper(r *Aws_guardduty_threatintelset) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["format"] = r.Format
    config["location"] = r.Location
    config["activate"] = r.Activate
    config["detector_id"] = r.Detector_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_guardduty_threatintelsetUnmapper(state map[string]interface{}) *Aws_guardduty_threatintelset {
	r := &Aws_guardduty_threatintelset{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_guardduty_threatintelset_id = &x
}

if x, ok := state["detector_id"]; ok {
	r.Detector_id = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["format"]; ok {
	r.Format = x.(string)
}

if x, ok := state["location"]; ok {
	r.Location = x.(string)
}

if x, ok := state["activate"]; ok {
	r.Activate = x.(bool)
}
	return r
}


// Aws_guardduty_threatintelsetHandler ...
type Aws_guardduty_threatintelsetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_guardduty_threatintelsetHandler) Create(desired *Aws_guardduty_threatintelset) (*Aws_guardduty_threatintelset, string, error) {
	rState := Aws_guardduty_threatintelsetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_guardduty_threatintelset", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_guardduty_threatintelsetHandler) Read(externalID string) (*Aws_guardduty_threatintelset, error) {
	actual, err := bridge.Read(h.provider, "aws_guardduty_threatintelset", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_guardduty_threatintelsetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_guardduty_threatintelsetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_guardduty_threatintelset", externalID)
}

type Aws_elasticache_replication_group struct {
     Aws_elasticache_replication_group_id *string
     Node_type *string
     Configuration_endpoint_address *string
     Auto_minor_version_upgrade *bool
     Automatic_failover_enabled *bool
     Maintenance_window *string
     Snapshot_window *string
     Primary_endpoint_address *string
     Replication_group_id string
     Engine_version *string
     Subnet_group_name *string
     At_rest_encryption_enabled *bool
     Auth_token *string
     Parameter_group_name *string
     Snapshot_name *string
     Transit_encryption_enabled *bool
     Notification_topic_arn *string
     Replication_group_description string
     Tags *map[string]string
     Apply_immediately *bool
     Engine *string
}


func Aws_elasticache_replication_groupMapper(r *Aws_elasticache_replication_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Configuration_endpoint_address != nil {
    config["configuration_endpoint_address"] = *r.Configuration_endpoint_address
}
if r.Auto_minor_version_upgrade != nil {
    config["auto_minor_version_upgrade"] = *r.Auto_minor_version_upgrade
}
if r.Automatic_failover_enabled != nil {
    config["automatic_failover_enabled"] = *r.Automatic_failover_enabled
}
if r.Maintenance_window != nil {
    config["maintenance_window"] = *r.Maintenance_window
}
if r.Snapshot_window != nil {
    config["snapshot_window"] = *r.Snapshot_window
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Primary_endpoint_address != nil {
    config["primary_endpoint_address"] = *r.Primary_endpoint_address
}
    config["replication_group_id"] = r.Replication_group_id
if r.At_rest_encryption_enabled != nil {
    config["at_rest_encryption_enabled"] = *r.At_rest_encryption_enabled
}
if r.Auth_token != nil {
    config["auth_token"] = *r.Auth_token
}
if r.Parameter_group_name != nil {
    config["parameter_group_name"] = *r.Parameter_group_name
}
if r.Subnet_group_name != nil {
    config["subnet_group_name"] = *r.Subnet_group_name
}
if r.Notification_topic_arn != nil {
    config["notification_topic_arn"] = *r.Notification_topic_arn
}
    config["replication_group_description"] = r.Replication_group_description
if r.Snapshot_name != nil {
    config["snapshot_name"] = *r.Snapshot_name
}
if r.Transit_encryption_enabled != nil {
    config["transit_encryption_enabled"] = *r.Transit_encryption_enabled
}
if r.Apply_immediately != nil {
    config["apply_immediately"] = *r.Apply_immediately
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Node_type != nil {
    config["node_type"] = *r.Node_type
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elasticache_replication_groupUnmapper(state map[string]interface{}) *Aws_elasticache_replication_group {
	r := &Aws_elasticache_replication_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elasticache_replication_group_id = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["primary_endpoint_address"]; ok {
	x := x.(string)
	r.Primary_endpoint_address = &x
}

if x, ok := state["replication_group_id"]; ok {
	r.Replication_group_id = x.(string)
}

if x, ok := state["auth_token"]; ok {
	x := x.(string)
	r.Auth_token = &x
}

if x, ok := state["parameter_group_name"]; ok {
	x := x.(string)
	r.Parameter_group_name = &x
}

if x, ok := state["subnet_group_name"]; ok {
	x := x.(string)
	r.Subnet_group_name = &x
}

if x, ok := state["at_rest_encryption_enabled"]; ok {
	x := x.(bool)
	r.At_rest_encryption_enabled = &x
}

if x, ok := state["notification_topic_arn"]; ok {
	x := x.(string)
	r.Notification_topic_arn = &x
}

if x, ok := state["replication_group_description"]; ok {
	r.Replication_group_description = x.(string)
}

if x, ok := state["snapshot_name"]; ok {
	x := x.(string)
	r.Snapshot_name = &x
}

if x, ok := state["transit_encryption_enabled"]; ok {
	x := x.(bool)
	r.Transit_encryption_enabled = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["apply_immediately"]; ok {
	x := x.(bool)
	r.Apply_immediately = &x
}

if x, ok := state["node_type"]; ok {
	x := x.(string)
	r.Node_type = &x
}

if x, ok := state["configuration_endpoint_address"]; ok {
	x := x.(string)
	r.Configuration_endpoint_address = &x
}

if x, ok := state["automatic_failover_enabled"]; ok {
	x := x.(bool)
	r.Automatic_failover_enabled = &x
}

if x, ok := state["auto_minor_version_upgrade"]; ok {
	x := x.(bool)
	r.Auto_minor_version_upgrade = &x
}

if x, ok := state["snapshot_window"]; ok {
	x := x.(string)
	r.Snapshot_window = &x
}

if x, ok := state["maintenance_window"]; ok {
	x := x.(string)
	r.Maintenance_window = &x
}
	return r
}


// Aws_elasticache_replication_groupHandler ...
type Aws_elasticache_replication_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elasticache_replication_groupHandler) Create(desired *Aws_elasticache_replication_group) (*Aws_elasticache_replication_group, string, error) {
	rState := Aws_elasticache_replication_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elasticache_replication_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elasticache_replication_groupHandler) Read(externalID string) (*Aws_elasticache_replication_group, error) {
	actual, err := bridge.Read(h.provider, "aws_elasticache_replication_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elasticache_replication_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elasticache_replication_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elasticache_replication_group", externalID)
}

type Aws_sns_topic_policy struct {
     Aws_sns_topic_policy_id *string
     Arn string
     Policy string
}


func Aws_sns_topic_policyMapper(r *Aws_sns_topic_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["arn"] = r.Arn
    config["policy"] = r.Policy
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sns_topic_policyUnmapper(state map[string]interface{}) *Aws_sns_topic_policy {
	r := &Aws_sns_topic_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sns_topic_policy_id = &x
}

if x, ok := state["arn"]; ok {
	r.Arn = x.(string)
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}
	return r
}


// Aws_sns_topic_policyHandler ...
type Aws_sns_topic_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sns_topic_policyHandler) Create(desired *Aws_sns_topic_policy) (*Aws_sns_topic_policy, string, error) {
	rState := Aws_sns_topic_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sns_topic_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sns_topic_policyHandler) Read(externalID string) (*Aws_sns_topic_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_sns_topic_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sns_topic_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sns_topic_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sns_topic_policy", externalID)
}

type Aws_batch_job_queue struct {
     Aws_batch_job_queue_id *string
     Name string
     State string
     Arn *string
}


func Aws_batch_job_queueMapper(r *Aws_batch_job_queue) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["state"] = r.State
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_batch_job_queueUnmapper(state map[string]interface{}) *Aws_batch_job_queue {
	r := &Aws_batch_job_queue{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_batch_job_queue_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["state"]; ok {
	r.State = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_batch_job_queueHandler ...
type Aws_batch_job_queueHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_batch_job_queueHandler) Create(desired *Aws_batch_job_queue) (*Aws_batch_job_queue, string, error) {
	rState := Aws_batch_job_queueMapper(desired)
	id, err := bridge.Create(h.provider, "aws_batch_job_queue", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_batch_job_queueHandler) Read(externalID string) (*Aws_batch_job_queue, error) {
	actual, err := bridge.Read(h.provider, "aws_batch_job_queue", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_batch_job_queueUnmapper(actual), nil
}

// Delete ...
func (h *Aws_batch_job_queueHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_batch_job_queue", externalID)
}

type Aws_cognito_identity_provider struct {
     Aws_cognito_identity_provider_id *string
     Attribute_mapping *map[string]string
     Provider_details map[string]string
     Provider_name string
     Provider_type string
     User_pool_id string
}


func Aws_cognito_identity_providerMapper(r *Aws_cognito_identity_provider) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["provider_details"] = r.Provider_details
    config["provider_name"] = r.Provider_name
    config["provider_type"] = r.Provider_type
    config["user_pool_id"] = r.User_pool_id
if r.Attribute_mapping != nil {
    config["attribute_mapping"] = *r.Attribute_mapping
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cognito_identity_providerUnmapper(state map[string]interface{}) *Aws_cognito_identity_provider {
	r := &Aws_cognito_identity_provider{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cognito_identity_provider_id = &x
}

if x, ok := state["provider_name"]; ok {
	r.Provider_name = x.(string)
}

if x, ok := state["provider_type"]; ok {
	r.Provider_type = x.(string)
}

if x, ok := state["user_pool_id"]; ok {
	r.User_pool_id = x.(string)
}

if x, ok := state["attribute_mapping"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Attribute_mapping = &x
}

if x, ok := state["provider_details"]; ok {
	r.Provider_details = x.(map[string]string)
}
	return r
}


// Aws_cognito_identity_providerHandler ...
type Aws_cognito_identity_providerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cognito_identity_providerHandler) Create(desired *Aws_cognito_identity_provider) (*Aws_cognito_identity_provider, string, error) {
	rState := Aws_cognito_identity_providerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cognito_identity_provider", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cognito_identity_providerHandler) Read(externalID string) (*Aws_cognito_identity_provider, error) {
	actual, err := bridge.Read(h.provider, "aws_cognito_identity_provider", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cognito_identity_providerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cognito_identity_providerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cognito_identity_provider", externalID)
}

type Aws_cognito_resource_server struct {
     Aws_cognito_resource_server_id *string
     Identifier string
     Name string
     User_pool_id string
}


func Aws_cognito_resource_serverMapper(r *Aws_cognito_resource_server) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["identifier"] = r.Identifier
    config["name"] = r.Name
    config["user_pool_id"] = r.User_pool_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cognito_resource_serverUnmapper(state map[string]interface{}) *Aws_cognito_resource_server {
	r := &Aws_cognito_resource_server{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cognito_resource_server_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["user_pool_id"]; ok {
	r.User_pool_id = x.(string)
}

if x, ok := state["identifier"]; ok {
	r.Identifier = x.(string)
}
	return r
}


// Aws_cognito_resource_serverHandler ...
type Aws_cognito_resource_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cognito_resource_serverHandler) Create(desired *Aws_cognito_resource_server) (*Aws_cognito_resource_server, string, error) {
	rState := Aws_cognito_resource_serverMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cognito_resource_server", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cognito_resource_serverHandler) Read(externalID string) (*Aws_cognito_resource_server, error) {
	actual, err := bridge.Read(h.provider, "aws_cognito_resource_server", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cognito_resource_serverUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cognito_resource_serverHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cognito_resource_server", externalID)
}

type Aws_guardduty_member struct {
     Aws_guardduty_member_id *string
     Detector_id string
     Email string
     Relationship_status *string
     Invite *bool
     Disable_email_notification *bool
     Invitation_message *string
     Account_id string
}


func Aws_guardduty_memberMapper(r *Aws_guardduty_member) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["email"] = r.Email
if r.Relationship_status != nil {
    config["relationship_status"] = *r.Relationship_status
}
if r.Invite != nil {
    config["invite"] = *r.Invite
}
if r.Disable_email_notification != nil {
    config["disable_email_notification"] = *r.Disable_email_notification
}
if r.Invitation_message != nil {
    config["invitation_message"] = *r.Invitation_message
}
    config["account_id"] = r.Account_id
    config["detector_id"] = r.Detector_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_guardduty_memberUnmapper(state map[string]interface{}) *Aws_guardduty_member {
	r := &Aws_guardduty_member{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_guardduty_member_id = &x
}

if x, ok := state["relationship_status"]; ok {
	x := x.(string)
	r.Relationship_status = &x
}

if x, ok := state["invite"]; ok {
	x := x.(bool)
	r.Invite = &x
}

if x, ok := state["disable_email_notification"]; ok {
	x := x.(bool)
	r.Disable_email_notification = &x
}

if x, ok := state["invitation_message"]; ok {
	x := x.(string)
	r.Invitation_message = &x
}

if x, ok := state["account_id"]; ok {
	r.Account_id = x.(string)
}

if x, ok := state["detector_id"]; ok {
	r.Detector_id = x.(string)
}

if x, ok := state["email"]; ok {
	r.Email = x.(string)
}
	return r
}


// Aws_guardduty_memberHandler ...
type Aws_guardduty_memberHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_guardduty_memberHandler) Create(desired *Aws_guardduty_member) (*Aws_guardduty_member, string, error) {
	rState := Aws_guardduty_memberMapper(desired)
	id, err := bridge.Create(h.provider, "aws_guardduty_member", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_guardduty_memberHandler) Read(externalID string) (*Aws_guardduty_member, error) {
	actual, err := bridge.Read(h.provider, "aws_guardduty_member", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_guardduty_memberUnmapper(actual), nil
}

// Delete ...
func (h *Aws_guardduty_memberHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_guardduty_member", externalID)
}

type Aws_iam_saml_provider struct {
     Aws_iam_saml_provider_id *string
     Saml_metadata_document string
     Arn *string
     Valid_until *string
     Name string
}


func Aws_iam_saml_providerMapper(r *Aws_iam_saml_provider) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Valid_until != nil {
    config["valid_until"] = *r.Valid_until
}
    config["name"] = r.Name
    config["saml_metadata_document"] = r.Saml_metadata_document
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_saml_providerUnmapper(state map[string]interface{}) *Aws_iam_saml_provider {
	r := &Aws_iam_saml_provider{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_saml_provider_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["valid_until"]; ok {
	x := x.(string)
	r.Valid_until = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["saml_metadata_document"]; ok {
	r.Saml_metadata_document = x.(string)
}
	return r
}


// Aws_iam_saml_providerHandler ...
type Aws_iam_saml_providerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_saml_providerHandler) Create(desired *Aws_iam_saml_provider) (*Aws_iam_saml_provider, string, error) {
	rState := Aws_iam_saml_providerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_saml_provider", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_saml_providerHandler) Read(externalID string) (*Aws_iam_saml_provider, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_saml_provider", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_saml_providerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_saml_providerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_saml_provider", externalID)
}

type Aws_storagegateway_upload_buffer struct {
     Aws_storagegateway_upload_buffer_id *string
     Disk_id string
     Gateway_arn string
}


func Aws_storagegateway_upload_bufferMapper(r *Aws_storagegateway_upload_buffer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["disk_id"] = r.Disk_id
    config["gateway_arn"] = r.Gateway_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_storagegateway_upload_bufferUnmapper(state map[string]interface{}) *Aws_storagegateway_upload_buffer {
	r := &Aws_storagegateway_upload_buffer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_storagegateway_upload_buffer_id = &x
}

if x, ok := state["disk_id"]; ok {
	r.Disk_id = x.(string)
}

if x, ok := state["gateway_arn"]; ok {
	r.Gateway_arn = x.(string)
}
	return r
}


// Aws_storagegateway_upload_bufferHandler ...
type Aws_storagegateway_upload_bufferHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_storagegateway_upload_bufferHandler) Create(desired *Aws_storagegateway_upload_buffer) (*Aws_storagegateway_upload_buffer, string, error) {
	rState := Aws_storagegateway_upload_bufferMapper(desired)
	id, err := bridge.Create(h.provider, "aws_storagegateway_upload_buffer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_storagegateway_upload_bufferHandler) Read(externalID string) (*Aws_storagegateway_upload_buffer, error) {
	actual, err := bridge.Read(h.provider, "aws_storagegateway_upload_buffer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_storagegateway_upload_bufferUnmapper(actual), nil
}

// Delete ...
func (h *Aws_storagegateway_upload_bufferHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_storagegateway_upload_buffer", externalID)
}

type Aws_waf_rule_group struct {
     Aws_waf_rule_group_id *string
     Name string
     Metric_name string
}


func Aws_waf_rule_groupMapper(r *Aws_waf_rule_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["metric_name"] = r.Metric_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_rule_groupUnmapper(state map[string]interface{}) *Aws_waf_rule_group {
	r := &Aws_waf_rule_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_rule_group_id = &x
}

if x, ok := state["metric_name"]; ok {
	r.Metric_name = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_waf_rule_groupHandler ...
type Aws_waf_rule_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_rule_groupHandler) Create(desired *Aws_waf_rule_group) (*Aws_waf_rule_group, string, error) {
	rState := Aws_waf_rule_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_rule_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_rule_groupHandler) Read(externalID string) (*Aws_waf_rule_group, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_rule_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_rule_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_rule_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_rule_group", externalID)
}

type Aws_cloudwatch_log_stream struct {
     Aws_cloudwatch_log_stream_id *string
     Arn *string
     Name string
     Log_group_name string
}


func Aws_cloudwatch_log_streamMapper(r *Aws_cloudwatch_log_stream) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
    config["log_group_name"] = r.Log_group_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_log_streamUnmapper(state map[string]interface{}) *Aws_cloudwatch_log_stream {
	r := &Aws_cloudwatch_log_stream{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_log_stream_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["log_group_name"]; ok {
	r.Log_group_name = x.(string)
}
	return r
}


// Aws_cloudwatch_log_streamHandler ...
type Aws_cloudwatch_log_streamHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_log_streamHandler) Create(desired *Aws_cloudwatch_log_stream) (*Aws_cloudwatch_log_stream, string, error) {
	rState := Aws_cloudwatch_log_streamMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_log_stream", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_log_streamHandler) Read(externalID string) (*Aws_cloudwatch_log_stream, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_log_stream", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_log_streamUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_log_streamHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_log_stream", externalID)
}

type Aws_config_configuration_recorder_status struct {
     Aws_config_configuration_recorder_status_id *string
     Name string
     Is_enabled bool
}


func Aws_config_configuration_recorder_statusMapper(r *Aws_config_configuration_recorder_status) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["is_enabled"] = r.Is_enabled
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_config_configuration_recorder_statusUnmapper(state map[string]interface{}) *Aws_config_configuration_recorder_status {
	r := &Aws_config_configuration_recorder_status{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_config_configuration_recorder_status_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["is_enabled"]; ok {
	r.Is_enabled = x.(bool)
}
	return r
}


// Aws_config_configuration_recorder_statusHandler ...
type Aws_config_configuration_recorder_statusHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_config_configuration_recorder_statusHandler) Create(desired *Aws_config_configuration_recorder_status) (*Aws_config_configuration_recorder_status, string, error) {
	rState := Aws_config_configuration_recorder_statusMapper(desired)
	id, err := bridge.Create(h.provider, "aws_config_configuration_recorder_status", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_config_configuration_recorder_statusHandler) Read(externalID string) (*Aws_config_configuration_recorder_status, error) {
	actual, err := bridge.Read(h.provider, "aws_config_configuration_recorder_status", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_config_configuration_recorder_statusUnmapper(actual), nil
}

// Delete ...
func (h *Aws_config_configuration_recorder_statusHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_config_configuration_recorder_status", externalID)
}

type Aws_opsworks_stack struct {
     Aws_opsworks_stack_id *string
     Arn *string
     Configuration_manager_version *string
     Custom_json *string
     Default_availability_zone *string
     Default_os *string
     Tags *map[string]string
     Agent_version *string
     Vpc_id *string
     Use_custom_cookbooks *bool
     Default_instance_profile_arn string
     Configuration_manager_name *string
     Berkshelf_version *string
     Use_opsworks_security_groups *bool
     Region string
     Color *string
     Manage_berkshelf *bool
     Default_root_device_type *string
     Default_ssh_key_name *string
     Hostname_theme *string
     Stack_endpoint *string
     Name string
     Default_subnet_id *string
     Service_role_arn string
}


func Aws_opsworks_stackMapper(r *Aws_opsworks_stack) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["region"] = r.Region
    config["default_instance_profile_arn"] = r.Default_instance_profile_arn
if r.Configuration_manager_name != nil {
    config["configuration_manager_name"] = *r.Configuration_manager_name
}
if r.Berkshelf_version != nil {
    config["berkshelf_version"] = *r.Berkshelf_version
}
if r.Use_opsworks_security_groups != nil {
    config["use_opsworks_security_groups"] = *r.Use_opsworks_security_groups
}
    config["name"] = r.Name
if r.Color != nil {
    config["color"] = *r.Color
}
if r.Manage_berkshelf != nil {
    config["manage_berkshelf"] = *r.Manage_berkshelf
}
if r.Default_root_device_type != nil {
    config["default_root_device_type"] = *r.Default_root_device_type
}
if r.Default_ssh_key_name != nil {
    config["default_ssh_key_name"] = *r.Default_ssh_key_name
}
if r.Hostname_theme != nil {
    config["hostname_theme"] = *r.Hostname_theme
}
if r.Stack_endpoint != nil {
    config["stack_endpoint"] = *r.Stack_endpoint
}
    config["service_role_arn"] = r.Service_role_arn
if r.Default_subnet_id != nil {
    config["default_subnet_id"] = *r.Default_subnet_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Agent_version != nil {
    config["agent_version"] = *r.Agent_version
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Configuration_manager_version != nil {
    config["configuration_manager_version"] = *r.Configuration_manager_version
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Default_availability_zone != nil {
    config["default_availability_zone"] = *r.Default_availability_zone
}
if r.Default_os != nil {
    config["default_os"] = *r.Default_os
}
if r.Use_custom_cookbooks != nil {
    config["use_custom_cookbooks"] = *r.Use_custom_cookbooks
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_stackUnmapper(state map[string]interface{}) *Aws_opsworks_stack {
	r := &Aws_opsworks_stack{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_stack_id = &x
}

if x, ok := state["color"]; ok {
	x := x.(string)
	r.Color = &x
}

if x, ok := state["manage_berkshelf"]; ok {
	x := x.(bool)
	r.Manage_berkshelf = &x
}

if x, ok := state["default_root_device_type"]; ok {
	x := x.(string)
	r.Default_root_device_type = &x
}

if x, ok := state["default_ssh_key_name"]; ok {
	x := x.(string)
	r.Default_ssh_key_name = &x
}

if x, ok := state["hostname_theme"]; ok {
	x := x.(string)
	r.Hostname_theme = &x
}

if x, ok := state["stack_endpoint"]; ok {
	x := x.(string)
	r.Stack_endpoint = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["default_subnet_id"]; ok {
	x := x.(string)
	r.Default_subnet_id = &x
}

if x, ok := state["service_role_arn"]; ok {
	r.Service_role_arn = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["configuration_manager_version"]; ok {
	x := x.(string)
	r.Configuration_manager_version = &x
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["default_availability_zone"]; ok {
	x := x.(string)
	r.Default_availability_zone = &x
}

if x, ok := state["default_os"]; ok {
	x := x.(string)
	r.Default_os = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["agent_version"]; ok {
	x := x.(string)
	r.Agent_version = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["use_custom_cookbooks"]; ok {
	x := x.(bool)
	r.Use_custom_cookbooks = &x
}

if x, ok := state["default_instance_profile_arn"]; ok {
	r.Default_instance_profile_arn = x.(string)
}

if x, ok := state["configuration_manager_name"]; ok {
	x := x.(string)
	r.Configuration_manager_name = &x
}

if x, ok := state["berkshelf_version"]; ok {
	x := x.(string)
	r.Berkshelf_version = &x
}

if x, ok := state["use_opsworks_security_groups"]; ok {
	x := x.(bool)
	r.Use_opsworks_security_groups = &x
}

if x, ok := state["region"]; ok {
	r.Region = x.(string)
}
	return r
}


// Aws_opsworks_stackHandler ...
type Aws_opsworks_stackHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_stackHandler) Create(desired *Aws_opsworks_stack) (*Aws_opsworks_stack, string, error) {
	rState := Aws_opsworks_stackMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_stack", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_stackHandler) Read(externalID string) (*Aws_opsworks_stack, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_stack", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_stackUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_stackHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_stack", externalID)
}

type Aws_wafregional_byte_match_set struct {
     Aws_wafregional_byte_match_set_id *string
     Name string
}


func Aws_wafregional_byte_match_setMapper(r *Aws_wafregional_byte_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_byte_match_setUnmapper(state map[string]interface{}) *Aws_wafregional_byte_match_set {
	r := &Aws_wafregional_byte_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_byte_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_wafregional_byte_match_setHandler ...
type Aws_wafregional_byte_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_byte_match_setHandler) Create(desired *Aws_wafregional_byte_match_set) (*Aws_wafregional_byte_match_set, string, error) {
	rState := Aws_wafregional_byte_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_byte_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_byte_match_setHandler) Read(externalID string) (*Aws_wafregional_byte_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_byte_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_byte_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_byte_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_byte_match_set", externalID)
}

type Aws_dax_parameter_group struct {
     Aws_dax_parameter_group_id *string
     Name string
     Description *string
}


func Aws_dax_parameter_groupMapper(r *Aws_dax_parameter_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dax_parameter_groupUnmapper(state map[string]interface{}) *Aws_dax_parameter_group {
	r := &Aws_dax_parameter_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dax_parameter_group_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_dax_parameter_groupHandler ...
type Aws_dax_parameter_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dax_parameter_groupHandler) Create(desired *Aws_dax_parameter_group) (*Aws_dax_parameter_group, string, error) {
	rState := Aws_dax_parameter_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dax_parameter_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dax_parameter_groupHandler) Read(externalID string) (*Aws_dax_parameter_group, error) {
	actual, err := bridge.Read(h.provider, "aws_dax_parameter_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dax_parameter_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dax_parameter_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dax_parameter_group", externalID)
}

type Aws_kinesis_firehose_delivery_stream struct {
     Aws_kinesis_firehose_delivery_stream_id *string
     Name string
     Tags *map[string]string
     Destination string
     Destination_id *string
     Arn *string
     Version_id *string
}


func Aws_kinesis_firehose_delivery_streamMapper(r *Aws_kinesis_firehose_delivery_stream) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["destination"] = r.Destination
    config["name"] = r.Name
if r.Destination_id != nil {
    config["destination_id"] = *r.Destination_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Version_id != nil {
    config["version_id"] = *r.Version_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_kinesis_firehose_delivery_streamUnmapper(state map[string]interface{}) *Aws_kinesis_firehose_delivery_stream {
	r := &Aws_kinesis_firehose_delivery_stream{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_kinesis_firehose_delivery_stream_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["version_id"]; ok {
	x := x.(string)
	r.Version_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["destination"]; ok {
	r.Destination = x.(string)
}

if x, ok := state["destination_id"]; ok {
	x := x.(string)
	r.Destination_id = &x
}
	return r
}


// Aws_kinesis_firehose_delivery_streamHandler ...
type Aws_kinesis_firehose_delivery_streamHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_kinesis_firehose_delivery_streamHandler) Create(desired *Aws_kinesis_firehose_delivery_stream) (*Aws_kinesis_firehose_delivery_stream, string, error) {
	rState := Aws_kinesis_firehose_delivery_streamMapper(desired)
	id, err := bridge.Create(h.provider, "aws_kinesis_firehose_delivery_stream", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_kinesis_firehose_delivery_streamHandler) Read(externalID string) (*Aws_kinesis_firehose_delivery_stream, error) {
	actual, err := bridge.Read(h.provider, "aws_kinesis_firehose_delivery_stream", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_kinesis_firehose_delivery_streamUnmapper(actual), nil
}

// Delete ...
func (h *Aws_kinesis_firehose_delivery_streamHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_kinesis_firehose_delivery_stream", externalID)
}

type Aws_sqs_queue struct {
     Aws_sqs_queue_id *string
     Name *string
     Name_prefix *string
     Content_based_deduplication *bool
     Redrive_policy *string
     Arn *string
     Tags *map[string]string
     Kms_master_key_id *string
     Policy *string
     Fifo_queue *bool
}


func Aws_sqs_queueMapper(r *Aws_sqs_queue) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Policy != nil {
    config["policy"] = *r.Policy
}
if r.Fifo_queue != nil {
    config["fifo_queue"] = *r.Fifo_queue
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Content_based_deduplication != nil {
    config["content_based_deduplication"] = *r.Content_based_deduplication
}
if r.Redrive_policy != nil {
    config["redrive_policy"] = *r.Redrive_policy
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Kms_master_key_id != nil {
    config["kms_master_key_id"] = *r.Kms_master_key_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sqs_queueUnmapper(state map[string]interface{}) *Aws_sqs_queue {
	r := &Aws_sqs_queue{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sqs_queue_id = &x
}

if x, ok := state["kms_master_key_id"]; ok {
	x := x.(string)
	r.Kms_master_key_id = &x
}

if x, ok := state["policy"]; ok {
	x := x.(string)
	r.Policy = &x
}

if x, ok := state["fifo_queue"]; ok {
	x := x.(bool)
	r.Fifo_queue = &x
}

if x, ok := state["content_based_deduplication"]; ok {
	x := x.(bool)
	r.Content_based_deduplication = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["redrive_policy"]; ok {
	x := x.(string)
	r.Redrive_policy = &x
}
	return r
}


// Aws_sqs_queueHandler ...
type Aws_sqs_queueHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sqs_queueHandler) Create(desired *Aws_sqs_queue) (*Aws_sqs_queue, string, error) {
	rState := Aws_sqs_queueMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sqs_queue", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sqs_queueHandler) Read(externalID string) (*Aws_sqs_queue, error) {
	actual, err := bridge.Read(h.provider, "aws_sqs_queue", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sqs_queueUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sqs_queueHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sqs_queue", externalID)
}

type Aws_appmesh_mesh struct {
     Aws_appmesh_mesh_id *string
     Created_date *string
     Last_updated_date *string
     Name string
     Arn *string
}


func Aws_appmesh_meshMapper(r *Aws_appmesh_mesh) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
if r.Last_updated_date != nil {
    config["last_updated_date"] = *r.Last_updated_date
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appmesh_meshUnmapper(state map[string]interface{}) *Aws_appmesh_mesh {
	r := &Aws_appmesh_mesh{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appmesh_mesh_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}

if x, ok := state["last_updated_date"]; ok {
	x := x.(string)
	r.Last_updated_date = &x
}
	return r
}


// Aws_appmesh_meshHandler ...
type Aws_appmesh_meshHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appmesh_meshHandler) Create(desired *Aws_appmesh_mesh) (*Aws_appmesh_mesh, string, error) {
	rState := Aws_appmesh_meshMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appmesh_mesh", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appmesh_meshHandler) Read(externalID string) (*Aws_appmesh_mesh, error) {
	actual, err := bridge.Read(h.provider, "aws_appmesh_mesh", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appmesh_meshUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appmesh_meshHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appmesh_mesh", externalID)
}

type Aws_ec2_transit_gateway_vpc_attachment struct {
     Aws_ec2_transit_gateway_vpc_attachment_id *string
     Dns_support *string
     Tags *map[string]string
     Transit_gateway_default_route_table_association *bool
     Transit_gateway_default_route_table_propagation *bool
     Transit_gateway_id string
     Ipv6_support *string
     Vpc_id string
     Vpc_owner_id *string
}


func Aws_ec2_transit_gateway_vpc_attachmentMapper(r *Aws_ec2_transit_gateway_vpc_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Transit_gateway_default_route_table_association != nil {
    config["transit_gateway_default_route_table_association"] = *r.Transit_gateway_default_route_table_association
}
if r.Transit_gateway_default_route_table_propagation != nil {
    config["transit_gateway_default_route_table_propagation"] = *r.Transit_gateway_default_route_table_propagation
}
    config["transit_gateway_id"] = r.Transit_gateway_id
if r.Dns_support != nil {
    config["dns_support"] = *r.Dns_support
}
if r.Vpc_owner_id != nil {
    config["vpc_owner_id"] = *r.Vpc_owner_id
}
if r.Ipv6_support != nil {
    config["ipv6_support"] = *r.Ipv6_support
}
    config["vpc_id"] = r.Vpc_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ec2_transit_gateway_vpc_attachmentUnmapper(state map[string]interface{}) *Aws_ec2_transit_gateway_vpc_attachment {
	r := &Aws_ec2_transit_gateway_vpc_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ec2_transit_gateway_vpc_attachment_id = &x
}

if x, ok := state["dns_support"]; ok {
	x := x.(string)
	r.Dns_support = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["transit_gateway_default_route_table_association"]; ok {
	x := x.(bool)
	r.Transit_gateway_default_route_table_association = &x
}

if x, ok := state["transit_gateway_default_route_table_propagation"]; ok {
	x := x.(bool)
	r.Transit_gateway_default_route_table_propagation = &x
}

if x, ok := state["transit_gateway_id"]; ok {
	r.Transit_gateway_id = x.(string)
}

if x, ok := state["ipv6_support"]; ok {
	x := x.(string)
	r.Ipv6_support = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["vpc_owner_id"]; ok {
	x := x.(string)
	r.Vpc_owner_id = &x
}
	return r
}


// Aws_ec2_transit_gateway_vpc_attachmentHandler ...
type Aws_ec2_transit_gateway_vpc_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ec2_transit_gateway_vpc_attachmentHandler) Create(desired *Aws_ec2_transit_gateway_vpc_attachment) (*Aws_ec2_transit_gateway_vpc_attachment, string, error) {
	rState := Aws_ec2_transit_gateway_vpc_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ec2_transit_gateway_vpc_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ec2_transit_gateway_vpc_attachmentHandler) Read(externalID string) (*Aws_ec2_transit_gateway_vpc_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_ec2_transit_gateway_vpc_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ec2_transit_gateway_vpc_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ec2_transit_gateway_vpc_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ec2_transit_gateway_vpc_attachment", externalID)
}

type Aws_opsworks_ganglia_layer struct {
     Aws_opsworks_ganglia_layer_id *string
     Auto_assign_public_ips *bool
     Elastic_load_balancer *string
     Custom_json *string
     Name *string
     Auto_assign_elastic_ips *bool
     Custom_instance_profile_arn *string
     Drain_elb_on_shutdown *bool
     Username *string
     Password string
     Use_ebs_optimized_instances *bool
     Auto_healing *bool
     Install_updates_on_boot *bool
     Stack_id string
     Url *string
}


func Aws_opsworks_ganglia_layerMapper(r *Aws_opsworks_ganglia_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
    config["stack_id"] = r.Stack_id
if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
if r.Url != nil {
    config["url"] = *r.Url
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
if r.Username != nil {
    config["username"] = *r.Username
}
    config["password"] = r.Password
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_ganglia_layerUnmapper(state map[string]interface{}) *Aws_opsworks_ganglia_layer {
	r := &Aws_opsworks_ganglia_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_ganglia_layer_id = &x
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["username"]; ok {
	x := x.(string)
	r.Username = &x
}

if x, ok := state["password"]; ok {
	r.Password = x.(string)
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["url"]; ok {
	x := x.(string)
	r.Url = &x
}
	return r
}


// Aws_opsworks_ganglia_layerHandler ...
type Aws_opsworks_ganglia_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_ganglia_layerHandler) Create(desired *Aws_opsworks_ganglia_layer) (*Aws_opsworks_ganglia_layer, string, error) {
	rState := Aws_opsworks_ganglia_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_ganglia_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_ganglia_layerHandler) Read(externalID string) (*Aws_opsworks_ganglia_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_ganglia_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_ganglia_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_ganglia_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_ganglia_layer", externalID)
}

type Aws_batch_job_definition struct {
     Aws_batch_job_definition_id *string
     Name string
     Container_properties *string
     Parameters *map[string]string
     Resource_type string
     Arn *string
}


func Aws_batch_job_definitionMapper(r *Aws_batch_job_definition) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Container_properties != nil {
    config["container_properties"] = *r.Container_properties
}
if r.Parameters != nil {
    config["parameters"] = *r.Parameters
}
    config["resource_type"] = r.Resource_type
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_batch_job_definitionUnmapper(state map[string]interface{}) *Aws_batch_job_definition {
	r := &Aws_batch_job_definition{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_batch_job_definition_id = &x
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["container_properties"]; ok {
	x := x.(string)
	r.Container_properties = &x
}

if x, ok := state["parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Parameters = &x
}
	return r
}


// Aws_batch_job_definitionHandler ...
type Aws_batch_job_definitionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_batch_job_definitionHandler) Create(desired *Aws_batch_job_definition) (*Aws_batch_job_definition, string, error) {
	rState := Aws_batch_job_definitionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_batch_job_definition", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_batch_job_definitionHandler) Read(externalID string) (*Aws_batch_job_definition, error) {
	actual, err := bridge.Read(h.provider, "aws_batch_job_definition", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_batch_job_definitionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_batch_job_definitionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_batch_job_definition", externalID)
}

type Aws_config_configuration_aggregator struct {
     Aws_config_configuration_aggregator_id *string
     Name string
     Arn *string
}


func Aws_config_configuration_aggregatorMapper(r *Aws_config_configuration_aggregator) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_config_configuration_aggregatorUnmapper(state map[string]interface{}) *Aws_config_configuration_aggregator {
	r := &Aws_config_configuration_aggregator{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_config_configuration_aggregator_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_config_configuration_aggregatorHandler ...
type Aws_config_configuration_aggregatorHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_config_configuration_aggregatorHandler) Create(desired *Aws_config_configuration_aggregator) (*Aws_config_configuration_aggregator, string, error) {
	rState := Aws_config_configuration_aggregatorMapper(desired)
	id, err := bridge.Create(h.provider, "aws_config_configuration_aggregator", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_config_configuration_aggregatorHandler) Read(externalID string) (*Aws_config_configuration_aggregator, error) {
	actual, err := bridge.Read(h.provider, "aws_config_configuration_aggregator", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_config_configuration_aggregatorUnmapper(actual), nil
}

// Delete ...
func (h *Aws_config_configuration_aggregatorHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_config_configuration_aggregator", externalID)
}

type Aws_elasticache_security_group struct {
     Aws_elasticache_security_group_id *string
     Description *string
     Name string
}


func Aws_elasticache_security_groupMapper(r *Aws_elasticache_security_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elasticache_security_groupUnmapper(state map[string]interface{}) *Aws_elasticache_security_group {
	r := &Aws_elasticache_security_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elasticache_security_group_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_elasticache_security_groupHandler ...
type Aws_elasticache_security_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elasticache_security_groupHandler) Create(desired *Aws_elasticache_security_group) (*Aws_elasticache_security_group, string, error) {
	rState := Aws_elasticache_security_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elasticache_security_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elasticache_security_groupHandler) Read(externalID string) (*Aws_elasticache_security_group, error) {
	actual, err := bridge.Read(h.provider, "aws_elasticache_security_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elasticache_security_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elasticache_security_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elasticache_security_group", externalID)
}

type Aws_network_interface_attachment struct {
     Aws_network_interface_attachment_id *string
     Network_interface_id string
     Attachment_id *string
     Status *string
     Instance_id string
}


func Aws_network_interface_attachmentMapper(r *Aws_network_interface_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Attachment_id != nil {
    config["attachment_id"] = *r.Attachment_id
}
if r.Status != nil {
    config["status"] = *r.Status
}
    config["instance_id"] = r.Instance_id
    config["network_interface_id"] = r.Network_interface_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_network_interface_attachmentUnmapper(state map[string]interface{}) *Aws_network_interface_attachment {
	r := &Aws_network_interface_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_network_interface_attachment_id = &x
}

if x, ok := state["instance_id"]; ok {
	r.Instance_id = x.(string)
}

if x, ok := state["network_interface_id"]; ok {
	r.Network_interface_id = x.(string)
}

if x, ok := state["attachment_id"]; ok {
	x := x.(string)
	r.Attachment_id = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}
	return r
}


// Aws_network_interface_attachmentHandler ...
type Aws_network_interface_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_network_interface_attachmentHandler) Create(desired *Aws_network_interface_attachment) (*Aws_network_interface_attachment, string, error) {
	rState := Aws_network_interface_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_network_interface_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_network_interface_attachmentHandler) Read(externalID string) (*Aws_network_interface_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_network_interface_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_network_interface_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_network_interface_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_network_interface_attachment", externalID)
}

type Aws_transfer_user struct {
     Aws_transfer_user_id *string
     Role string
     Server_id string
     Tags *map[string]string
     User_name string
     Arn *string
     Home_directory *string
     Policy *string
}


func Aws_transfer_userMapper(r *Aws_transfer_user) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["server_id"] = r.Server_id
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["user_name"] = r.User_name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Home_directory != nil {
    config["home_directory"] = *r.Home_directory
}
if r.Policy != nil {
    config["policy"] = *r.Policy
}
    config["role"] = r.Role
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_transfer_userUnmapper(state map[string]interface{}) *Aws_transfer_user {
	r := &Aws_transfer_user{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_transfer_user_id = &x
}

if x, ok := state["home_directory"]; ok {
	x := x.(string)
	r.Home_directory = &x
}

if x, ok := state["policy"]; ok {
	x := x.(string)
	r.Policy = &x
}

if x, ok := state["role"]; ok {
	r.Role = x.(string)
}

if x, ok := state["server_id"]; ok {
	r.Server_id = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["user_name"]; ok {
	r.User_name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_transfer_userHandler ...
type Aws_transfer_userHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_transfer_userHandler) Create(desired *Aws_transfer_user) (*Aws_transfer_user, string, error) {
	rState := Aws_transfer_userMapper(desired)
	id, err := bridge.Create(h.provider, "aws_transfer_user", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_transfer_userHandler) Read(externalID string) (*Aws_transfer_user, error) {
	actual, err := bridge.Read(h.provider, "aws_transfer_user", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_transfer_userUnmapper(actual), nil
}

// Delete ...
func (h *Aws_transfer_userHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_transfer_user", externalID)
}

type Aws_autoscaling_notification struct {
     Aws_autoscaling_notification_id *string
     Topic_arn string
}


func Aws_autoscaling_notificationMapper(r *Aws_autoscaling_notification) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["topic_arn"] = r.Topic_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_autoscaling_notificationUnmapper(state map[string]interface{}) *Aws_autoscaling_notification {
	r := &Aws_autoscaling_notification{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_autoscaling_notification_id = &x
}

if x, ok := state["topic_arn"]; ok {
	r.Topic_arn = x.(string)
}
	return r
}


// Aws_autoscaling_notificationHandler ...
type Aws_autoscaling_notificationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_autoscaling_notificationHandler) Create(desired *Aws_autoscaling_notification) (*Aws_autoscaling_notification, string, error) {
	rState := Aws_autoscaling_notificationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_autoscaling_notification", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_autoscaling_notificationHandler) Read(externalID string) (*Aws_autoscaling_notification, error) {
	actual, err := bridge.Read(h.provider, "aws_autoscaling_notification", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_autoscaling_notificationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_autoscaling_notificationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_autoscaling_notification", externalID)
}

type Aws_glue_job struct {
     Aws_glue_job_id *string
     Name string
     Role_arn string
     Security_configuration *string
     Description *string
     Default_arguments *map[string]string
}


func Aws_glue_jobMapper(r *Aws_glue_job) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Security_configuration != nil {
    config["security_configuration"] = *r.Security_configuration
}
if r.Description != nil {
    config["description"] = *r.Description
}
    config["name"] = r.Name
    config["role_arn"] = r.Role_arn
if r.Default_arguments != nil {
    config["default_arguments"] = *r.Default_arguments
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glue_jobUnmapper(state map[string]interface{}) *Aws_glue_job {
	r := &Aws_glue_job{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glue_job_id = &x
}

if x, ok := state["default_arguments"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Default_arguments = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}

if x, ok := state["security_configuration"]; ok {
	x := x.(string)
	r.Security_configuration = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_glue_jobHandler ...
type Aws_glue_jobHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glue_jobHandler) Create(desired *Aws_glue_job) (*Aws_glue_job, string, error) {
	rState := Aws_glue_jobMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glue_job", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glue_jobHandler) Read(externalID string) (*Aws_glue_job, error) {
	actual, err := bridge.Read(h.provider, "aws_glue_job", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glue_jobUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glue_jobHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glue_job", externalID)
}

type Aws_iot_topic_rule struct {
     Aws_iot_topic_rule_id *string
     Sql_version string
     Sql string
     Name string
     Description *string
     Enabled bool
     Arn *string
}


func Aws_iot_topic_ruleMapper(r *Aws_iot_topic_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["sql"] = r.Sql
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
    config["enabled"] = r.Enabled
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["sql_version"] = r.Sql_version
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iot_topic_ruleUnmapper(state map[string]interface{}) *Aws_iot_topic_rule {
	r := &Aws_iot_topic_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iot_topic_rule_id = &x
}

if x, ok := state["sql_version"]; ok {
	r.Sql_version = x.(string)
}

if x, ok := state["sql"]; ok {
	r.Sql = x.(string)
}

if x, ok := state["enabled"]; ok {
	r.Enabled = x.(bool)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_iot_topic_ruleHandler ...
type Aws_iot_topic_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iot_topic_ruleHandler) Create(desired *Aws_iot_topic_rule) (*Aws_iot_topic_rule, string, error) {
	rState := Aws_iot_topic_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iot_topic_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iot_topic_ruleHandler) Read(externalID string) (*Aws_iot_topic_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_iot_topic_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iot_topic_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iot_topic_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iot_topic_rule", externalID)
}

type Aws_wafregional_web_acl_association struct {
     Aws_wafregional_web_acl_association_id *string
     Web_acl_id string
     Resource_arn string
}


func Aws_wafregional_web_acl_associationMapper(r *Aws_wafregional_web_acl_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["web_acl_id"] = r.Web_acl_id
    config["resource_arn"] = r.Resource_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_web_acl_associationUnmapper(state map[string]interface{}) *Aws_wafregional_web_acl_association {
	r := &Aws_wafregional_web_acl_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_web_acl_association_id = &x
}

if x, ok := state["web_acl_id"]; ok {
	r.Web_acl_id = x.(string)
}

if x, ok := state["resource_arn"]; ok {
	r.Resource_arn = x.(string)
}
	return r
}


// Aws_wafregional_web_acl_associationHandler ...
type Aws_wafregional_web_acl_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_web_acl_associationHandler) Create(desired *Aws_wafregional_web_acl_association) (*Aws_wafregional_web_acl_association, string, error) {
	rState := Aws_wafregional_web_acl_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_web_acl_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_web_acl_associationHandler) Read(externalID string) (*Aws_wafregional_web_acl_association, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_web_acl_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_web_acl_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_web_acl_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_web_acl_association", externalID)
}

type Aws_pinpoint_adm_channel struct {
     Aws_pinpoint_adm_channel_id *string
     Client_secret string
     Enabled *bool
     Application_id string
     Client_id string
}


func Aws_pinpoint_adm_channelMapper(r *Aws_pinpoint_adm_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["application_id"] = r.Application_id
    config["client_id"] = r.Client_id
    config["client_secret"] = r.Client_secret
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_adm_channelUnmapper(state map[string]interface{}) *Aws_pinpoint_adm_channel {
	r := &Aws_pinpoint_adm_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_adm_channel_id = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["client_id"]; ok {
	r.Client_id = x.(string)
}

if x, ok := state["client_secret"]; ok {
	r.Client_secret = x.(string)
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}
	return r
}


// Aws_pinpoint_adm_channelHandler ...
type Aws_pinpoint_adm_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_adm_channelHandler) Create(desired *Aws_pinpoint_adm_channel) (*Aws_pinpoint_adm_channel, string, error) {
	rState := Aws_pinpoint_adm_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_adm_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_adm_channelHandler) Read(externalID string) (*Aws_pinpoint_adm_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_adm_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_adm_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_adm_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_adm_channel", externalID)
}

type Aws_ebs_snapshot struct {
     Aws_ebs_snapshot_id *string
     Encrypted *bool
     Kms_key_id *string
     Description *string
     Owner_id *string
     Owner_alias *string
     Volume_id string
     Data_encryption_key_id *string
     Tags *map[string]string
}


func Aws_ebs_snapshotMapper(r *Aws_ebs_snapshot) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["volume_id"] = r.Volume_id
if r.Data_encryption_key_id != nil {
    config["data_encryption_key_id"] = *r.Data_encryption_key_id
}
if r.Owner_alias != nil {
    config["owner_alias"] = *r.Owner_alias
}
if r.Encrypted != nil {
    config["encrypted"] = *r.Encrypted
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ebs_snapshotUnmapper(state map[string]interface{}) *Aws_ebs_snapshot {
	r := &Aws_ebs_snapshot{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ebs_snapshot_id = &x
}

if x, ok := state["volume_id"]; ok {
	r.Volume_id = x.(string)
}

if x, ok := state["data_encryption_key_id"]; ok {
	x := x.(string)
	r.Data_encryption_key_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["owner_alias"]; ok {
	x := x.(string)
	r.Owner_alias = &x
}

if x, ok := state["encrypted"]; ok {
	x := x.(bool)
	r.Encrypted = &x
}
	return r
}


// Aws_ebs_snapshotHandler ...
type Aws_ebs_snapshotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ebs_snapshotHandler) Create(desired *Aws_ebs_snapshot) (*Aws_ebs_snapshot, string, error) {
	rState := Aws_ebs_snapshotMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ebs_snapshot", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ebs_snapshotHandler) Read(externalID string) (*Aws_ebs_snapshot, error) {
	actual, err := bridge.Read(h.provider, "aws_ebs_snapshot", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ebs_snapshotUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ebs_snapshotHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ebs_snapshot", externalID)
}

type Aws_iam_access_key struct {
     Aws_iam_access_key_id *string
     Status *string
     Secret *string
     Ses_smtp_password *string
     Pgp_key *string
     Key_fingerprint *string
     Encrypted_secret *string
     User string
}


func Aws_iam_access_keyMapper(r *Aws_iam_access_key) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Encrypted_secret != nil {
    config["encrypted_secret"] = *r.Encrypted_secret
}
    config["user"] = r.User
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Secret != nil {
    config["secret"] = *r.Secret
}
if r.Ses_smtp_password != nil {
    config["ses_smtp_password"] = *r.Ses_smtp_password
}
if r.Pgp_key != nil {
    config["pgp_key"] = *r.Pgp_key
}
if r.Key_fingerprint != nil {
    config["key_fingerprint"] = *r.Key_fingerprint
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_access_keyUnmapper(state map[string]interface{}) *Aws_iam_access_key {
	r := &Aws_iam_access_key{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_access_key_id = &x
}

if x, ok := state["ses_smtp_password"]; ok {
	x := x.(string)
	r.Ses_smtp_password = &x
}

if x, ok := state["pgp_key"]; ok {
	x := x.(string)
	r.Pgp_key = &x
}

if x, ok := state["key_fingerprint"]; ok {
	x := x.(string)
	r.Key_fingerprint = &x
}

if x, ok := state["encrypted_secret"]; ok {
	x := x.(string)
	r.Encrypted_secret = &x
}

if x, ok := state["user"]; ok {
	r.User = x.(string)
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["secret"]; ok {
	x := x.(string)
	r.Secret = &x
}
	return r
}


// Aws_iam_access_keyHandler ...
type Aws_iam_access_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_access_keyHandler) Create(desired *Aws_iam_access_key) (*Aws_iam_access_key, string, error) {
	rState := Aws_iam_access_keyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_access_key", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_access_keyHandler) Read(externalID string) (*Aws_iam_access_key, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_access_key", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_access_keyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_access_keyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_access_key", externalID)
}

type Aws_lightsail_static_ip struct {
     Aws_lightsail_static_ip_id *string
     Arn *string
     Support_code *string
     Name string
     Ip_address *string
}


func Aws_lightsail_static_ipMapper(r *Aws_lightsail_static_ip) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Ip_address != nil {
    config["ip_address"] = *r.Ip_address
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Support_code != nil {
    config["support_code"] = *r.Support_code
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lightsail_static_ipUnmapper(state map[string]interface{}) *Aws_lightsail_static_ip {
	r := &Aws_lightsail_static_ip{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lightsail_static_ip_id = &x
}

if x, ok := state["support_code"]; ok {
	x := x.(string)
	r.Support_code = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["ip_address"]; ok {
	x := x.(string)
	r.Ip_address = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_lightsail_static_ipHandler ...
type Aws_lightsail_static_ipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lightsail_static_ipHandler) Create(desired *Aws_lightsail_static_ip) (*Aws_lightsail_static_ip, string, error) {
	rState := Aws_lightsail_static_ipMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lightsail_static_ip", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lightsail_static_ipHandler) Read(externalID string) (*Aws_lightsail_static_ip, error) {
	actual, err := bridge.Read(h.provider, "aws_lightsail_static_ip", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lightsail_static_ipUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lightsail_static_ipHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lightsail_static_ip", externalID)
}

type Aws_media_store_container_policy struct {
     Aws_media_store_container_policy_id *string
     Container_name string
     Policy string
}


func Aws_media_store_container_policyMapper(r *Aws_media_store_container_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["container_name"] = r.Container_name
    config["policy"] = r.Policy
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_media_store_container_policyUnmapper(state map[string]interface{}) *Aws_media_store_container_policy {
	r := &Aws_media_store_container_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_media_store_container_policy_id = &x
}

if x, ok := state["container_name"]; ok {
	r.Container_name = x.(string)
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}
	return r
}


// Aws_media_store_container_policyHandler ...
type Aws_media_store_container_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_media_store_container_policyHandler) Create(desired *Aws_media_store_container_policy) (*Aws_media_store_container_policy, string, error) {
	rState := Aws_media_store_container_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_media_store_container_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_media_store_container_policyHandler) Read(externalID string) (*Aws_media_store_container_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_media_store_container_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_media_store_container_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_media_store_container_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_media_store_container_policy", externalID)
}

type Aws_route53_delegation_set struct {
     Aws_route53_delegation_set_id *string
     Reference_name *string
}


func Aws_route53_delegation_setMapper(r *Aws_route53_delegation_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Reference_name != nil {
    config["reference_name"] = *r.Reference_name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_route53_delegation_setUnmapper(state map[string]interface{}) *Aws_route53_delegation_set {
	r := &Aws_route53_delegation_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_route53_delegation_set_id = &x
}

if x, ok := state["reference_name"]; ok {
	x := x.(string)
	r.Reference_name = &x
}
	return r
}


// Aws_route53_delegation_setHandler ...
type Aws_route53_delegation_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_route53_delegation_setHandler) Create(desired *Aws_route53_delegation_set) (*Aws_route53_delegation_set, string, error) {
	rState := Aws_route53_delegation_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_route53_delegation_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_route53_delegation_setHandler) Read(externalID string) (*Aws_route53_delegation_set, error) {
	actual, err := bridge.Read(h.provider, "aws_route53_delegation_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_route53_delegation_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_route53_delegation_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_route53_delegation_set", externalID)
}

type Aws_elasticache_parameter_group struct {
     Aws_elasticache_parameter_group_id *string
     Name string
     Family string
     Description *string
}


func Aws_elasticache_parameter_groupMapper(r *Aws_elasticache_parameter_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["family"] = r.Family
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elasticache_parameter_groupUnmapper(state map[string]interface{}) *Aws_elasticache_parameter_group {
	r := &Aws_elasticache_parameter_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elasticache_parameter_group_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["family"]; ok {
	r.Family = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_elasticache_parameter_groupHandler ...
type Aws_elasticache_parameter_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elasticache_parameter_groupHandler) Create(desired *Aws_elasticache_parameter_group) (*Aws_elasticache_parameter_group, string, error) {
	rState := Aws_elasticache_parameter_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elasticache_parameter_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elasticache_parameter_groupHandler) Read(externalID string) (*Aws_elasticache_parameter_group, error) {
	actual, err := bridge.Read(h.provider, "aws_elasticache_parameter_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elasticache_parameter_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elasticache_parameter_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elasticache_parameter_group", externalID)
}

type Aws_launch_template struct {
     Aws_launch_template_id *string
     Disable_api_termination *bool
     Instance_type *string
     Image_id *string
     Instance_initiated_shutdown_behavior *string
     Key_name *string
     Ram_disk_id *string
     Name *string
     Name_prefix *string
     Description *string
     Ebs_optimized *string
     Kernel_id *string
     Arn *string
     User_data *string
     Tags *map[string]string
}


func Aws_launch_templateMapper(r *Aws_launch_template) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Disable_api_termination != nil {
    config["disable_api_termination"] = *r.Disable_api_termination
}
if r.Instance_type != nil {
    config["instance_type"] = *r.Instance_type
}
if r.Image_id != nil {
    config["image_id"] = *r.Image_id
}
if r.Instance_initiated_shutdown_behavior != nil {
    config["instance_initiated_shutdown_behavior"] = *r.Instance_initiated_shutdown_behavior
}
if r.Key_name != nil {
    config["key_name"] = *r.Key_name
}
if r.Ram_disk_id != nil {
    config["ram_disk_id"] = *r.Ram_disk_id
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Ebs_optimized != nil {
    config["ebs_optimized"] = *r.Ebs_optimized
}
if r.Kernel_id != nil {
    config["kernel_id"] = *r.Kernel_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.User_data != nil {
    config["user_data"] = *r.User_data
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_launch_templateUnmapper(state map[string]interface{}) *Aws_launch_template {
	r := &Aws_launch_template{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_launch_template_id = &x
}

if x, ok := state["disable_api_termination"]; ok {
	x := x.(bool)
	r.Disable_api_termination = &x
}

if x, ok := state["instance_type"]; ok {
	x := x.(string)
	r.Instance_type = &x
}

if x, ok := state["image_id"]; ok {
	x := x.(string)
	r.Image_id = &x
}

if x, ok := state["instance_initiated_shutdown_behavior"]; ok {
	x := x.(string)
	r.Instance_initiated_shutdown_behavior = &x
}

if x, ok := state["key_name"]; ok {
	x := x.(string)
	r.Key_name = &x
}

if x, ok := state["ram_disk_id"]; ok {
	x := x.(string)
	r.Ram_disk_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["ebs_optimized"]; ok {
	x := x.(string)
	r.Ebs_optimized = &x
}

if x, ok := state["kernel_id"]; ok {
	x := x.(string)
	r.Kernel_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["user_data"]; ok {
	x := x.(string)
	r.User_data = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_launch_templateHandler ...
type Aws_launch_templateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_launch_templateHandler) Create(desired *Aws_launch_template) (*Aws_launch_template, string, error) {
	rState := Aws_launch_templateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_launch_template", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_launch_templateHandler) Read(externalID string) (*Aws_launch_template, error) {
	actual, err := bridge.Read(h.provider, "aws_launch_template", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_launch_templateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_launch_templateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_launch_template", externalID)
}

type Aws_storagegateway_cached_iscsi_volume struct {
     Aws_storagegateway_cached_iscsi_volume_id *string
     Snapshot_id *string
     Volume_arn *string
     Arn *string
     Chap_enabled *bool
     Gateway_arn string
     Network_interface_id string
     Source_volume_arn *string
     Target_arn *string
     Target_name string
     Volume_id *string
}


func Aws_storagegateway_cached_iscsi_volumeMapper(r *Aws_storagegateway_cached_iscsi_volume) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Snapshot_id != nil {
    config["snapshot_id"] = *r.Snapshot_id
}
    config["target_name"] = r.Target_name
if r.Volume_arn != nil {
    config["volume_arn"] = *r.Volume_arn
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Chap_enabled != nil {
    config["chap_enabled"] = *r.Chap_enabled
}
    config["gateway_arn"] = r.Gateway_arn
    config["network_interface_id"] = r.Network_interface_id
if r.Source_volume_arn != nil {
    config["source_volume_arn"] = *r.Source_volume_arn
}
if r.Target_arn != nil {
    config["target_arn"] = *r.Target_arn
}
if r.Volume_id != nil {
    config["volume_id"] = *r.Volume_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_storagegateway_cached_iscsi_volumeUnmapper(state map[string]interface{}) *Aws_storagegateway_cached_iscsi_volume {
	r := &Aws_storagegateway_cached_iscsi_volume{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_storagegateway_cached_iscsi_volume_id = &x
}

if x, ok := state["gateway_arn"]; ok {
	r.Gateway_arn = x.(string)
}

if x, ok := state["network_interface_id"]; ok {
	r.Network_interface_id = x.(string)
}

if x, ok := state["source_volume_arn"]; ok {
	x := x.(string)
	r.Source_volume_arn = &x
}

if x, ok := state["target_arn"]; ok {
	x := x.(string)
	r.Target_arn = &x
}

if x, ok := state["target_name"]; ok {
	r.Target_name = x.(string)
}

if x, ok := state["volume_arn"]; ok {
	x := x.(string)
	r.Volume_arn = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["chap_enabled"]; ok {
	x := x.(bool)
	r.Chap_enabled = &x
}

if x, ok := state["volume_id"]; ok {
	x := x.(string)
	r.Volume_id = &x
}

if x, ok := state["snapshot_id"]; ok {
	x := x.(string)
	r.Snapshot_id = &x
}
	return r
}


// Aws_storagegateway_cached_iscsi_volumeHandler ...
type Aws_storagegateway_cached_iscsi_volumeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_storagegateway_cached_iscsi_volumeHandler) Create(desired *Aws_storagegateway_cached_iscsi_volume) (*Aws_storagegateway_cached_iscsi_volume, string, error) {
	rState := Aws_storagegateway_cached_iscsi_volumeMapper(desired)
	id, err := bridge.Create(h.provider, "aws_storagegateway_cached_iscsi_volume", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_storagegateway_cached_iscsi_volumeHandler) Read(externalID string) (*Aws_storagegateway_cached_iscsi_volume, error) {
	actual, err := bridge.Read(h.provider, "aws_storagegateway_cached_iscsi_volume", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_storagegateway_cached_iscsi_volumeUnmapper(actual), nil
}

// Delete ...
func (h *Aws_storagegateway_cached_iscsi_volumeHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_storagegateway_cached_iscsi_volume", externalID)
}

type Aws_subnet struct {
     Aws_subnet_id *string
     Ipv6_cidr_block *string
     Availability_zone *string
     Availability_zone_id *string
     Arn *string
     Owner_id *string
     Vpc_id string
     Map_public_ip_on_launch *bool
     Assign_ipv6_address_on_creation *bool
     Ipv6_cidr_block_association_id *string
     Tags *map[string]string
     Cidr_block string
}


func Aws_subnetMapper(r *Aws_subnet) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["cidr_block"] = r.Cidr_block
if r.Map_public_ip_on_launch != nil {
    config["map_public_ip_on_launch"] = *r.Map_public_ip_on_launch
}
if r.Assign_ipv6_address_on_creation != nil {
    config["assign_ipv6_address_on_creation"] = *r.Assign_ipv6_address_on_creation
}
if r.Ipv6_cidr_block_association_id != nil {
    config["ipv6_cidr_block_association_id"] = *r.Ipv6_cidr_block_association_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
    config["vpc_id"] = r.Vpc_id
if r.Ipv6_cidr_block != nil {
    config["ipv6_cidr_block"] = *r.Ipv6_cidr_block
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Availability_zone_id != nil {
    config["availability_zone_id"] = *r.Availability_zone_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_subnetUnmapper(state map[string]interface{}) *Aws_subnet {
	r := &Aws_subnet{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_subnet_id = &x
}

if x, ok := state["ipv6_cidr_block_association_id"]; ok {
	x := x.(string)
	r.Ipv6_cidr_block_association_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["cidr_block"]; ok {
	r.Cidr_block = x.(string)
}

if x, ok := state["map_public_ip_on_launch"]; ok {
	x := x.(bool)
	r.Map_public_ip_on_launch = &x
}

if x, ok := state["assign_ipv6_address_on_creation"]; ok {
	x := x.(bool)
	r.Assign_ipv6_address_on_creation = &x
}

if x, ok := state["availability_zone_id"]; ok {
	x := x.(string)
	r.Availability_zone_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["ipv6_cidr_block"]; ok {
	x := x.(string)
	r.Ipv6_cidr_block = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}
	return r
}


// Aws_subnetHandler ...
type Aws_subnetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_subnetHandler) Create(desired *Aws_subnet) (*Aws_subnet, string, error) {
	rState := Aws_subnetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_subnet", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_subnetHandler) Read(externalID string) (*Aws_subnet, error) {
	actual, err := bridge.Read(h.provider, "aws_subnet", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_subnetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_subnetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_subnet", externalID)
}

type Aws_vpc struct {
     Aws_vpc_id *string
     Dhcp_options_id *string
     Owner_id *string
     Enable_dns_support *bool
     Assign_generated_ipv6_cidr_block *bool
     Enable_classiclink_dns_support *bool
     Default_security_group_id *string
     Ipv6_cidr_block *string
     Cidr_block string
     Enable_dns_hostnames *bool
     Ipv6_association_id *string
     Arn *string
     Tags *map[string]string
     Main_route_table_id *string
     Default_network_acl_id *string
     Default_route_table_id *string
     Instance_tenancy *string
     Enable_classiclink *bool
}


func Aws_vpcMapper(r *Aws_vpc) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Instance_tenancy != nil {
    config["instance_tenancy"] = *r.Instance_tenancy
}
if r.Enable_classiclink != nil {
    config["enable_classiclink"] = *r.Enable_classiclink
}
if r.Default_route_table_id != nil {
    config["default_route_table_id"] = *r.Default_route_table_id
}
if r.Enable_dns_support != nil {
    config["enable_dns_support"] = *r.Enable_dns_support
}
if r.Assign_generated_ipv6_cidr_block != nil {
    config["assign_generated_ipv6_cidr_block"] = *r.Assign_generated_ipv6_cidr_block
}
if r.Dhcp_options_id != nil {
    config["dhcp_options_id"] = *r.Dhcp_options_id
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
    config["cidr_block"] = r.Cidr_block
if r.Enable_dns_hostnames != nil {
    config["enable_dns_hostnames"] = *r.Enable_dns_hostnames
}
if r.Enable_classiclink_dns_support != nil {
    config["enable_classiclink_dns_support"] = *r.Enable_classiclink_dns_support
}
if r.Default_security_group_id != nil {
    config["default_security_group_id"] = *r.Default_security_group_id
}
if r.Ipv6_cidr_block != nil {
    config["ipv6_cidr_block"] = *r.Ipv6_cidr_block
}
if r.Main_route_table_id != nil {
    config["main_route_table_id"] = *r.Main_route_table_id
}
if r.Default_network_acl_id != nil {
    config["default_network_acl_id"] = *r.Default_network_acl_id
}
if r.Ipv6_association_id != nil {
    config["ipv6_association_id"] = *r.Ipv6_association_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpcUnmapper(state map[string]interface{}) *Aws_vpc {
	r := &Aws_vpc{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_id = &x
}

if x, ok := state["instance_tenancy"]; ok {
	x := x.(string)
	r.Instance_tenancy = &x
}

if x, ok := state["enable_classiclink"]; ok {
	x := x.(bool)
	r.Enable_classiclink = &x
}

if x, ok := state["default_route_table_id"]; ok {
	x := x.(string)
	r.Default_route_table_id = &x
}

if x, ok := state["enable_dns_support"]; ok {
	x := x.(bool)
	r.Enable_dns_support = &x
}

if x, ok := state["assign_generated_ipv6_cidr_block"]; ok {
	x := x.(bool)
	r.Assign_generated_ipv6_cidr_block = &x
}

if x, ok := state["dhcp_options_id"]; ok {
	x := x.(string)
	r.Dhcp_options_id = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["cidr_block"]; ok {
	r.Cidr_block = x.(string)
}

if x, ok := state["enable_dns_hostnames"]; ok {
	x := x.(bool)
	r.Enable_dns_hostnames = &x
}

if x, ok := state["enable_classiclink_dns_support"]; ok {
	x := x.(bool)
	r.Enable_classiclink_dns_support = &x
}

if x, ok := state["default_security_group_id"]; ok {
	x := x.(string)
	r.Default_security_group_id = &x
}

if x, ok := state["ipv6_cidr_block"]; ok {
	x := x.(string)
	r.Ipv6_cidr_block = &x
}

if x, ok := state["main_route_table_id"]; ok {
	x := x.(string)
	r.Main_route_table_id = &x
}

if x, ok := state["default_network_acl_id"]; ok {
	x := x.(string)
	r.Default_network_acl_id = &x
}

if x, ok := state["ipv6_association_id"]; ok {
	x := x.(string)
	r.Ipv6_association_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_vpcHandler ...
type Aws_vpcHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpcHandler) Create(desired *Aws_vpc) (*Aws_vpc, string, error) {
	rState := Aws_vpcMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpcHandler) Read(externalID string) (*Aws_vpc, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpcUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpcHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc", externalID)
}

type Aws_api_gateway_api_key struct {
     Aws_api_gateway_api_key_id *string
     Name string
     Description *string
     Enabled *bool
     Created_date *string
     Last_updated_date *string
     Value *string
}


func Aws_api_gateway_api_keyMapper(r *Aws_api_gateway_api_key) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
if r.Last_updated_date != nil {
    config["last_updated_date"] = *r.Last_updated_date
}
if r.Value != nil {
    config["value"] = *r.Value
}
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_api_keyUnmapper(state map[string]interface{}) *Aws_api_gateway_api_key {
	r := &Aws_api_gateway_api_key{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_api_key_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}

if x, ok := state["last_updated_date"]; ok {
	x := x.(string)
	r.Last_updated_date = &x
}

if x, ok := state["value"]; ok {
	x := x.(string)
	r.Value = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_api_gateway_api_keyHandler ...
type Aws_api_gateway_api_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_api_keyHandler) Create(desired *Aws_api_gateway_api_key) (*Aws_api_gateway_api_key, string, error) {
	rState := Aws_api_gateway_api_keyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_api_key", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_api_keyHandler) Read(externalID string) (*Aws_api_gateway_api_key, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_api_key", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_api_keyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_api_keyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_api_key", externalID)
}

type Aws_opsworks_user_profile struct {
     Aws_opsworks_user_profile_id *string
     Allow_self_management *bool
     Ssh_username string
     Ssh_public_key *string
     User_arn string
}


func Aws_opsworks_user_profileMapper(r *Aws_opsworks_user_profile) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["user_arn"] = r.User_arn
if r.Allow_self_management != nil {
    config["allow_self_management"] = *r.Allow_self_management
}
    config["ssh_username"] = r.Ssh_username
if r.Ssh_public_key != nil {
    config["ssh_public_key"] = *r.Ssh_public_key
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_user_profileUnmapper(state map[string]interface{}) *Aws_opsworks_user_profile {
	r := &Aws_opsworks_user_profile{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_user_profile_id = &x
}

if x, ok := state["user_arn"]; ok {
	r.User_arn = x.(string)
}

if x, ok := state["allow_self_management"]; ok {
	x := x.(bool)
	r.Allow_self_management = &x
}

if x, ok := state["ssh_username"]; ok {
	r.Ssh_username = x.(string)
}

if x, ok := state["ssh_public_key"]; ok {
	x := x.(string)
	r.Ssh_public_key = &x
}
	return r
}


// Aws_opsworks_user_profileHandler ...
type Aws_opsworks_user_profileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_user_profileHandler) Create(desired *Aws_opsworks_user_profile) (*Aws_opsworks_user_profile, string, error) {
	rState := Aws_opsworks_user_profileMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_user_profile", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_user_profileHandler) Read(externalID string) (*Aws_opsworks_user_profile, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_user_profile", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_user_profileUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_user_profileHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_user_profile", externalID)
}

type Aws_ssm_activation struct {
     Aws_ssm_activation_id *string
     Name *string
     Description *string
     Expired *string
     Expiration_date *string
     Iam_role string
     Activation_code *string
}


func Aws_ssm_activationMapper(r *Aws_ssm_activation) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["iam_role"] = r.Iam_role
if r.Activation_code != nil {
    config["activation_code"] = *r.Activation_code
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Expired != nil {
    config["expired"] = *r.Expired
}
if r.Expiration_date != nil {
    config["expiration_date"] = *r.Expiration_date
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_activationUnmapper(state map[string]interface{}) *Aws_ssm_activation {
	r := &Aws_ssm_activation{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_activation_id = &x
}

if x, ok := state["activation_code"]; ok {
	x := x.(string)
	r.Activation_code = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["expired"]; ok {
	x := x.(string)
	r.Expired = &x
}

if x, ok := state["expiration_date"]; ok {
	x := x.(string)
	r.Expiration_date = &x
}

if x, ok := state["iam_role"]; ok {
	r.Iam_role = x.(string)
}
	return r
}


// Aws_ssm_activationHandler ...
type Aws_ssm_activationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_activationHandler) Create(desired *Aws_ssm_activation) (*Aws_ssm_activation, string, error) {
	rState := Aws_ssm_activationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_activation", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_activationHandler) Read(externalID string) (*Aws_ssm_activation, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_activation", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_activationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_activationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_activation", externalID)
}

type Aws_wafregional_xss_match_set struct {
     Aws_wafregional_xss_match_set_id *string
     Name string
}


func Aws_wafregional_xss_match_setMapper(r *Aws_wafregional_xss_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_xss_match_setUnmapper(state map[string]interface{}) *Aws_wafregional_xss_match_set {
	r := &Aws_wafregional_xss_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_xss_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_wafregional_xss_match_setHandler ...
type Aws_wafregional_xss_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_xss_match_setHandler) Create(desired *Aws_wafregional_xss_match_set) (*Aws_wafregional_xss_match_set, string, error) {
	rState := Aws_wafregional_xss_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_xss_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_xss_match_setHandler) Read(externalID string) (*Aws_wafregional_xss_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_xss_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_xss_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_xss_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_xss_match_set", externalID)
}

type Aws_cloudwatch_event_rule struct {
     Aws_cloudwatch_event_rule_id *string
     Event_pattern *string
     Description *string
     Role_arn *string
     Is_enabled *bool
     Arn *string
     Name *string
     Name_prefix *string
     Schedule_expression *string
}


func Aws_cloudwatch_event_ruleMapper(r *Aws_cloudwatch_event_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Schedule_expression != nil {
    config["schedule_expression"] = *r.Schedule_expression
}
if r.Event_pattern != nil {
    config["event_pattern"] = *r.Event_pattern
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Role_arn != nil {
    config["role_arn"] = *r.Role_arn
}
if r.Is_enabled != nil {
    config["is_enabled"] = *r.Is_enabled
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_event_ruleUnmapper(state map[string]interface{}) *Aws_cloudwatch_event_rule {
	r := &Aws_cloudwatch_event_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_event_rule_id = &x
}

if x, ok := state["schedule_expression"]; ok {
	x := x.(string)
	r.Schedule_expression = &x
}

if x, ok := state["event_pattern"]; ok {
	x := x.(string)
	r.Event_pattern = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["role_arn"]; ok {
	x := x.(string)
	r.Role_arn = &x
}

if x, ok := state["is_enabled"]; ok {
	x := x.(bool)
	r.Is_enabled = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}
	return r
}


// Aws_cloudwatch_event_ruleHandler ...
type Aws_cloudwatch_event_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_event_ruleHandler) Create(desired *Aws_cloudwatch_event_rule) (*Aws_cloudwatch_event_rule, string, error) {
	rState := Aws_cloudwatch_event_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_event_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_event_ruleHandler) Read(externalID string) (*Aws_cloudwatch_event_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_event_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_event_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_event_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_event_rule", externalID)
}

type Aws_s3_bucket_object struct {
     Aws_s3_bucket_object_id *string
     Server_side_encryption *string
     Etag *string
     Content_encoding *string
     Content_base64 *string
     Kms_key_id *string
     Website_redirect *string
     Tags *map[string]string
     Content_language *string
     Content_type *string
     Source *string
     Version_id *string
     Content_disposition *string
     Content *string
     Storage_class *string
     Bucket string
     Key string
     Acl *string
     Cache_control *string
}


func Aws_s3_bucket_objectMapper(r *Aws_s3_bucket_object) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Content_language != nil {
    config["content_language"] = *r.Content_language
}
if r.Content_type != nil {
    config["content_type"] = *r.Content_type
}
if r.Source != nil {
    config["source"] = *r.Source
}
if r.Version_id != nil {
    config["version_id"] = *r.Version_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["bucket"] = r.Bucket
    config["key"] = r.Key
if r.Acl != nil {
    config["acl"] = *r.Acl
}
if r.Cache_control != nil {
    config["cache_control"] = *r.Cache_control
}
if r.Content_disposition != nil {
    config["content_disposition"] = *r.Content_disposition
}
if r.Content != nil {
    config["content"] = *r.Content
}
if r.Storage_class != nil {
    config["storage_class"] = *r.Storage_class
}
if r.Server_side_encryption != nil {
    config["server_side_encryption"] = *r.Server_side_encryption
}
if r.Etag != nil {
    config["etag"] = *r.Etag
}
if r.Content_encoding != nil {
    config["content_encoding"] = *r.Content_encoding
}
if r.Content_base64 != nil {
    config["content_base64"] = *r.Content_base64
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Website_redirect != nil {
    config["website_redirect"] = *r.Website_redirect
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_s3_bucket_objectUnmapper(state map[string]interface{}) *Aws_s3_bucket_object {
	r := &Aws_s3_bucket_object{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_s3_bucket_object_id = &x
}

if x, ok := state["server_side_encryption"]; ok {
	x := x.(string)
	r.Server_side_encryption = &x
}

if x, ok := state["etag"]; ok {
	x := x.(string)
	r.Etag = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["website_redirect"]; ok {
	x := x.(string)
	r.Website_redirect = &x
}

if x, ok := state["content_encoding"]; ok {
	x := x.(string)
	r.Content_encoding = &x
}

if x, ok := state["content_base64"]; ok {
	x := x.(string)
	r.Content_base64 = &x
}

if x, ok := state["source"]; ok {
	x := x.(string)
	r.Source = &x
}

if x, ok := state["version_id"]; ok {
	x := x.(string)
	r.Version_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["content_language"]; ok {
	x := x.(string)
	r.Content_language = &x
}

if x, ok := state["content_type"]; ok {
	x := x.(string)
	r.Content_type = &x
}

if x, ok := state["acl"]; ok {
	x := x.(string)
	r.Acl = &x
}

if x, ok := state["cache_control"]; ok {
	x := x.(string)
	r.Cache_control = &x
}

if x, ok := state["content_disposition"]; ok {
	x := x.(string)
	r.Content_disposition = &x
}

if x, ok := state["content"]; ok {
	x := x.(string)
	r.Content = &x
}

if x, ok := state["storage_class"]; ok {
	x := x.(string)
	r.Storage_class = &x
}

if x, ok := state["bucket"]; ok {
	r.Bucket = x.(string)
}

if x, ok := state["key"]; ok {
	r.Key = x.(string)
}
	return r
}


// Aws_s3_bucket_objectHandler ...
type Aws_s3_bucket_objectHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_s3_bucket_objectHandler) Create(desired *Aws_s3_bucket_object) (*Aws_s3_bucket_object, string, error) {
	rState := Aws_s3_bucket_objectMapper(desired)
	id, err := bridge.Create(h.provider, "aws_s3_bucket_object", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_s3_bucket_objectHandler) Read(externalID string) (*Aws_s3_bucket_object, error) {
	actual, err := bridge.Read(h.provider, "aws_s3_bucket_object", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_s3_bucket_objectUnmapper(actual), nil
}

// Delete ...
func (h *Aws_s3_bucket_objectHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_s3_bucket_object", externalID)
}

type Aws_kms_key struct {
     Aws_kms_key_id *string
     Arn *string
     Key_id *string
     Is_enabled *bool
     Description *string
     Key_usage *string
     Policy *string
     Enable_key_rotation *bool
     Tags *map[string]string
}


func Aws_kms_keyMapper(r *Aws_kms_key) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Policy != nil {
    config["policy"] = *r.Policy
}
if r.Enable_key_rotation != nil {
    config["enable_key_rotation"] = *r.Enable_key_rotation
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Key_usage != nil {
    config["key_usage"] = *r.Key_usage
}
if r.Is_enabled != nil {
    config["is_enabled"] = *r.Is_enabled
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Key_id != nil {
    config["key_id"] = *r.Key_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_kms_keyUnmapper(state map[string]interface{}) *Aws_kms_key {
	r := &Aws_kms_key{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_kms_key_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["key_usage"]; ok {
	x := x.(string)
	r.Key_usage = &x
}

if x, ok := state["policy"]; ok {
	x := x.(string)
	r.Policy = &x
}

if x, ok := state["enable_key_rotation"]; ok {
	x := x.(bool)
	r.Enable_key_rotation = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["key_id"]; ok {
	x := x.(string)
	r.Key_id = &x
}

if x, ok := state["is_enabled"]; ok {
	x := x.(bool)
	r.Is_enabled = &x
}
	return r
}


// Aws_kms_keyHandler ...
type Aws_kms_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_kms_keyHandler) Create(desired *Aws_kms_key) (*Aws_kms_key, string, error) {
	rState := Aws_kms_keyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_kms_key", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_kms_keyHandler) Read(externalID string) (*Aws_kms_key, error) {
	actual, err := bridge.Read(h.provider, "aws_kms_key", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_kms_keyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_kms_keyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_kms_key", externalID)
}

type Aws_simpledb_domain struct {
     Aws_simpledb_domain_id *string
     Name string
}


func Aws_simpledb_domainMapper(r *Aws_simpledb_domain) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_simpledb_domainUnmapper(state map[string]interface{}) *Aws_simpledb_domain {
	r := &Aws_simpledb_domain{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_simpledb_domain_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_simpledb_domainHandler ...
type Aws_simpledb_domainHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_simpledb_domainHandler) Create(desired *Aws_simpledb_domain) (*Aws_simpledb_domain, string, error) {
	rState := Aws_simpledb_domainMapper(desired)
	id, err := bridge.Create(h.provider, "aws_simpledb_domain", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_simpledb_domainHandler) Read(externalID string) (*Aws_simpledb_domain, error) {
	actual, err := bridge.Read(h.provider, "aws_simpledb_domain", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_simpledb_domainUnmapper(actual), nil
}

// Delete ...
func (h *Aws_simpledb_domainHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_simpledb_domain", externalID)
}

type Aws_autoscaling_lifecycle_hook struct {
     Aws_autoscaling_lifecycle_hook_id *string
     Autoscaling_group_name string
     Default_result *string
     Lifecycle_transition string
     Notification_metadata *string
     Notification_target_arn *string
     Role_arn *string
     Name string
}


func Aws_autoscaling_lifecycle_hookMapper(r *Aws_autoscaling_lifecycle_hook) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Notification_target_arn != nil {
    config["notification_target_arn"] = *r.Notification_target_arn
}
if r.Role_arn != nil {
    config["role_arn"] = *r.Role_arn
}
    config["name"] = r.Name
    config["autoscaling_group_name"] = r.Autoscaling_group_name
if r.Default_result != nil {
    config["default_result"] = *r.Default_result
}
    config["lifecycle_transition"] = r.Lifecycle_transition
if r.Notification_metadata != nil {
    config["notification_metadata"] = *r.Notification_metadata
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_autoscaling_lifecycle_hookUnmapper(state map[string]interface{}) *Aws_autoscaling_lifecycle_hook {
	r := &Aws_autoscaling_lifecycle_hook{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_autoscaling_lifecycle_hook_id = &x
}

if x, ok := state["lifecycle_transition"]; ok {
	r.Lifecycle_transition = x.(string)
}

if x, ok := state["notification_metadata"]; ok {
	x := x.(string)
	r.Notification_metadata = &x
}

if x, ok := state["notification_target_arn"]; ok {
	x := x.(string)
	r.Notification_target_arn = &x
}

if x, ok := state["role_arn"]; ok {
	x := x.(string)
	r.Role_arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["autoscaling_group_name"]; ok {
	r.Autoscaling_group_name = x.(string)
}

if x, ok := state["default_result"]; ok {
	x := x.(string)
	r.Default_result = &x
}
	return r
}


// Aws_autoscaling_lifecycle_hookHandler ...
type Aws_autoscaling_lifecycle_hookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_autoscaling_lifecycle_hookHandler) Create(desired *Aws_autoscaling_lifecycle_hook) (*Aws_autoscaling_lifecycle_hook, string, error) {
	rState := Aws_autoscaling_lifecycle_hookMapper(desired)
	id, err := bridge.Create(h.provider, "aws_autoscaling_lifecycle_hook", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_autoscaling_lifecycle_hookHandler) Read(externalID string) (*Aws_autoscaling_lifecycle_hook, error) {
	actual, err := bridge.Read(h.provider, "aws_autoscaling_lifecycle_hook", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_autoscaling_lifecycle_hookUnmapper(actual), nil
}

// Delete ...
func (h *Aws_autoscaling_lifecycle_hookHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_autoscaling_lifecycle_hook", externalID)
}

type Aws_iam_user_policy struct {
     Aws_iam_user_policy_id *string
     Policy string
     Name *string
     Name_prefix *string
     User string
}


func Aws_iam_user_policyMapper(r *Aws_iam_user_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["user"] = r.User
    config["policy"] = r.Policy
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_user_policyUnmapper(state map[string]interface{}) *Aws_iam_user_policy {
	r := &Aws_iam_user_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_user_policy_id = &x
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["user"]; ok {
	r.User = x.(string)
}
	return r
}


// Aws_iam_user_policyHandler ...
type Aws_iam_user_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_user_policyHandler) Create(desired *Aws_iam_user_policy) (*Aws_iam_user_policy, string, error) {
	rState := Aws_iam_user_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_user_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_user_policyHandler) Read(externalID string) (*Aws_iam_user_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_user_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_user_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_user_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_user_policy", externalID)
}

type Aws_iam_service_linked_role struct {
     Aws_iam_service_linked_role_id *string
     Description *string
     Aws_service_name string
     Name *string
     Path *string
     Arn *string
     Create_date *string
     Unique_id *string
     Custom_suffix *string
}


func Aws_iam_service_linked_roleMapper(r *Aws_iam_service_linked_role) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Create_date != nil {
    config["create_date"] = *r.Create_date
}
if r.Unique_id != nil {
    config["unique_id"] = *r.Unique_id
}
if r.Custom_suffix != nil {
    config["custom_suffix"] = *r.Custom_suffix
}
if r.Description != nil {
    config["description"] = *r.Description
}
    config["aws_service_name"] = r.Aws_service_name
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Path != nil {
    config["path"] = *r.Path
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_service_linked_roleUnmapper(state map[string]interface{}) *Aws_iam_service_linked_role {
	r := &Aws_iam_service_linked_role{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_service_linked_role_id = &x
}

if x, ok := state["unique_id"]; ok {
	x := x.(string)
	r.Unique_id = &x
}

if x, ok := state["custom_suffix"]; ok {
	x := x.(string)
	r.Custom_suffix = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["aws_service_name"]; ok {
	r.Aws_service_name = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["path"]; ok {
	x := x.(string)
	r.Path = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["create_date"]; ok {
	x := x.(string)
	r.Create_date = &x
}
	return r
}


// Aws_iam_service_linked_roleHandler ...
type Aws_iam_service_linked_roleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_service_linked_roleHandler) Create(desired *Aws_iam_service_linked_role) (*Aws_iam_service_linked_role, string, error) {
	rState := Aws_iam_service_linked_roleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_service_linked_role", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_service_linked_roleHandler) Read(externalID string) (*Aws_iam_service_linked_role, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_service_linked_role", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_service_linked_roleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_service_linked_roleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_service_linked_role", externalID)
}

type Aws_storagegateway_working_storage struct {
     Aws_storagegateway_working_storage_id *string
     Disk_id string
     Gateway_arn string
}


func Aws_storagegateway_working_storageMapper(r *Aws_storagegateway_working_storage) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["disk_id"] = r.Disk_id
    config["gateway_arn"] = r.Gateway_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_storagegateway_working_storageUnmapper(state map[string]interface{}) *Aws_storagegateway_working_storage {
	r := &Aws_storagegateway_working_storage{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_storagegateway_working_storage_id = &x
}

if x, ok := state["gateway_arn"]; ok {
	r.Gateway_arn = x.(string)
}

if x, ok := state["disk_id"]; ok {
	r.Disk_id = x.(string)
}
	return r
}


// Aws_storagegateway_working_storageHandler ...
type Aws_storagegateway_working_storageHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_storagegateway_working_storageHandler) Create(desired *Aws_storagegateway_working_storage) (*Aws_storagegateway_working_storage, string, error) {
	rState := Aws_storagegateway_working_storageMapper(desired)
	id, err := bridge.Create(h.provider, "aws_storagegateway_working_storage", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_storagegateway_working_storageHandler) Read(externalID string) (*Aws_storagegateway_working_storage, error) {
	actual, err := bridge.Read(h.provider, "aws_storagegateway_working_storage", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_storagegateway_working_storageUnmapper(actual), nil
}

// Delete ...
func (h *Aws_storagegateway_working_storageHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_storagegateway_working_storage", externalID)
}

type Aws_api_gateway_vpc_link struct {
     Aws_api_gateway_vpc_link_id *string
     Name string
     Description *string
}


func Aws_api_gateway_vpc_linkMapper(r *Aws_api_gateway_vpc_link) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_vpc_linkUnmapper(state map[string]interface{}) *Aws_api_gateway_vpc_link {
	r := &Aws_api_gateway_vpc_link{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_vpc_link_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_api_gateway_vpc_linkHandler ...
type Aws_api_gateway_vpc_linkHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_vpc_linkHandler) Create(desired *Aws_api_gateway_vpc_link) (*Aws_api_gateway_vpc_link, string, error) {
	rState := Aws_api_gateway_vpc_linkMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_vpc_link", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_vpc_linkHandler) Read(externalID string) (*Aws_api_gateway_vpc_link, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_vpc_link", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_vpc_linkUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_vpc_linkHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_vpc_link", externalID)
}

type Aws_datasync_location_nfs struct {
     Aws_datasync_location_nfs_id *string
     Arn *string
     Server_hostname string
     Subdirectory string
     Tags *map[string]string
     Uri *string
}


func Aws_datasync_location_nfsMapper(r *Aws_datasync_location_nfs) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["server_hostname"] = r.Server_hostname
    config["subdirectory"] = r.Subdirectory
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Uri != nil {
    config["uri"] = *r.Uri
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_datasync_location_nfsUnmapper(state map[string]interface{}) *Aws_datasync_location_nfs {
	r := &Aws_datasync_location_nfs{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_datasync_location_nfs_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["server_hostname"]; ok {
	r.Server_hostname = x.(string)
}

if x, ok := state["subdirectory"]; ok {
	r.Subdirectory = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["uri"]; ok {
	x := x.(string)
	r.Uri = &x
}
	return r
}


// Aws_datasync_location_nfsHandler ...
type Aws_datasync_location_nfsHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_datasync_location_nfsHandler) Create(desired *Aws_datasync_location_nfs) (*Aws_datasync_location_nfs, string, error) {
	rState := Aws_datasync_location_nfsMapper(desired)
	id, err := bridge.Create(h.provider, "aws_datasync_location_nfs", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_datasync_location_nfsHandler) Read(externalID string) (*Aws_datasync_location_nfs, error) {
	actual, err := bridge.Read(h.provider, "aws_datasync_location_nfs", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_datasync_location_nfsUnmapper(actual), nil
}

// Delete ...
func (h *Aws_datasync_location_nfsHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_datasync_location_nfs", externalID)
}

type Aws_opsworks_nodejs_app_layer struct {
     Aws_opsworks_nodejs_app_layer_id *string
     Custom_json *string
     Install_updates_on_boot *bool
     Name *string
     Auto_assign_elastic_ips *bool
     Stack_id string
     Use_ebs_optimized_instances *bool
     Nodejs_version *string
     Elastic_load_balancer *string
     Custom_instance_profile_arn *string
     Auto_healing *bool
     Drain_elb_on_shutdown *bool
     Auto_assign_public_ips *bool
}


func Aws_opsworks_nodejs_app_layerMapper(r *Aws_opsworks_nodejs_app_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
    config["stack_id"] = r.Stack_id
if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
if r.Nodejs_version != nil {
    config["nodejs_version"] = *r.Nodejs_version
}
if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_nodejs_app_layerUnmapper(state map[string]interface{}) *Aws_opsworks_nodejs_app_layer {
	r := &Aws_opsworks_nodejs_app_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_nodejs_app_layer_id = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["nodejs_version"]; ok {
	x := x.(string)
	r.Nodejs_version = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}
	return r
}


// Aws_opsworks_nodejs_app_layerHandler ...
type Aws_opsworks_nodejs_app_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_nodejs_app_layerHandler) Create(desired *Aws_opsworks_nodejs_app_layer) (*Aws_opsworks_nodejs_app_layer, string, error) {
	rState := Aws_opsworks_nodejs_app_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_nodejs_app_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_nodejs_app_layerHandler) Read(externalID string) (*Aws_opsworks_nodejs_app_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_nodejs_app_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_nodejs_app_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_nodejs_app_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_nodejs_app_layer", externalID)
}

type Aws_spot_instance_request struct {
     Aws_spot_instance_request_id *string
     Spot_type *string
     Ami string
     Arn *string
     Instance_state *string
     Spot_request_state *string
     Associate_public_ip_address *bool
     Network_interface_id *string
     Disable_api_termination *bool
     Iam_instance_profile *string
     Volume_tags *map[string]string
     Spot_price *string
     Spot_bid_status *string
     Instance_type string
     User_data *string
     Valid_until *string
     Wait_for_fulfillment *bool
     Launch_group *string
     Availability_zone *string
     Private_ip *string
     Monitoring *bool
     Tenancy *string
     Valid_from *string
     Source_dest_check *bool
     Private_dns *string
     Block_device *map[string]string
     Spot_instance_id *string
     Placement_group *string
     Public_dns *string
     Password_data *string
     Primary_network_interface_id *string
     Public_ip *string
     Tags *map[string]string
     Key_name *string
     Get_password_data *bool
     Ebs_optimized *bool
     Instance_initiated_shutdown_behavior *string
     Host_id *string
     Instance_interruption_behaviour *string
     Subnet_id *string
     User_data_base64 *string
}


func Aws_spot_instance_requestMapper(r *Aws_spot_instance_request) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Monitoring != nil {
    config["monitoring"] = *r.Monitoring
}
if r.Tenancy != nil {
    config["tenancy"] = *r.Tenancy
}
if r.Valid_from != nil {
    config["valid_from"] = *r.Valid_from
}
if r.Source_dest_check != nil {
    config["source_dest_check"] = *r.Source_dest_check
}
if r.Public_dns != nil {
    config["public_dns"] = *r.Public_dns
}
if r.Private_dns != nil {
    config["private_dns"] = *r.Private_dns
}
if r.Block_device != nil {
    config["block_device"] = *r.Block_device
}
if r.Spot_instance_id != nil {
    config["spot_instance_id"] = *r.Spot_instance_id
}
if r.Placement_group != nil {
    config["placement_group"] = *r.Placement_group
}
if r.Get_password_data != nil {
    config["get_password_data"] = *r.Get_password_data
}
if r.Password_data != nil {
    config["password_data"] = *r.Password_data
}
if r.Primary_network_interface_id != nil {
    config["primary_network_interface_id"] = *r.Primary_network_interface_id
}
if r.Public_ip != nil {
    config["public_ip"] = *r.Public_ip
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Key_name != nil {
    config["key_name"] = *r.Key_name
}
if r.User_data_base64 != nil {
    config["user_data_base64"] = *r.User_data_base64
}
if r.Ebs_optimized != nil {
    config["ebs_optimized"] = *r.Ebs_optimized
}
if r.Instance_initiated_shutdown_behavior != nil {
    config["instance_initiated_shutdown_behavior"] = *r.Instance_initiated_shutdown_behavior
}
if r.Host_id != nil {
    config["host_id"] = *r.Host_id
}
if r.Instance_interruption_behaviour != nil {
    config["instance_interruption_behaviour"] = *r.Instance_interruption_behaviour
}
if r.Subnet_id != nil {
    config["subnet_id"] = *r.Subnet_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Spot_type != nil {
    config["spot_type"] = *r.Spot_type
}
    config["ami"] = r.Ami
if r.Instance_state != nil {
    config["instance_state"] = *r.Instance_state
}
if r.Spot_request_state != nil {
    config["spot_request_state"] = *r.Spot_request_state
}
if r.Associate_public_ip_address != nil {
    config["associate_public_ip_address"] = *r.Associate_public_ip_address
}
if r.User_data != nil {
    config["user_data"] = *r.User_data
}
if r.Network_interface_id != nil {
    config["network_interface_id"] = *r.Network_interface_id
}
if r.Disable_api_termination != nil {
    config["disable_api_termination"] = *r.Disable_api_termination
}
if r.Iam_instance_profile != nil {
    config["iam_instance_profile"] = *r.Iam_instance_profile
}
if r.Volume_tags != nil {
    config["volume_tags"] = *r.Volume_tags
}
if r.Spot_price != nil {
    config["spot_price"] = *r.Spot_price
}
if r.Spot_bid_status != nil {
    config["spot_bid_status"] = *r.Spot_bid_status
}
    config["instance_type"] = r.Instance_type
if r.Valid_until != nil {
    config["valid_until"] = *r.Valid_until
}
if r.Private_ip != nil {
    config["private_ip"] = *r.Private_ip
}
if r.Wait_for_fulfillment != nil {
    config["wait_for_fulfillment"] = *r.Wait_for_fulfillment
}
if r.Launch_group != nil {
    config["launch_group"] = *r.Launch_group
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_spot_instance_requestUnmapper(state map[string]interface{}) *Aws_spot_instance_request {
	r := &Aws_spot_instance_request{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_spot_instance_request_id = &x
}

if x, ok := state["monitoring"]; ok {
	x := x.(bool)
	r.Monitoring = &x
}

if x, ok := state["tenancy"]; ok {
	x := x.(string)
	r.Tenancy = &x
}

if x, ok := state["valid_from"]; ok {
	x := x.(string)
	r.Valid_from = &x
}

if x, ok := state["source_dest_check"]; ok {
	x := x.(bool)
	r.Source_dest_check = &x
}

if x, ok := state["public_dns"]; ok {
	x := x.(string)
	r.Public_dns = &x
}

if x, ok := state["private_dns"]; ok {
	x := x.(string)
	r.Private_dns = &x
}

if x, ok := state["block_device"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Block_device = &x
}

if x, ok := state["spot_instance_id"]; ok {
	x := x.(string)
	r.Spot_instance_id = &x
}

if x, ok := state["placement_group"]; ok {
	x := x.(string)
	r.Placement_group = &x
}

if x, ok := state["get_password_data"]; ok {
	x := x.(bool)
	r.Get_password_data = &x
}

if x, ok := state["password_data"]; ok {
	x := x.(string)
	r.Password_data = &x
}

if x, ok := state["primary_network_interface_id"]; ok {
	x := x.(string)
	r.Primary_network_interface_id = &x
}

if x, ok := state["public_ip"]; ok {
	x := x.(string)
	r.Public_ip = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["key_name"]; ok {
	x := x.(string)
	r.Key_name = &x
}

if x, ok := state["user_data_base64"]; ok {
	x := x.(string)
	r.User_data_base64 = &x
}

if x, ok := state["ebs_optimized"]; ok {
	x := x.(bool)
	r.Ebs_optimized = &x
}

if x, ok := state["instance_initiated_shutdown_behavior"]; ok {
	x := x.(string)
	r.Instance_initiated_shutdown_behavior = &x
}

if x, ok := state["host_id"]; ok {
	x := x.(string)
	r.Host_id = &x
}

if x, ok := state["instance_interruption_behaviour"]; ok {
	x := x.(string)
	r.Instance_interruption_behaviour = &x
}

if x, ok := state["subnet_id"]; ok {
	x := x.(string)
	r.Subnet_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["spot_type"]; ok {
	x := x.(string)
	r.Spot_type = &x
}

if x, ok := state["ami"]; ok {
	r.Ami = x.(string)
}

if x, ok := state["instance_state"]; ok {
	x := x.(string)
	r.Instance_state = &x
}

if x, ok := state["spot_request_state"]; ok {
	x := x.(string)
	r.Spot_request_state = &x
}

if x, ok := state["associate_public_ip_address"]; ok {
	x := x.(bool)
	r.Associate_public_ip_address = &x
}

if x, ok := state["user_data"]; ok {
	x := x.(string)
	r.User_data = &x
}

if x, ok := state["network_interface_id"]; ok {
	x := x.(string)
	r.Network_interface_id = &x
}

if x, ok := state["disable_api_termination"]; ok {
	x := x.(bool)
	r.Disable_api_termination = &x
}

if x, ok := state["iam_instance_profile"]; ok {
	x := x.(string)
	r.Iam_instance_profile = &x
}

if x, ok := state["volume_tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Volume_tags = &x
}

if x, ok := state["spot_price"]; ok {
	x := x.(string)
	r.Spot_price = &x
}

if x, ok := state["spot_bid_status"]; ok {
	x := x.(string)
	r.Spot_bid_status = &x
}

if x, ok := state["instance_type"]; ok {
	r.Instance_type = x.(string)
}

if x, ok := state["valid_until"]; ok {
	x := x.(string)
	r.Valid_until = &x
}

if x, ok := state["private_ip"]; ok {
	x := x.(string)
	r.Private_ip = &x
}

if x, ok := state["wait_for_fulfillment"]; ok {
	x := x.(bool)
	r.Wait_for_fulfillment = &x
}

if x, ok := state["launch_group"]; ok {
	x := x.(string)
	r.Launch_group = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}
	return r
}


// Aws_spot_instance_requestHandler ...
type Aws_spot_instance_requestHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_spot_instance_requestHandler) Create(desired *Aws_spot_instance_request) (*Aws_spot_instance_request, string, error) {
	rState := Aws_spot_instance_requestMapper(desired)
	id, err := bridge.Create(h.provider, "aws_spot_instance_request", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_spot_instance_requestHandler) Read(externalID string) (*Aws_spot_instance_request, error) {
	actual, err := bridge.Read(h.provider, "aws_spot_instance_request", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_spot_instance_requestUnmapper(actual), nil
}

// Delete ...
func (h *Aws_spot_instance_requestHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_spot_instance_request", externalID)
}

type Aws_ami_from_instance struct {
     Aws_ami_from_instance_id *string
     Architecture *string
     Image_location *string
     Name string
     Tags *map[string]string
     Kernel_id *string
     Root_snapshot_id *string
     Sriov_net_support *string
     Source_instance_id string
     Description *string
     Ena_support *bool
     Ramdisk_id *string
     Virtualization_type *string
     Manage_ebs_snapshots *bool
     Root_device_name *string
     Snapshot_without_reboot *bool
}


func Aws_ami_from_instanceMapper(r *Aws_ami_from_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Architecture != nil {
    config["architecture"] = *r.Architecture
}
if r.Image_location != nil {
    config["image_location"] = *r.Image_location
}
    config["name"] = r.Name
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Kernel_id != nil {
    config["kernel_id"] = *r.Kernel_id
}
if r.Root_snapshot_id != nil {
    config["root_snapshot_id"] = *r.Root_snapshot_id
}
if r.Sriov_net_support != nil {
    config["sriov_net_support"] = *r.Sriov_net_support
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Ena_support != nil {
    config["ena_support"] = *r.Ena_support
}
if r.Ramdisk_id != nil {
    config["ramdisk_id"] = *r.Ramdisk_id
}
    config["source_instance_id"] = r.Source_instance_id
if r.Manage_ebs_snapshots != nil {
    config["manage_ebs_snapshots"] = *r.Manage_ebs_snapshots
}
if r.Root_device_name != nil {
    config["root_device_name"] = *r.Root_device_name
}
if r.Snapshot_without_reboot != nil {
    config["snapshot_without_reboot"] = *r.Snapshot_without_reboot
}
if r.Virtualization_type != nil {
    config["virtualization_type"] = *r.Virtualization_type
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ami_from_instanceUnmapper(state map[string]interface{}) *Aws_ami_from_instance {
	r := &Aws_ami_from_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ami_from_instance_id = &x
}

if x, ok := state["architecture"]; ok {
	x := x.(string)
	r.Architecture = &x
}

if x, ok := state["image_location"]; ok {
	x := x.(string)
	r.Image_location = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["kernel_id"]; ok {
	x := x.(string)
	r.Kernel_id = &x
}

if x, ok := state["root_snapshot_id"]; ok {
	x := x.(string)
	r.Root_snapshot_id = &x
}

if x, ok := state["sriov_net_support"]; ok {
	x := x.(string)
	r.Sriov_net_support = &x
}

if x, ok := state["source_instance_id"]; ok {
	r.Source_instance_id = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["ena_support"]; ok {
	x := x.(bool)
	r.Ena_support = &x
}

if x, ok := state["ramdisk_id"]; ok {
	x := x.(string)
	r.Ramdisk_id = &x
}

if x, ok := state["virtualization_type"]; ok {
	x := x.(string)
	r.Virtualization_type = &x
}

if x, ok := state["manage_ebs_snapshots"]; ok {
	x := x.(bool)
	r.Manage_ebs_snapshots = &x
}

if x, ok := state["root_device_name"]; ok {
	x := x.(string)
	r.Root_device_name = &x
}

if x, ok := state["snapshot_without_reboot"]; ok {
	x := x.(bool)
	r.Snapshot_without_reboot = &x
}
	return r
}


// Aws_ami_from_instanceHandler ...
type Aws_ami_from_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ami_from_instanceHandler) Create(desired *Aws_ami_from_instance) (*Aws_ami_from_instance, string, error) {
	rState := Aws_ami_from_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ami_from_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ami_from_instanceHandler) Read(externalID string) (*Aws_ami_from_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_ami_from_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ami_from_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ami_from_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ami_from_instance", externalID)
}

type Aws_iam_group_policy struct {
     Aws_iam_group_policy_id *string
     Policy string
     Name *string
     Name_prefix *string
     Group string
}


func Aws_iam_group_policyMapper(r *Aws_iam_group_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["policy"] = r.Policy
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["group"] = r.Group
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_group_policyUnmapper(state map[string]interface{}) *Aws_iam_group_policy {
	r := &Aws_iam_group_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_group_policy_id = &x
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["group"]; ok {
	r.Group = x.(string)
}
	return r
}


// Aws_iam_group_policyHandler ...
type Aws_iam_group_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_group_policyHandler) Create(desired *Aws_iam_group_policy) (*Aws_iam_group_policy, string, error) {
	rState := Aws_iam_group_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_group_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_group_policyHandler) Read(externalID string) (*Aws_iam_group_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_group_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_group_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_group_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_group_policy", externalID)
}

type Aws_iam_user_policy_attachment struct {
     Aws_iam_user_policy_attachment_id *string
     User string
     Policy_arn string
}


func Aws_iam_user_policy_attachmentMapper(r *Aws_iam_user_policy_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["policy_arn"] = r.Policy_arn
    config["user"] = r.User
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_user_policy_attachmentUnmapper(state map[string]interface{}) *Aws_iam_user_policy_attachment {
	r := &Aws_iam_user_policy_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_user_policy_attachment_id = &x
}

if x, ok := state["user"]; ok {
	r.User = x.(string)
}

if x, ok := state["policy_arn"]; ok {
	r.Policy_arn = x.(string)
}
	return r
}


// Aws_iam_user_policy_attachmentHandler ...
type Aws_iam_user_policy_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_user_policy_attachmentHandler) Create(desired *Aws_iam_user_policy_attachment) (*Aws_iam_user_policy_attachment, string, error) {
	rState := Aws_iam_user_policy_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_user_policy_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_user_policy_attachmentHandler) Read(externalID string) (*Aws_iam_user_policy_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_user_policy_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_user_policy_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_user_policy_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_user_policy_attachment", externalID)
}

type Aws_rds_cluster struct {
     Aws_rds_cluster_id *string
     Cluster_identifier_prefix *string
     Cluster_resource_id *string
     Db_subnet_group_name *string
     Hosted_zone_id *string
     Final_snapshot_identifier *string
     Master_username *string
     Tags *map[string]string
     Apply_immediately *bool
     Kms_key_id *string
     Iam_database_authentication_enabled *bool
     Engine_version *string
     Master_password *string
     Preferred_maintenance_window *string
     Source_region *string
     Cluster_identifier *string
     Global_cluster_identifier *string
     Engine_mode *string
     Db_cluster_parameter_group_name *string
     Reader_endpoint *string
     Storage_encrypted *bool
     Replication_source_identifier *string
     Database_name *string
     Endpoint *string
     Engine *string
     Skip_final_snapshot *bool
     Snapshot_identifier *string
     Preferred_backup_window *string
     Arn *string
     Deletion_protection *bool
}


func Aws_rds_clusterMapper(r *Aws_rds_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Db_cluster_parameter_group_name != nil {
    config["db_cluster_parameter_group_name"] = *r.Db_cluster_parameter_group_name
}
if r.Reader_endpoint != nil {
    config["reader_endpoint"] = *r.Reader_endpoint
}
if r.Storage_encrypted != nil {
    config["storage_encrypted"] = *r.Storage_encrypted
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Replication_source_identifier != nil {
    config["replication_source_identifier"] = *r.Replication_source_identifier
}
if r.Database_name != nil {
    config["database_name"] = *r.Database_name
}
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
if r.Skip_final_snapshot != nil {
    config["skip_final_snapshot"] = *r.Skip_final_snapshot
}
if r.Snapshot_identifier != nil {
    config["snapshot_identifier"] = *r.Snapshot_identifier
}
if r.Preferred_backup_window != nil {
    config["preferred_backup_window"] = *r.Preferred_backup_window
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Deletion_protection != nil {
    config["deletion_protection"] = *r.Deletion_protection
}
if r.Cluster_identifier_prefix != nil {
    config["cluster_identifier_prefix"] = *r.Cluster_identifier_prefix
}
if r.Master_username != nil {
    config["master_username"] = *r.Master_username
}
if r.Cluster_resource_id != nil {
    config["cluster_resource_id"] = *r.Cluster_resource_id
}
if r.Db_subnet_group_name != nil {
    config["db_subnet_group_name"] = *r.Db_subnet_group_name
}
if r.Hosted_zone_id != nil {
    config["hosted_zone_id"] = *r.Hosted_zone_id
}
if r.Final_snapshot_identifier != nil {
    config["final_snapshot_identifier"] = *r.Final_snapshot_identifier
}
if r.Iam_database_authentication_enabled != nil {
    config["iam_database_authentication_enabled"] = *r.Iam_database_authentication_enabled
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Apply_immediately != nil {
    config["apply_immediately"] = *r.Apply_immediately
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Engine_mode != nil {
    config["engine_mode"] = *r.Engine_mode
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Master_password != nil {
    config["master_password"] = *r.Master_password
}
if r.Preferred_maintenance_window != nil {
    config["preferred_maintenance_window"] = *r.Preferred_maintenance_window
}
if r.Source_region != nil {
    config["source_region"] = *r.Source_region
}
if r.Cluster_identifier != nil {
    config["cluster_identifier"] = *r.Cluster_identifier
}
if r.Global_cluster_identifier != nil {
    config["global_cluster_identifier"] = *r.Global_cluster_identifier
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_rds_clusterUnmapper(state map[string]interface{}) *Aws_rds_cluster {
	r := &Aws_rds_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_rds_cluster_id = &x
}

if x, ok := state["db_subnet_group_name"]; ok {
	x := x.(string)
	r.Db_subnet_group_name = &x
}

if x, ok := state["hosted_zone_id"]; ok {
	x := x.(string)
	r.Hosted_zone_id = &x
}

if x, ok := state["final_snapshot_identifier"]; ok {
	x := x.(string)
	r.Final_snapshot_identifier = &x
}

if x, ok := state["master_username"]; ok {
	x := x.(string)
	r.Master_username = &x
}

if x, ok := state["cluster_resource_id"]; ok {
	x := x.(string)
	r.Cluster_resource_id = &x
}

if x, ok := state["apply_immediately"]; ok {
	x := x.(bool)
	r.Apply_immediately = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["iam_database_authentication_enabled"]; ok {
	x := x.(bool)
	r.Iam_database_authentication_enabled = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["cluster_identifier"]; ok {
	x := x.(string)
	r.Cluster_identifier = &x
}

if x, ok := state["global_cluster_identifier"]; ok {
	x := x.(string)
	r.Global_cluster_identifier = &x
}

if x, ok := state["engine_mode"]; ok {
	x := x.(string)
	r.Engine_mode = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["master_password"]; ok {
	x := x.(string)
	r.Master_password = &x
}

if x, ok := state["preferred_maintenance_window"]; ok {
	x := x.(string)
	r.Preferred_maintenance_window = &x
}

if x, ok := state["source_region"]; ok {
	x := x.(string)
	r.Source_region = &x
}

if x, ok := state["db_cluster_parameter_group_name"]; ok {
	x := x.(string)
	r.Db_cluster_parameter_group_name = &x
}

if x, ok := state["reader_endpoint"]; ok {
	x := x.(string)
	r.Reader_endpoint = &x
}

if x, ok := state["storage_encrypted"]; ok {
	x := x.(bool)
	r.Storage_encrypted = &x
}

if x, ok := state["database_name"]; ok {
	x := x.(string)
	r.Database_name = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["replication_source_identifier"]; ok {
	x := x.(string)
	r.Replication_source_identifier = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["deletion_protection"]; ok {
	x := x.(bool)
	r.Deletion_protection = &x
}

if x, ok := state["skip_final_snapshot"]; ok {
	x := x.(bool)
	r.Skip_final_snapshot = &x
}

if x, ok := state["snapshot_identifier"]; ok {
	x := x.(string)
	r.Snapshot_identifier = &x
}

if x, ok := state["preferred_backup_window"]; ok {
	x := x.(string)
	r.Preferred_backup_window = &x
}

if x, ok := state["cluster_identifier_prefix"]; ok {
	x := x.(string)
	r.Cluster_identifier_prefix = &x
}
	return r
}


// Aws_rds_clusterHandler ...
type Aws_rds_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_rds_clusterHandler) Create(desired *Aws_rds_cluster) (*Aws_rds_cluster, string, error) {
	rState := Aws_rds_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_rds_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_rds_clusterHandler) Read(externalID string) (*Aws_rds_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_rds_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_rds_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_rds_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_rds_cluster", externalID)
}

type Aws_appsync_datasource struct {
     Aws_appsync_datasource_id *string
     Name string
     Api_id string
     Description *string
     Service_role_arn *string
     Arn *string
     Resource_type string
}


func Aws_appsync_datasourceMapper(r *Aws_appsync_datasource) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Service_role_arn != nil {
    config["service_role_arn"] = *r.Service_role_arn
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["resource_type"] = r.Resource_type
if r.Description != nil {
    config["description"] = *r.Description
}
    config["api_id"] = r.Api_id
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appsync_datasourceUnmapper(state map[string]interface{}) *Aws_appsync_datasource {
	r := &Aws_appsync_datasource{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appsync_datasource_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["api_id"]; ok {
	r.Api_id = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["service_role_arn"]; ok {
	x := x.(string)
	r.Service_role_arn = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}
	return r
}


// Aws_appsync_datasourceHandler ...
type Aws_appsync_datasourceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appsync_datasourceHandler) Create(desired *Aws_appsync_datasource) (*Aws_appsync_datasource, string, error) {
	rState := Aws_appsync_datasourceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appsync_datasource", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appsync_datasourceHandler) Read(externalID string) (*Aws_appsync_datasource, error) {
	actual, err := bridge.Read(h.provider, "aws_appsync_datasource", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appsync_datasourceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appsync_datasourceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appsync_datasource", externalID)
}

type Aws_codedeploy_deployment_config struct {
     Aws_codedeploy_deployment_config_id *string
     Deployment_config_name string
     Compute_platform *string
     Deployment_config_id *string
}


func Aws_codedeploy_deployment_configMapper(r *Aws_codedeploy_deployment_config) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Compute_platform != nil {
    config["compute_platform"] = *r.Compute_platform
}
if r.Deployment_config_id != nil {
    config["deployment_config_id"] = *r.Deployment_config_id
}
    config["deployment_config_name"] = r.Deployment_config_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_codedeploy_deployment_configUnmapper(state map[string]interface{}) *Aws_codedeploy_deployment_config {
	r := &Aws_codedeploy_deployment_config{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_codedeploy_deployment_config_id = &x
}

if x, ok := state["deployment_config_id"]; ok {
	x := x.(string)
	r.Deployment_config_id = &x
}

if x, ok := state["deployment_config_name"]; ok {
	r.Deployment_config_name = x.(string)
}

if x, ok := state["compute_platform"]; ok {
	x := x.(string)
	r.Compute_platform = &x
}
	return r
}


// Aws_codedeploy_deployment_configHandler ...
type Aws_codedeploy_deployment_configHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_codedeploy_deployment_configHandler) Create(desired *Aws_codedeploy_deployment_config) (*Aws_codedeploy_deployment_config, string, error) {
	rState := Aws_codedeploy_deployment_configMapper(desired)
	id, err := bridge.Create(h.provider, "aws_codedeploy_deployment_config", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_codedeploy_deployment_configHandler) Read(externalID string) (*Aws_codedeploy_deployment_config, error) {
	actual, err := bridge.Read(h.provider, "aws_codedeploy_deployment_config", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_codedeploy_deployment_configUnmapper(actual), nil
}

// Delete ...
func (h *Aws_codedeploy_deployment_configHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_codedeploy_deployment_config", externalID)
}

type Aws_glacier_vault struct {
     Aws_glacier_vault_id *string
     Access_policy *string
     Tags *map[string]string
     Name string
     Location *string
     Arn *string
}


func Aws_glacier_vaultMapper(r *Aws_glacier_vault) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["name"] = r.Name
if r.Location != nil {
    config["location"] = *r.Location
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Access_policy != nil {
    config["access_policy"] = *r.Access_policy
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glacier_vaultUnmapper(state map[string]interface{}) *Aws_glacier_vault {
	r := &Aws_glacier_vault{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glacier_vault_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["location"]; ok {
	x := x.(string)
	r.Location = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["access_policy"]; ok {
	x := x.(string)
	r.Access_policy = &x
}
	return r
}


// Aws_glacier_vaultHandler ...
type Aws_glacier_vaultHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glacier_vaultHandler) Create(desired *Aws_glacier_vault) (*Aws_glacier_vault, string, error) {
	rState := Aws_glacier_vaultMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glacier_vault", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glacier_vaultHandler) Read(externalID string) (*Aws_glacier_vault, error) {
	actual, err := bridge.Read(h.provider, "aws_glacier_vault", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glacier_vaultUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glacier_vaultHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glacier_vault", externalID)
}

type Aws_s3_bucket_inventory struct {
     Aws_s3_bucket_inventory_id *string
     Included_object_versions string
     Bucket string
     Name string
     Enabled *bool
}


func Aws_s3_bucket_inventoryMapper(r *Aws_s3_bucket_inventory) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["included_object_versions"] = r.Included_object_versions
    config["bucket"] = r.Bucket
    config["name"] = r.Name
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_s3_bucket_inventoryUnmapper(state map[string]interface{}) *Aws_s3_bucket_inventory {
	r := &Aws_s3_bucket_inventory{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_s3_bucket_inventory_id = &x
}

if x, ok := state["bucket"]; ok {
	r.Bucket = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["included_object_versions"]; ok {
	r.Included_object_versions = x.(string)
}
	return r
}


// Aws_s3_bucket_inventoryHandler ...
type Aws_s3_bucket_inventoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_s3_bucket_inventoryHandler) Create(desired *Aws_s3_bucket_inventory) (*Aws_s3_bucket_inventory, string, error) {
	rState := Aws_s3_bucket_inventoryMapper(desired)
	id, err := bridge.Create(h.provider, "aws_s3_bucket_inventory", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_s3_bucket_inventoryHandler) Read(externalID string) (*Aws_s3_bucket_inventory, error) {
	actual, err := bridge.Read(h.provider, "aws_s3_bucket_inventory", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_s3_bucket_inventoryUnmapper(actual), nil
}

// Delete ...
func (h *Aws_s3_bucket_inventoryHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_s3_bucket_inventory", externalID)
}

type Aws_dx_hosted_public_virtual_interface_accepter struct {
     Aws_dx_hosted_public_virtual_interface_accepter_id *string
     Virtual_interface_id string
     Tags *map[string]string
     Arn *string
}


func Aws_dx_hosted_public_virtual_interface_accepterMapper(r *Aws_dx_hosted_public_virtual_interface_accepter) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["virtual_interface_id"] = r.Virtual_interface_id
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_hosted_public_virtual_interface_accepterUnmapper(state map[string]interface{}) *Aws_dx_hosted_public_virtual_interface_accepter {
	r := &Aws_dx_hosted_public_virtual_interface_accepter{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_hosted_public_virtual_interface_accepter_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["virtual_interface_id"]; ok {
	r.Virtual_interface_id = x.(string)
}
	return r
}


// Aws_dx_hosted_public_virtual_interface_accepterHandler ...
type Aws_dx_hosted_public_virtual_interface_accepterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_hosted_public_virtual_interface_accepterHandler) Create(desired *Aws_dx_hosted_public_virtual_interface_accepter) (*Aws_dx_hosted_public_virtual_interface_accepter, string, error) {
	rState := Aws_dx_hosted_public_virtual_interface_accepterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_hosted_public_virtual_interface_accepter", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_hosted_public_virtual_interface_accepterHandler) Read(externalID string) (*Aws_dx_hosted_public_virtual_interface_accepter, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_hosted_public_virtual_interface_accepter", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_hosted_public_virtual_interface_accepterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_hosted_public_virtual_interface_accepterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_hosted_public_virtual_interface_accepter", externalID)
}

type Aws_elastictranscoder_pipeline struct {
     Aws_elastictranscoder_pipeline_id *string
     Aws_kms_key_arn *string
     Name *string
     Output_bucket *string
     Role string
     Arn *string
     Input_bucket string
}


func Aws_elastictranscoder_pipelineMapper(r *Aws_elastictranscoder_pipeline) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name != nil {
    config["name"] = *r.Name
}
if r.Output_bucket != nil {
    config["output_bucket"] = *r.Output_bucket
}
    config["role"] = r.Role
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["input_bucket"] = r.Input_bucket
if r.Aws_kms_key_arn != nil {
    config["aws_kms_key_arn"] = *r.Aws_kms_key_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elastictranscoder_pipelineUnmapper(state map[string]interface{}) *Aws_elastictranscoder_pipeline {
	r := &Aws_elastictranscoder_pipeline{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elastictranscoder_pipeline_id = &x
}

if x, ok := state["role"]; ok {
	r.Role = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["input_bucket"]; ok {
	r.Input_bucket = x.(string)
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["output_bucket"]; ok {
	x := x.(string)
	r.Output_bucket = &x
}

if x, ok := state["aws_kms_key_arn"]; ok {
	x := x.(string)
	r.Aws_kms_key_arn = &x
}
	return r
}


// Aws_elastictranscoder_pipelineHandler ...
type Aws_elastictranscoder_pipelineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elastictranscoder_pipelineHandler) Create(desired *Aws_elastictranscoder_pipeline) (*Aws_elastictranscoder_pipeline, string, error) {
	rState := Aws_elastictranscoder_pipelineMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elastictranscoder_pipeline", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elastictranscoder_pipelineHandler) Read(externalID string) (*Aws_elastictranscoder_pipeline, error) {
	actual, err := bridge.Read(h.provider, "aws_elastictranscoder_pipeline", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elastictranscoder_pipelineUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elastictranscoder_pipelineHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elastictranscoder_pipeline", externalID)
}

type Aws_sns_topic struct {
     Aws_sns_topic_id *string
     Application_success_feedback_role_arn *string
     Application_failure_feedback_role_arn *string
     Http_failure_feedback_role_arn *string
     Name *string
     Display_name *string
     Delivery_policy *string
     Sqs_success_feedback_role_arn *string
     Sqs_failure_feedback_role_arn *string
     Arn *string
     Policy *string
     Http_success_feedback_role_arn *string
     Lambda_success_feedback_role_arn *string
     Kms_master_key_id *string
     Lambda_failure_feedback_role_arn *string
     Name_prefix *string
}


func Aws_sns_topicMapper(r *Aws_sns_topic) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Kms_master_key_id != nil {
    config["kms_master_key_id"] = *r.Kms_master_key_id
}
if r.Lambda_failure_feedback_role_arn != nil {
    config["lambda_failure_feedback_role_arn"] = *r.Lambda_failure_feedback_role_arn
}
if r.Application_success_feedback_role_arn != nil {
    config["application_success_feedback_role_arn"] = *r.Application_success_feedback_role_arn
}
if r.Application_failure_feedback_role_arn != nil {
    config["application_failure_feedback_role_arn"] = *r.Application_failure_feedback_role_arn
}
if r.Http_failure_feedback_role_arn != nil {
    config["http_failure_feedback_role_arn"] = *r.Http_failure_feedback_role_arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Display_name != nil {
    config["display_name"] = *r.Display_name
}
if r.Delivery_policy != nil {
    config["delivery_policy"] = *r.Delivery_policy
}
if r.Policy != nil {
    config["policy"] = *r.Policy
}
if r.Http_success_feedback_role_arn != nil {
    config["http_success_feedback_role_arn"] = *r.Http_success_feedback_role_arn
}
if r.Lambda_success_feedback_role_arn != nil {
    config["lambda_success_feedback_role_arn"] = *r.Lambda_success_feedback_role_arn
}
if r.Sqs_success_feedback_role_arn != nil {
    config["sqs_success_feedback_role_arn"] = *r.Sqs_success_feedback_role_arn
}
if r.Sqs_failure_feedback_role_arn != nil {
    config["sqs_failure_feedback_role_arn"] = *r.Sqs_failure_feedback_role_arn
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sns_topicUnmapper(state map[string]interface{}) *Aws_sns_topic {
	r := &Aws_sns_topic{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sns_topic_id = &x
}

if x, ok := state["lambda_failure_feedback_role_arn"]; ok {
	x := x.(string)
	r.Lambda_failure_feedback_role_arn = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["kms_master_key_id"]; ok {
	x := x.(string)
	r.Kms_master_key_id = &x
}

if x, ok := state["application_success_feedback_role_arn"]; ok {
	x := x.(string)
	r.Application_success_feedback_role_arn = &x
}

if x, ok := state["application_failure_feedback_role_arn"]; ok {
	x := x.(string)
	r.Application_failure_feedback_role_arn = &x
}

if x, ok := state["http_failure_feedback_role_arn"]; ok {
	x := x.(string)
	r.Http_failure_feedback_role_arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["display_name"]; ok {
	x := x.(string)
	r.Display_name = &x
}

if x, ok := state["delivery_policy"]; ok {
	x := x.(string)
	r.Delivery_policy = &x
}

if x, ok := state["sqs_failure_feedback_role_arn"]; ok {
	x := x.(string)
	r.Sqs_failure_feedback_role_arn = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["policy"]; ok {
	x := x.(string)
	r.Policy = &x
}

if x, ok := state["http_success_feedback_role_arn"]; ok {
	x := x.(string)
	r.Http_success_feedback_role_arn = &x
}

if x, ok := state["lambda_success_feedback_role_arn"]; ok {
	x := x.(string)
	r.Lambda_success_feedback_role_arn = &x
}

if x, ok := state["sqs_success_feedback_role_arn"]; ok {
	x := x.(string)
	r.Sqs_success_feedback_role_arn = &x
}
	return r
}


// Aws_sns_topicHandler ...
type Aws_sns_topicHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sns_topicHandler) Create(desired *Aws_sns_topic) (*Aws_sns_topic, string, error) {
	rState := Aws_sns_topicMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sns_topic", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sns_topicHandler) Read(externalID string) (*Aws_sns_topic, error) {
	actual, err := bridge.Read(h.provider, "aws_sns_topic", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sns_topicUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sns_topicHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sns_topic", externalID)
}

type Aws_vpc_ipv4_cidr_block_association struct {
     Aws_vpc_ipv4_cidr_block_association_id *string
     Vpc_id string
     Cidr_block string
}


func Aws_vpc_ipv4_cidr_block_associationMapper(r *Aws_vpc_ipv4_cidr_block_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_id"] = r.Vpc_id
    config["cidr_block"] = r.Cidr_block
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_ipv4_cidr_block_associationUnmapper(state map[string]interface{}) *Aws_vpc_ipv4_cidr_block_association {
	r := &Aws_vpc_ipv4_cidr_block_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_ipv4_cidr_block_association_id = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}

if x, ok := state["cidr_block"]; ok {
	r.Cidr_block = x.(string)
}
	return r
}


// Aws_vpc_ipv4_cidr_block_associationHandler ...
type Aws_vpc_ipv4_cidr_block_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_ipv4_cidr_block_associationHandler) Create(desired *Aws_vpc_ipv4_cidr_block_association) (*Aws_vpc_ipv4_cidr_block_association, string, error) {
	rState := Aws_vpc_ipv4_cidr_block_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_ipv4_cidr_block_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_ipv4_cidr_block_associationHandler) Read(externalID string) (*Aws_vpc_ipv4_cidr_block_association, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_ipv4_cidr_block_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_ipv4_cidr_block_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_ipv4_cidr_block_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_ipv4_cidr_block_association", externalID)
}

type Aws_waf_web_acl struct {
     Aws_waf_web_acl_id *string
     Name string
     Metric_name string
}


func Aws_waf_web_aclMapper(r *Aws_waf_web_acl) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["metric_name"] = r.Metric_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_web_aclUnmapper(state map[string]interface{}) *Aws_waf_web_acl {
	r := &Aws_waf_web_acl{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_web_acl_id = &x
}

if x, ok := state["metric_name"]; ok {
	r.Metric_name = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_waf_web_aclHandler ...
type Aws_waf_web_aclHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_web_aclHandler) Create(desired *Aws_waf_web_acl) (*Aws_waf_web_acl, string, error) {
	rState := Aws_waf_web_aclMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_web_acl", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_web_aclHandler) Read(externalID string) (*Aws_waf_web_acl, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_web_acl", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_web_aclUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_web_aclHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_web_acl", externalID)
}

type Aws_dynamodb_global_table struct {
     Aws_dynamodb_global_table_id *string
     Name string
     Arn *string
}


func Aws_dynamodb_global_tableMapper(r *Aws_dynamodb_global_table) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dynamodb_global_tableUnmapper(state map[string]interface{}) *Aws_dynamodb_global_table {
	r := &Aws_dynamodb_global_table{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dynamodb_global_table_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_dynamodb_global_tableHandler ...
type Aws_dynamodb_global_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dynamodb_global_tableHandler) Create(desired *Aws_dynamodb_global_table) (*Aws_dynamodb_global_table, string, error) {
	rState := Aws_dynamodb_global_tableMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dynamodb_global_table", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dynamodb_global_tableHandler) Read(externalID string) (*Aws_dynamodb_global_table, error) {
	actual, err := bridge.Read(h.provider, "aws_dynamodb_global_table", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dynamodb_global_tableUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dynamodb_global_tableHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dynamodb_global_table", externalID)
}

type Aws_iot_policy_attachment struct {
     Aws_iot_policy_attachment_id *string
     Target string
     Policy string
}


func Aws_iot_policy_attachmentMapper(r *Aws_iot_policy_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["policy"] = r.Policy
    config["target"] = r.Target
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iot_policy_attachmentUnmapper(state map[string]interface{}) *Aws_iot_policy_attachment {
	r := &Aws_iot_policy_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iot_policy_attachment_id = &x
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}

if x, ok := state["target"]; ok {
	r.Target = x.(string)
}
	return r
}


// Aws_iot_policy_attachmentHandler ...
type Aws_iot_policy_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iot_policy_attachmentHandler) Create(desired *Aws_iot_policy_attachment) (*Aws_iot_policy_attachment, string, error) {
	rState := Aws_iot_policy_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iot_policy_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iot_policy_attachmentHandler) Read(externalID string) (*Aws_iot_policy_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_iot_policy_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iot_policy_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iot_policy_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iot_policy_attachment", externalID)
}

type Aws_instance struct {
     Aws_instance_id *string
     Subnet_id *string
     Primary_network_interface_id *string
     Instance_initiated_shutdown_behavior *string
     Host_id *string
     Key_name *string
     Public_dns *string
     Ebs_optimized *bool
     Instance_type string
     Source_dest_check *bool
     Iam_instance_profile *string
     Tags *map[string]string
     Availability_zone *string
     Tenancy *string
     Private_ip *string
     User_data *string
     Public_ip *string
     Instance_state *string
     Private_dns *string
     Monitoring *bool
     Associate_public_ip_address *bool
     Placement_group *string
     Get_password_data *bool
     User_data_base64 *string
     Network_interface_id *string
     Block_device *map[string]string
     Ami string
     Arn *string
     Password_data *string
     Disable_api_termination *bool
     Volume_tags *map[string]string
}


func Aws_instanceMapper(r *Aws_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Associate_public_ip_address != nil {
    config["associate_public_ip_address"] = *r.Associate_public_ip_address
}
if r.Placement_group != nil {
    config["placement_group"] = *r.Placement_group
}
if r.Get_password_data != nil {
    config["get_password_data"] = *r.Get_password_data
}
if r.User_data_base64 != nil {
    config["user_data_base64"] = *r.User_data_base64
}
if r.Network_interface_id != nil {
    config["network_interface_id"] = *r.Network_interface_id
}
if r.Monitoring != nil {
    config["monitoring"] = *r.Monitoring
}
    config["ami"] = r.Ami
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Password_data != nil {
    config["password_data"] = *r.Password_data
}
if r.Disable_api_termination != nil {
    config["disable_api_termination"] = *r.Disable_api_termination
}
if r.Volume_tags != nil {
    config["volume_tags"] = *r.Volume_tags
}
if r.Block_device != nil {
    config["block_device"] = *r.Block_device
}
if r.Subnet_id != nil {
    config["subnet_id"] = *r.Subnet_id
}
if r.Primary_network_interface_id != nil {
    config["primary_network_interface_id"] = *r.Primary_network_interface_id
}
if r.Instance_initiated_shutdown_behavior != nil {
    config["instance_initiated_shutdown_behavior"] = *r.Instance_initiated_shutdown_behavior
}
if r.Host_id != nil {
    config["host_id"] = *r.Host_id
}
if r.Key_name != nil {
    config["key_name"] = *r.Key_name
}
if r.Public_dns != nil {
    config["public_dns"] = *r.Public_dns
}
if r.Ebs_optimized != nil {
    config["ebs_optimized"] = *r.Ebs_optimized
}
    config["instance_type"] = r.Instance_type
if r.Source_dest_check != nil {
    config["source_dest_check"] = *r.Source_dest_check
}
if r.Iam_instance_profile != nil {
    config["iam_instance_profile"] = *r.Iam_instance_profile
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Tenancy != nil {
    config["tenancy"] = *r.Tenancy
}
if r.Private_ip != nil {
    config["private_ip"] = *r.Private_ip
}
if r.User_data != nil {
    config["user_data"] = *r.User_data
}
if r.Public_ip != nil {
    config["public_ip"] = *r.Public_ip
}
if r.Instance_state != nil {
    config["instance_state"] = *r.Instance_state
}
if r.Private_dns != nil {
    config["private_dns"] = *r.Private_dns
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_instanceUnmapper(state map[string]interface{}) *Aws_instance {
	r := &Aws_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_instance_id = &x
}

if x, ok := state["associate_public_ip_address"]; ok {
	x := x.(bool)
	r.Associate_public_ip_address = &x
}

if x, ok := state["placement_group"]; ok {
	x := x.(string)
	r.Placement_group = &x
}

if x, ok := state["get_password_data"]; ok {
	x := x.(bool)
	r.Get_password_data = &x
}

if x, ok := state["user_data_base64"]; ok {
	x := x.(string)
	r.User_data_base64 = &x
}

if x, ok := state["network_interface_id"]; ok {
	x := x.(string)
	r.Network_interface_id = &x
}

if x, ok := state["monitoring"]; ok {
	x := x.(bool)
	r.Monitoring = &x
}

if x, ok := state["ami"]; ok {
	r.Ami = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["password_data"]; ok {
	x := x.(string)
	r.Password_data = &x
}

if x, ok := state["disable_api_termination"]; ok {
	x := x.(bool)
	r.Disable_api_termination = &x
}

if x, ok := state["volume_tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Volume_tags = &x
}

if x, ok := state["block_device"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Block_device = &x
}

if x, ok := state["subnet_id"]; ok {
	x := x.(string)
	r.Subnet_id = &x
}

if x, ok := state["primary_network_interface_id"]; ok {
	x := x.(string)
	r.Primary_network_interface_id = &x
}

if x, ok := state["instance_initiated_shutdown_behavior"]; ok {
	x := x.(string)
	r.Instance_initiated_shutdown_behavior = &x
}

if x, ok := state["host_id"]; ok {
	x := x.(string)
	r.Host_id = &x
}

if x, ok := state["key_name"]; ok {
	x := x.(string)
	r.Key_name = &x
}

if x, ok := state["public_dns"]; ok {
	x := x.(string)
	r.Public_dns = &x
}

if x, ok := state["ebs_optimized"]; ok {
	x := x.(bool)
	r.Ebs_optimized = &x
}

if x, ok := state["instance_type"]; ok {
	r.Instance_type = x.(string)
}

if x, ok := state["source_dest_check"]; ok {
	x := x.(bool)
	r.Source_dest_check = &x
}

if x, ok := state["iam_instance_profile"]; ok {
	x := x.(string)
	r.Iam_instance_profile = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["tenancy"]; ok {
	x := x.(string)
	r.Tenancy = &x
}

if x, ok := state["private_ip"]; ok {
	x := x.(string)
	r.Private_ip = &x
}

if x, ok := state["user_data"]; ok {
	x := x.(string)
	r.User_data = &x
}

if x, ok := state["public_ip"]; ok {
	x := x.(string)
	r.Public_ip = &x
}

if x, ok := state["instance_state"]; ok {
	x := x.(string)
	r.Instance_state = &x
}

if x, ok := state["private_dns"]; ok {
	x := x.(string)
	r.Private_dns = &x
}
	return r
}


// Aws_instanceHandler ...
type Aws_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_instanceHandler) Create(desired *Aws_instance) (*Aws_instance, string, error) {
	rState := Aws_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_instanceHandler) Read(externalID string) (*Aws_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_instance", externalID)
}

type Aws_opsworks_application struct {
     Aws_opsworks_application_id *string
     Aws_flow_ruby_settings *string
     Data_source_arn *string
     Stack_id string
     Enable_ssl *bool
     Short_name *string
     Document_root *string
     Data_source_database_name *string
     Description *string
     Data_source_type *string
     Name string
     Resource_type string
     Rails_env *string
     Auto_bundle_on_deploy *string
}


func Aws_opsworks_applicationMapper(r *Aws_opsworks_application) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Data_source_arn != nil {
    config["data_source_arn"] = *r.Data_source_arn
}
if r.Aws_flow_ruby_settings != nil {
    config["aws_flow_ruby_settings"] = *r.Aws_flow_ruby_settings
}
if r.Enable_ssl != nil {
    config["enable_ssl"] = *r.Enable_ssl
}
    config["stack_id"] = r.Stack_id
if r.Document_root != nil {
    config["document_root"] = *r.Document_root
}
if r.Data_source_database_name != nil {
    config["data_source_database_name"] = *r.Data_source_database_name
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Short_name != nil {
    config["short_name"] = *r.Short_name
}
    config["resource_type"] = r.Resource_type
if r.Rails_env != nil {
    config["rails_env"] = *r.Rails_env
}
if r.Auto_bundle_on_deploy != nil {
    config["auto_bundle_on_deploy"] = *r.Auto_bundle_on_deploy
}
if r.Data_source_type != nil {
    config["data_source_type"] = *r.Data_source_type
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_applicationUnmapper(state map[string]interface{}) *Aws_opsworks_application {
	r := &Aws_opsworks_application{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_application_id = &x
}

if x, ok := state["data_source_type"]; ok {
	x := x.(string)
	r.Data_source_type = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["rails_env"]; ok {
	x := x.(string)
	r.Rails_env = &x
}

if x, ok := state["auto_bundle_on_deploy"]; ok {
	x := x.(string)
	r.Auto_bundle_on_deploy = &x
}

if x, ok := state["aws_flow_ruby_settings"]; ok {
	x := x.(string)
	r.Aws_flow_ruby_settings = &x
}

if x, ok := state["data_source_arn"]; ok {
	x := x.(string)
	r.Data_source_arn = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["enable_ssl"]; ok {
	x := x.(bool)
	r.Enable_ssl = &x
}

if x, ok := state["short_name"]; ok {
	x := x.(string)
	r.Short_name = &x
}

if x, ok := state["document_root"]; ok {
	x := x.(string)
	r.Document_root = &x
}

if x, ok := state["data_source_database_name"]; ok {
	x := x.(string)
	r.Data_source_database_name = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_opsworks_applicationHandler ...
type Aws_opsworks_applicationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_applicationHandler) Create(desired *Aws_opsworks_application) (*Aws_opsworks_application, string, error) {
	rState := Aws_opsworks_applicationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_application", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_applicationHandler) Read(externalID string) (*Aws_opsworks_application, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_application", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_applicationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_applicationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_application", externalID)
}

type Aws_directory_service_conditional_forwarder struct {
     Aws_directory_service_conditional_forwarder_id *string
     Remote_domain_name string
     Directory_id string
}


func Aws_directory_service_conditional_forwarderMapper(r *Aws_directory_service_conditional_forwarder) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["directory_id"] = r.Directory_id
    config["remote_domain_name"] = r.Remote_domain_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_directory_service_conditional_forwarderUnmapper(state map[string]interface{}) *Aws_directory_service_conditional_forwarder {
	r := &Aws_directory_service_conditional_forwarder{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_directory_service_conditional_forwarder_id = &x
}

if x, ok := state["remote_domain_name"]; ok {
	r.Remote_domain_name = x.(string)
}

if x, ok := state["directory_id"]; ok {
	r.Directory_id = x.(string)
}
	return r
}


// Aws_directory_service_conditional_forwarderHandler ...
type Aws_directory_service_conditional_forwarderHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_directory_service_conditional_forwarderHandler) Create(desired *Aws_directory_service_conditional_forwarder) (*Aws_directory_service_conditional_forwarder, string, error) {
	rState := Aws_directory_service_conditional_forwarderMapper(desired)
	id, err := bridge.Create(h.provider, "aws_directory_service_conditional_forwarder", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_directory_service_conditional_forwarderHandler) Read(externalID string) (*Aws_directory_service_conditional_forwarder, error) {
	actual, err := bridge.Read(h.provider, "aws_directory_service_conditional_forwarder", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_directory_service_conditional_forwarderUnmapper(actual), nil
}

// Delete ...
func (h *Aws_directory_service_conditional_forwarderHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_directory_service_conditional_forwarder", externalID)
}

type Aws_ec2_transit_gateway_route_table_propagation struct {
     Aws_ec2_transit_gateway_route_table_propagation_id *string
     Resource_id *string
     Resource_type *string
     Transit_gateway_attachment_id string
     Transit_gateway_route_table_id string
}


func Aws_ec2_transit_gateway_route_table_propagationMapper(r *Aws_ec2_transit_gateway_route_table_propagation) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["transit_gateway_attachment_id"] = r.Transit_gateway_attachment_id
    config["transit_gateway_route_table_id"] = r.Transit_gateway_route_table_id
if r.Resource_id != nil {
    config["resource_id"] = *r.Resource_id
}
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ec2_transit_gateway_route_table_propagationUnmapper(state map[string]interface{}) *Aws_ec2_transit_gateway_route_table_propagation {
	r := &Aws_ec2_transit_gateway_route_table_propagation{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ec2_transit_gateway_route_table_propagation_id = &x
}

if x, ok := state["resource_id"]; ok {
	x := x.(string)
	r.Resource_id = &x
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}

if x, ok := state["transit_gateway_attachment_id"]; ok {
	r.Transit_gateway_attachment_id = x.(string)
}

if x, ok := state["transit_gateway_route_table_id"]; ok {
	r.Transit_gateway_route_table_id = x.(string)
}
	return r
}


// Aws_ec2_transit_gateway_route_table_propagationHandler ...
type Aws_ec2_transit_gateway_route_table_propagationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ec2_transit_gateway_route_table_propagationHandler) Create(desired *Aws_ec2_transit_gateway_route_table_propagation) (*Aws_ec2_transit_gateway_route_table_propagation, string, error) {
	rState := Aws_ec2_transit_gateway_route_table_propagationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ec2_transit_gateway_route_table_propagation", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ec2_transit_gateway_route_table_propagationHandler) Read(externalID string) (*Aws_ec2_transit_gateway_route_table_propagation, error) {
	actual, err := bridge.Read(h.provider, "aws_ec2_transit_gateway_route_table_propagation", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ec2_transit_gateway_route_table_propagationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ec2_transit_gateway_route_table_propagationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ec2_transit_gateway_route_table_propagation", externalID)
}

type Aws_gamelift_build struct {
     Aws_gamelift_build_id *string
     Name string
     Operating_system string
     Version *string
}


func Aws_gamelift_buildMapper(r *Aws_gamelift_build) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["operating_system"] = r.Operating_system
if r.Version != nil {
    config["version"] = *r.Version
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_gamelift_buildUnmapper(state map[string]interface{}) *Aws_gamelift_build {
	r := &Aws_gamelift_build{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_gamelift_build_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["operating_system"]; ok {
	r.Operating_system = x.(string)
}

if x, ok := state["version"]; ok {
	x := x.(string)
	r.Version = &x
}
	return r
}


// Aws_gamelift_buildHandler ...
type Aws_gamelift_buildHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_gamelift_buildHandler) Create(desired *Aws_gamelift_build) (*Aws_gamelift_build, string, error) {
	rState := Aws_gamelift_buildMapper(desired)
	id, err := bridge.Create(h.provider, "aws_gamelift_build", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_gamelift_buildHandler) Read(externalID string) (*Aws_gamelift_build, error) {
	actual, err := bridge.Read(h.provider, "aws_gamelift_build", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_gamelift_buildUnmapper(actual), nil
}

// Delete ...
func (h *Aws_gamelift_buildHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_gamelift_build", externalID)
}

type Aws_network_interface_sg_attachment struct {
     Aws_network_interface_sg_attachment_id *string
     Security_group_id string
     Network_interface_id string
}


func Aws_network_interface_sg_attachmentMapper(r *Aws_network_interface_sg_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["network_interface_id"] = r.Network_interface_id
    config["security_group_id"] = r.Security_group_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_network_interface_sg_attachmentUnmapper(state map[string]interface{}) *Aws_network_interface_sg_attachment {
	r := &Aws_network_interface_sg_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_network_interface_sg_attachment_id = &x
}

if x, ok := state["security_group_id"]; ok {
	r.Security_group_id = x.(string)
}

if x, ok := state["network_interface_id"]; ok {
	r.Network_interface_id = x.(string)
}
	return r
}


// Aws_network_interface_sg_attachmentHandler ...
type Aws_network_interface_sg_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_network_interface_sg_attachmentHandler) Create(desired *Aws_network_interface_sg_attachment) (*Aws_network_interface_sg_attachment, string, error) {
	rState := Aws_network_interface_sg_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_network_interface_sg_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_network_interface_sg_attachmentHandler) Read(externalID string) (*Aws_network_interface_sg_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_network_interface_sg_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_network_interface_sg_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_network_interface_sg_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_network_interface_sg_attachment", externalID)
}

type Aws_vpc_endpoint_service_allowed_principal struct {
     Aws_vpc_endpoint_service_allowed_principal_id *string
     Vpc_endpoint_service_id string
     Principal_arn string
}


func Aws_vpc_endpoint_service_allowed_principalMapper(r *Aws_vpc_endpoint_service_allowed_principal) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_endpoint_service_id"] = r.Vpc_endpoint_service_id
    config["principal_arn"] = r.Principal_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_endpoint_service_allowed_principalUnmapper(state map[string]interface{}) *Aws_vpc_endpoint_service_allowed_principal {
	r := &Aws_vpc_endpoint_service_allowed_principal{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_endpoint_service_allowed_principal_id = &x
}

if x, ok := state["principal_arn"]; ok {
	r.Principal_arn = x.(string)
}

if x, ok := state["vpc_endpoint_service_id"]; ok {
	r.Vpc_endpoint_service_id = x.(string)
}
	return r
}


// Aws_vpc_endpoint_service_allowed_principalHandler ...
type Aws_vpc_endpoint_service_allowed_principalHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_endpoint_service_allowed_principalHandler) Create(desired *Aws_vpc_endpoint_service_allowed_principal) (*Aws_vpc_endpoint_service_allowed_principal, string, error) {
	rState := Aws_vpc_endpoint_service_allowed_principalMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_endpoint_service_allowed_principal", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_endpoint_service_allowed_principalHandler) Read(externalID string) (*Aws_vpc_endpoint_service_allowed_principal, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_endpoint_service_allowed_principal", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_endpoint_service_allowed_principalUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_endpoint_service_allowed_principalHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_endpoint_service_allowed_principal", externalID)
}

type Aws_wafregional_geo_match_set struct {
     Aws_wafregional_geo_match_set_id *string
     Name string
}


func Aws_wafregional_geo_match_setMapper(r *Aws_wafregional_geo_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_geo_match_setUnmapper(state map[string]interface{}) *Aws_wafregional_geo_match_set {
	r := &Aws_wafregional_geo_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_geo_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_wafregional_geo_match_setHandler ...
type Aws_wafregional_geo_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_geo_match_setHandler) Create(desired *Aws_wafregional_geo_match_set) (*Aws_wafregional_geo_match_set, string, error) {
	rState := Aws_wafregional_geo_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_geo_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_geo_match_setHandler) Read(externalID string) (*Aws_wafregional_geo_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_geo_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_geo_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_geo_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_geo_match_set", externalID)
}

type Aws_cloudwatch_log_subscription_filter struct {
     Aws_cloudwatch_log_subscription_filter_id *string
     Role_arn *string
     Distribution *string
     Name string
     Destination_arn string
     Filter_pattern string
     Log_group_name string
}


func Aws_cloudwatch_log_subscription_filterMapper(r *Aws_cloudwatch_log_subscription_filter) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["log_group_name"] = r.Log_group_name
if r.Role_arn != nil {
    config["role_arn"] = *r.Role_arn
}
if r.Distribution != nil {
    config["distribution"] = *r.Distribution
}
    config["name"] = r.Name
    config["destination_arn"] = r.Destination_arn
    config["filter_pattern"] = r.Filter_pattern
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_log_subscription_filterUnmapper(state map[string]interface{}) *Aws_cloudwatch_log_subscription_filter {
	r := &Aws_cloudwatch_log_subscription_filter{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_log_subscription_filter_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["destination_arn"]; ok {
	r.Destination_arn = x.(string)
}

if x, ok := state["filter_pattern"]; ok {
	r.Filter_pattern = x.(string)
}

if x, ok := state["log_group_name"]; ok {
	r.Log_group_name = x.(string)
}

if x, ok := state["role_arn"]; ok {
	x := x.(string)
	r.Role_arn = &x
}

if x, ok := state["distribution"]; ok {
	x := x.(string)
	r.Distribution = &x
}
	return r
}


// Aws_cloudwatch_log_subscription_filterHandler ...
type Aws_cloudwatch_log_subscription_filterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_log_subscription_filterHandler) Create(desired *Aws_cloudwatch_log_subscription_filter) (*Aws_cloudwatch_log_subscription_filter, string, error) {
	rState := Aws_cloudwatch_log_subscription_filterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_log_subscription_filter", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_log_subscription_filterHandler) Read(externalID string) (*Aws_cloudwatch_log_subscription_filter, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_log_subscription_filter", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_log_subscription_filterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_log_subscription_filterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_log_subscription_filter", externalID)
}

type Aws_db_option_group struct {
     Aws_db_option_group_id *string
     Arn *string
     Name *string
     Name_prefix *string
     Engine_name string
     Major_engine_version string
     Option_group_description *string
     Tags *map[string]string
}


func Aws_db_option_groupMapper(r *Aws_db_option_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["engine_name"] = r.Engine_name
    config["major_engine_version"] = r.Major_engine_version
if r.Option_group_description != nil {
    config["option_group_description"] = *r.Option_group_description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_db_option_groupUnmapper(state map[string]interface{}) *Aws_db_option_group {
	r := &Aws_db_option_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_db_option_group_id = &x
}

if x, ok := state["engine_name"]; ok {
	r.Engine_name = x.(string)
}

if x, ok := state["major_engine_version"]; ok {
	r.Major_engine_version = x.(string)
}

if x, ok := state["option_group_description"]; ok {
	x := x.(string)
	r.Option_group_description = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}
	return r
}


// Aws_db_option_groupHandler ...
type Aws_db_option_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_db_option_groupHandler) Create(desired *Aws_db_option_group) (*Aws_db_option_group, string, error) {
	rState := Aws_db_option_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_db_option_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_db_option_groupHandler) Read(externalID string) (*Aws_db_option_group, error) {
	actual, err := bridge.Read(h.provider, "aws_db_option_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_db_option_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_db_option_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_db_option_group", externalID)
}

type Aws_organizations_organization struct {
     Aws_organizations_organization_id *string
     Master_account_id *string
     Feature_set *string
     Arn *string
     Master_account_arn *string
     Master_account_email *string
}


func Aws_organizations_organizationMapper(r *Aws_organizations_organization) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Feature_set != nil {
    config["feature_set"] = *r.Feature_set
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Master_account_arn != nil {
    config["master_account_arn"] = *r.Master_account_arn
}
if r.Master_account_email != nil {
    config["master_account_email"] = *r.Master_account_email
}
if r.Master_account_id != nil {
    config["master_account_id"] = *r.Master_account_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_organizations_organizationUnmapper(state map[string]interface{}) *Aws_organizations_organization {
	r := &Aws_organizations_organization{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_organizations_organization_id = &x
}

if x, ok := state["master_account_id"]; ok {
	x := x.(string)
	r.Master_account_id = &x
}

if x, ok := state["feature_set"]; ok {
	x := x.(string)
	r.Feature_set = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["master_account_arn"]; ok {
	x := x.(string)
	r.Master_account_arn = &x
}

if x, ok := state["master_account_email"]; ok {
	x := x.(string)
	r.Master_account_email = &x
}
	return r
}


// Aws_organizations_organizationHandler ...
type Aws_organizations_organizationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_organizations_organizationHandler) Create(desired *Aws_organizations_organization) (*Aws_organizations_organization, string, error) {
	rState := Aws_organizations_organizationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_organizations_organization", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_organizations_organizationHandler) Read(externalID string) (*Aws_organizations_organization, error) {
	actual, err := bridge.Read(h.provider, "aws_organizations_organization", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_organizations_organizationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_organizations_organizationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_organizations_organization", externalID)
}

type Aws_resourcegroups_group struct {
     Aws_resourcegroups_group_id *string
     Name string
     Description *string
     Arn *string
}


func Aws_resourcegroups_groupMapper(r *Aws_resourcegroups_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_resourcegroups_groupUnmapper(state map[string]interface{}) *Aws_resourcegroups_group {
	r := &Aws_resourcegroups_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_resourcegroups_group_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_resourcegroups_groupHandler ...
type Aws_resourcegroups_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_resourcegroups_groupHandler) Create(desired *Aws_resourcegroups_group) (*Aws_resourcegroups_group, string, error) {
	rState := Aws_resourcegroups_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_resourcegroups_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_resourcegroups_groupHandler) Read(externalID string) (*Aws_resourcegroups_group, error) {
	actual, err := bridge.Read(h.provider, "aws_resourcegroups_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_resourcegroups_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_resourcegroups_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_resourcegroups_group", externalID)
}

type Aws_api_gateway_base_path_mapping struct {
     Aws_api_gateway_base_path_mapping_id *string
     Api_id string
     Base_path *string
     Stage_name *string
     Domain_name string
}


func Aws_api_gateway_base_path_mappingMapper(r *Aws_api_gateway_base_path_mapping) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["api_id"] = r.Api_id
if r.Base_path != nil {
    config["base_path"] = *r.Base_path
}
if r.Stage_name != nil {
    config["stage_name"] = *r.Stage_name
}
    config["domain_name"] = r.Domain_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_base_path_mappingUnmapper(state map[string]interface{}) *Aws_api_gateway_base_path_mapping {
	r := &Aws_api_gateway_base_path_mapping{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_base_path_mapping_id = &x
}

if x, ok := state["api_id"]; ok {
	r.Api_id = x.(string)
}

if x, ok := state["base_path"]; ok {
	x := x.(string)
	r.Base_path = &x
}

if x, ok := state["stage_name"]; ok {
	x := x.(string)
	r.Stage_name = &x
}

if x, ok := state["domain_name"]; ok {
	r.Domain_name = x.(string)
}
	return r
}


// Aws_api_gateway_base_path_mappingHandler ...
type Aws_api_gateway_base_path_mappingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_base_path_mappingHandler) Create(desired *Aws_api_gateway_base_path_mapping) (*Aws_api_gateway_base_path_mapping, string, error) {
	rState := Aws_api_gateway_base_path_mappingMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_base_path_mapping", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_base_path_mappingHandler) Read(externalID string) (*Aws_api_gateway_base_path_mapping, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_base_path_mapping", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_base_path_mappingUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_base_path_mappingHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_base_path_mapping", externalID)
}

type Aws_api_gateway_model struct {
     Aws_api_gateway_model_id *string
     Name string
     Description *string
     Schema *string
     Content_type string
     Rest_api_id string
}


func Aws_api_gateway_modelMapper(r *Aws_api_gateway_model) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["content_type"] = r.Content_type
    config["rest_api_id"] = r.Rest_api_id
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Schema != nil {
    config["schema"] = *r.Schema
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_modelUnmapper(state map[string]interface{}) *Aws_api_gateway_model {
	r := &Aws_api_gateway_model{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_model_id = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["schema"]; ok {
	x := x.(string)
	r.Schema = &x
}

if x, ok := state["content_type"]; ok {
	r.Content_type = x.(string)
}
	return r
}


// Aws_api_gateway_modelHandler ...
type Aws_api_gateway_modelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_modelHandler) Create(desired *Aws_api_gateway_model) (*Aws_api_gateway_model, string, error) {
	rState := Aws_api_gateway_modelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_model", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_modelHandler) Read(externalID string) (*Aws_api_gateway_model, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_model", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_modelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_modelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_model", externalID)
}

type Aws_gamelift_fleet struct {
     Aws_gamelift_fleet_id *string
     Arn *string
     Operating_system *string
     Build_id string
     Ec2_instance_type string
     Name string
     Description *string
     New_game_session_protection_policy *string
}


func Aws_gamelift_fleetMapper(r *Aws_gamelift_fleet) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["ec2_instance_type"] = r.Ec2_instance_type
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.New_game_session_protection_policy != nil {
    config["new_game_session_protection_policy"] = *r.New_game_session_protection_policy
}
    config["build_id"] = r.Build_id
if r.Operating_system != nil {
    config["operating_system"] = *r.Operating_system
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_gamelift_fleetUnmapper(state map[string]interface{}) *Aws_gamelift_fleet {
	r := &Aws_gamelift_fleet{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_gamelift_fleet_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["operating_system"]; ok {
	x := x.(string)
	r.Operating_system = &x
}

if x, ok := state["new_game_session_protection_policy"]; ok {
	x := x.(string)
	r.New_game_session_protection_policy = &x
}

if x, ok := state["build_id"]; ok {
	r.Build_id = x.(string)
}

if x, ok := state["ec2_instance_type"]; ok {
	r.Ec2_instance_type = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_gamelift_fleetHandler ...
type Aws_gamelift_fleetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_gamelift_fleetHandler) Create(desired *Aws_gamelift_fleet) (*Aws_gamelift_fleet, string, error) {
	rState := Aws_gamelift_fleetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_gamelift_fleet", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_gamelift_fleetHandler) Read(externalID string) (*Aws_gamelift_fleet, error) {
	actual, err := bridge.Read(h.provider, "aws_gamelift_fleet", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_gamelift_fleetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_gamelift_fleetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_gamelift_fleet", externalID)
}

type Aws_redshift_snapshot_copy_grant struct {
     Aws_redshift_snapshot_copy_grant_id *string
     Snapshot_copy_grant_name string
     Kms_key_id *string
     Tags *map[string]string
}


func Aws_redshift_snapshot_copy_grantMapper(r *Aws_redshift_snapshot_copy_grant) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["snapshot_copy_grant_name"] = r.Snapshot_copy_grant_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_redshift_snapshot_copy_grantUnmapper(state map[string]interface{}) *Aws_redshift_snapshot_copy_grant {
	r := &Aws_redshift_snapshot_copy_grant{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_redshift_snapshot_copy_grant_id = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["snapshot_copy_grant_name"]; ok {
	r.Snapshot_copy_grant_name = x.(string)
}
	return r
}


// Aws_redshift_snapshot_copy_grantHandler ...
type Aws_redshift_snapshot_copy_grantHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_redshift_snapshot_copy_grantHandler) Create(desired *Aws_redshift_snapshot_copy_grant) (*Aws_redshift_snapshot_copy_grant, string, error) {
	rState := Aws_redshift_snapshot_copy_grantMapper(desired)
	id, err := bridge.Create(h.provider, "aws_redshift_snapshot_copy_grant", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_redshift_snapshot_copy_grantHandler) Read(externalID string) (*Aws_redshift_snapshot_copy_grant, error) {
	actual, err := bridge.Read(h.provider, "aws_redshift_snapshot_copy_grant", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_redshift_snapshot_copy_grantUnmapper(actual), nil
}

// Delete ...
func (h *Aws_redshift_snapshot_copy_grantHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_redshift_snapshot_copy_grant", externalID)
}

type Aws_servicecatalog_portfolio struct {
     Aws_servicecatalog_portfolio_id *string
     Arn *string
     Created_time *string
     Name string
     Description *string
     Provider_name *string
     Tags *map[string]string
}


func Aws_servicecatalog_portfolioMapper(r *Aws_servicecatalog_portfolio) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Created_time != nil {
    config["created_time"] = *r.Created_time
}
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Provider_name != nil {
    config["provider_name"] = *r.Provider_name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_servicecatalog_portfolioUnmapper(state map[string]interface{}) *Aws_servicecatalog_portfolio {
	r := &Aws_servicecatalog_portfolio{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_servicecatalog_portfolio_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["created_time"]; ok {
	x := x.(string)
	r.Created_time = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["provider_name"]; ok {
	x := x.(string)
	r.Provider_name = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_servicecatalog_portfolioHandler ...
type Aws_servicecatalog_portfolioHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_servicecatalog_portfolioHandler) Create(desired *Aws_servicecatalog_portfolio) (*Aws_servicecatalog_portfolio, string, error) {
	rState := Aws_servicecatalog_portfolioMapper(desired)
	id, err := bridge.Create(h.provider, "aws_servicecatalog_portfolio", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_servicecatalog_portfolioHandler) Read(externalID string) (*Aws_servicecatalog_portfolio, error) {
	actual, err := bridge.Read(h.provider, "aws_servicecatalog_portfolio", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_servicecatalog_portfolioUnmapper(actual), nil
}

// Delete ...
func (h *Aws_servicecatalog_portfolioHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_servicecatalog_portfolio", externalID)
}

type Aws_vpc_dhcp_options struct {
     Aws_vpc_dhcp_options_id *string
     Netbios_node_type *string
     Tags *map[string]string
     Owner_id *string
     Domain_name *string
}


func Aws_vpc_dhcp_optionsMapper(r *Aws_vpc_dhcp_options) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Domain_name != nil {
    config["domain_name"] = *r.Domain_name
}
if r.Netbios_node_type != nil {
    config["netbios_node_type"] = *r.Netbios_node_type
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_dhcp_optionsUnmapper(state map[string]interface{}) *Aws_vpc_dhcp_options {
	r := &Aws_vpc_dhcp_options{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_dhcp_options_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["domain_name"]; ok {
	x := x.(string)
	r.Domain_name = &x
}

if x, ok := state["netbios_node_type"]; ok {
	x := x.(string)
	r.Netbios_node_type = &x
}
	return r
}


// Aws_vpc_dhcp_optionsHandler ...
type Aws_vpc_dhcp_optionsHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_dhcp_optionsHandler) Create(desired *Aws_vpc_dhcp_options) (*Aws_vpc_dhcp_options, string, error) {
	rState := Aws_vpc_dhcp_optionsMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_dhcp_options", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_dhcp_optionsHandler) Read(externalID string) (*Aws_vpc_dhcp_options, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_dhcp_options", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_dhcp_optionsUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_dhcp_optionsHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_dhcp_options", externalID)
}

type Aws_appmesh_virtual_router struct {
     Aws_appmesh_virtual_router_id *string
     Name string
     Mesh_name string
     Arn *string
     Created_date *string
     Last_updated_date *string
}


func Aws_appmesh_virtual_routerMapper(r *Aws_appmesh_virtual_router) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
if r.Last_updated_date != nil {
    config["last_updated_date"] = *r.Last_updated_date
}
    config["name"] = r.Name
    config["mesh_name"] = r.Mesh_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appmesh_virtual_routerUnmapper(state map[string]interface{}) *Aws_appmesh_virtual_router {
	r := &Aws_appmesh_virtual_router{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appmesh_virtual_router_id = &x
}

if x, ok := state["last_updated_date"]; ok {
	x := x.(string)
	r.Last_updated_date = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["mesh_name"]; ok {
	r.Mesh_name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}
	return r
}


// Aws_appmesh_virtual_routerHandler ...
type Aws_appmesh_virtual_routerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appmesh_virtual_routerHandler) Create(desired *Aws_appmesh_virtual_router) (*Aws_appmesh_virtual_router, string, error) {
	rState := Aws_appmesh_virtual_routerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appmesh_virtual_router", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appmesh_virtual_routerHandler) Read(externalID string) (*Aws_appmesh_virtual_router, error) {
	actual, err := bridge.Read(h.provider, "aws_appmesh_virtual_router", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appmesh_virtual_routerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appmesh_virtual_routerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appmesh_virtual_router", externalID)
}

type Aws_key_pair struct {
     Aws_key_pair_id *string
     Key_name_prefix *string
     Public_key string
     Fingerprint *string
     Key_name *string
}


func Aws_key_pairMapper(r *Aws_key_pair) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["public_key"] = r.Public_key
if r.Fingerprint != nil {
    config["fingerprint"] = *r.Fingerprint
}
if r.Key_name != nil {
    config["key_name"] = *r.Key_name
}
if r.Key_name_prefix != nil {
    config["key_name_prefix"] = *r.Key_name_prefix
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_key_pairUnmapper(state map[string]interface{}) *Aws_key_pair {
	r := &Aws_key_pair{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_key_pair_id = &x
}

if x, ok := state["key_name"]; ok {
	x := x.(string)
	r.Key_name = &x
}

if x, ok := state["key_name_prefix"]; ok {
	x := x.(string)
	r.Key_name_prefix = &x
}

if x, ok := state["public_key"]; ok {
	r.Public_key = x.(string)
}

if x, ok := state["fingerprint"]; ok {
	x := x.(string)
	r.Fingerprint = &x
}
	return r
}


// Aws_key_pairHandler ...
type Aws_key_pairHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_key_pairHandler) Create(desired *Aws_key_pair) (*Aws_key_pair, string, error) {
	rState := Aws_key_pairMapper(desired)
	id, err := bridge.Create(h.provider, "aws_key_pair", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_key_pairHandler) Read(externalID string) (*Aws_key_pair, error) {
	actual, err := bridge.Read(h.provider, "aws_key_pair", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_key_pairUnmapper(actual), nil
}

// Delete ...
func (h *Aws_key_pairHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_key_pair", externalID)
}

type Aws_glue_catalog_table struct {
     Aws_glue_catalog_table_id *string
     Catalog_id *string
     Database_name string
     Description *string
     Name string
     Owner *string
     Parameters *map[string]string
     Table_type *string
     View_original_text *string
     View_expanded_text *string
}


func Aws_glue_catalog_tableMapper(r *Aws_glue_catalog_table) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Catalog_id != nil {
    config["catalog_id"] = *r.Catalog_id
}
    config["database_name"] = r.Database_name
if r.Description != nil {
    config["description"] = *r.Description
}
    config["name"] = r.Name
if r.Owner != nil {
    config["owner"] = *r.Owner
}
if r.Parameters != nil {
    config["parameters"] = *r.Parameters
}
if r.Table_type != nil {
    config["table_type"] = *r.Table_type
}
if r.View_original_text != nil {
    config["view_original_text"] = *r.View_original_text
}
if r.View_expanded_text != nil {
    config["view_expanded_text"] = *r.View_expanded_text
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glue_catalog_tableUnmapper(state map[string]interface{}) *Aws_glue_catalog_table {
	r := &Aws_glue_catalog_table{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glue_catalog_table_id = &x
}

if x, ok := state["owner"]; ok {
	x := x.(string)
	r.Owner = &x
}

if x, ok := state["parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Parameters = &x
}

if x, ok := state["table_type"]; ok {
	x := x.(string)
	r.Table_type = &x
}

if x, ok := state["view_original_text"]; ok {
	x := x.(string)
	r.View_original_text = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["view_expanded_text"]; ok {
	x := x.(string)
	r.View_expanded_text = &x
}

if x, ok := state["catalog_id"]; ok {
	x := x.(string)
	r.Catalog_id = &x
}

if x, ok := state["database_name"]; ok {
	r.Database_name = x.(string)
}
	return r
}


// Aws_glue_catalog_tableHandler ...
type Aws_glue_catalog_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glue_catalog_tableHandler) Create(desired *Aws_glue_catalog_table) (*Aws_glue_catalog_table, string, error) {
	rState := Aws_glue_catalog_tableMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glue_catalog_table", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glue_catalog_tableHandler) Read(externalID string) (*Aws_glue_catalog_table, error) {
	actual, err := bridge.Read(h.provider, "aws_glue_catalog_table", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glue_catalog_tableUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glue_catalog_tableHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glue_catalog_table", externalID)
}

type Aws_glue_classifier struct {
     Aws_glue_classifier_id *string
     Name string
}


func Aws_glue_classifierMapper(r *Aws_glue_classifier) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glue_classifierUnmapper(state map[string]interface{}) *Aws_glue_classifier {
	r := &Aws_glue_classifier{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glue_classifier_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_glue_classifierHandler ...
type Aws_glue_classifierHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glue_classifierHandler) Create(desired *Aws_glue_classifier) (*Aws_glue_classifier, string, error) {
	rState := Aws_glue_classifierMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glue_classifier", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glue_classifierHandler) Read(externalID string) (*Aws_glue_classifier, error) {
	actual, err := bridge.Read(h.provider, "aws_glue_classifier", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glue_classifierUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glue_classifierHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glue_classifier", externalID)
}

type Aws_cognito_identity_pool_roles_attachment struct {
     Aws_cognito_identity_pool_roles_attachment_id *string
     Identity_pool_id string
     Roles map[string]string
}


func Aws_cognito_identity_pool_roles_attachmentMapper(r *Aws_cognito_identity_pool_roles_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["identity_pool_id"] = r.Identity_pool_id
    config["roles"] = r.Roles
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cognito_identity_pool_roles_attachmentUnmapper(state map[string]interface{}) *Aws_cognito_identity_pool_roles_attachment {
	r := &Aws_cognito_identity_pool_roles_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cognito_identity_pool_roles_attachment_id = &x
}

if x, ok := state["identity_pool_id"]; ok {
	r.Identity_pool_id = x.(string)
}

if x, ok := state["roles"]; ok {
	r.Roles = x.(map[string]string)
}
	return r
}


// Aws_cognito_identity_pool_roles_attachmentHandler ...
type Aws_cognito_identity_pool_roles_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cognito_identity_pool_roles_attachmentHandler) Create(desired *Aws_cognito_identity_pool_roles_attachment) (*Aws_cognito_identity_pool_roles_attachment, string, error) {
	rState := Aws_cognito_identity_pool_roles_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cognito_identity_pool_roles_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cognito_identity_pool_roles_attachmentHandler) Read(externalID string) (*Aws_cognito_identity_pool_roles_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_cognito_identity_pool_roles_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cognito_identity_pool_roles_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cognito_identity_pool_roles_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cognito_identity_pool_roles_attachment", externalID)
}

type Aws_db_parameter_group struct {
     Aws_db_parameter_group_id *string
     Tags *map[string]string
     Arn *string
     Name *string
     Name_prefix *string
     Family string
     Description *string
}


func Aws_db_parameter_groupMapper(r *Aws_db_parameter_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["family"] = r.Family
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_db_parameter_groupUnmapper(state map[string]interface{}) *Aws_db_parameter_group {
	r := &Aws_db_parameter_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_db_parameter_group_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["family"]; ok {
	r.Family = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_db_parameter_groupHandler ...
type Aws_db_parameter_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_db_parameter_groupHandler) Create(desired *Aws_db_parameter_group) (*Aws_db_parameter_group, string, error) {
	rState := Aws_db_parameter_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_db_parameter_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_db_parameter_groupHandler) Read(externalID string) (*Aws_db_parameter_group, error) {
	actual, err := bridge.Read(h.provider, "aws_db_parameter_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_db_parameter_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_db_parameter_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_db_parameter_group", externalID)
}

type Aws_redshift_subnet_group struct {
     Aws_redshift_subnet_group_id *string
     Name string
     Description *string
     Tags *map[string]string
}


func Aws_redshift_subnet_groupMapper(r *Aws_redshift_subnet_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_redshift_subnet_groupUnmapper(state map[string]interface{}) *Aws_redshift_subnet_group {
	r := &Aws_redshift_subnet_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_redshift_subnet_group_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_redshift_subnet_groupHandler ...
type Aws_redshift_subnet_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_redshift_subnet_groupHandler) Create(desired *Aws_redshift_subnet_group) (*Aws_redshift_subnet_group, string, error) {
	rState := Aws_redshift_subnet_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_redshift_subnet_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_redshift_subnet_groupHandler) Read(externalID string) (*Aws_redshift_subnet_group, error) {
	actual, err := bridge.Read(h.provider, "aws_redshift_subnet_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_redshift_subnet_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_redshift_subnet_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_redshift_subnet_group", externalID)
}

type Aws_ec2_capacity_reservation struct {
     Aws_ec2_capacity_reservation_id *string
     Ebs_optimized *bool
     End_date *string
     End_date_type *string
     Ephemeral_storage *bool
     Tenancy *string
     Availability_zone string
     Instance_match_criteria *string
     Instance_platform string
     Instance_type string
     Tags *map[string]string
}


func Aws_ec2_capacity_reservationMapper(r *Aws_ec2_capacity_reservation) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.End_date_type != nil {
    config["end_date_type"] = *r.End_date_type
}
if r.Ephemeral_storage != nil {
    config["ephemeral_storage"] = *r.Ephemeral_storage
}
if r.Tenancy != nil {
    config["tenancy"] = *r.Tenancy
}
if r.Ebs_optimized != nil {
    config["ebs_optimized"] = *r.Ebs_optimized
}
if r.End_date != nil {
    config["end_date"] = *r.End_date
}
if r.Instance_match_criteria != nil {
    config["instance_match_criteria"] = *r.Instance_match_criteria
}
    config["instance_platform"] = r.Instance_platform
    config["instance_type"] = r.Instance_type
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["availability_zone"] = r.Availability_zone
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ec2_capacity_reservationUnmapper(state map[string]interface{}) *Aws_ec2_capacity_reservation {
	r := &Aws_ec2_capacity_reservation{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ec2_capacity_reservation_id = &x
}

if x, ok := state["tenancy"]; ok {
	x := x.(string)
	r.Tenancy = &x
}

if x, ok := state["ebs_optimized"]; ok {
	x := x.(bool)
	r.Ebs_optimized = &x
}

if x, ok := state["end_date"]; ok {
	x := x.(string)
	r.End_date = &x
}

if x, ok := state["end_date_type"]; ok {
	x := x.(string)
	r.End_date_type = &x
}

if x, ok := state["ephemeral_storage"]; ok {
	x := x.(bool)
	r.Ephemeral_storage = &x
}

if x, ok := state["instance_type"]; ok {
	r.Instance_type = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["availability_zone"]; ok {
	r.Availability_zone = x.(string)
}

if x, ok := state["instance_match_criteria"]; ok {
	x := x.(string)
	r.Instance_match_criteria = &x
}

if x, ok := state["instance_platform"]; ok {
	r.Instance_platform = x.(string)
}
	return r
}


// Aws_ec2_capacity_reservationHandler ...
type Aws_ec2_capacity_reservationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ec2_capacity_reservationHandler) Create(desired *Aws_ec2_capacity_reservation) (*Aws_ec2_capacity_reservation, string, error) {
	rState := Aws_ec2_capacity_reservationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ec2_capacity_reservation", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ec2_capacity_reservationHandler) Read(externalID string) (*Aws_ec2_capacity_reservation, error) {
	actual, err := bridge.Read(h.provider, "aws_ec2_capacity_reservation", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ec2_capacity_reservationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ec2_capacity_reservationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ec2_capacity_reservation", externalID)
}

type Aws_rds_cluster_parameter_group struct {
     Aws_rds_cluster_parameter_group_id *string
     Family string
     Description *string
     Tags *map[string]string
     Arn *string
     Name *string
     Name_prefix *string
}


func Aws_rds_cluster_parameter_groupMapper(r *Aws_rds_cluster_parameter_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
    config["family"] = r.Family
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_rds_cluster_parameter_groupUnmapper(state map[string]interface{}) *Aws_rds_cluster_parameter_group {
	r := &Aws_rds_cluster_parameter_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_rds_cluster_parameter_group_id = &x
}

if x, ok := state["family"]; ok {
	r.Family = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}
	return r
}


// Aws_rds_cluster_parameter_groupHandler ...
type Aws_rds_cluster_parameter_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_rds_cluster_parameter_groupHandler) Create(desired *Aws_rds_cluster_parameter_group) (*Aws_rds_cluster_parameter_group, string, error) {
	rState := Aws_rds_cluster_parameter_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_rds_cluster_parameter_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_rds_cluster_parameter_groupHandler) Read(externalID string) (*Aws_rds_cluster_parameter_group, error) {
	actual, err := bridge.Read(h.provider, "aws_rds_cluster_parameter_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_rds_cluster_parameter_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_rds_cluster_parameter_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_rds_cluster_parameter_group", externalID)
}

type Aws_elastic_beanstalk_application struct {
     Aws_elastic_beanstalk_application_id *string
     Name string
     Description *string
}


func Aws_elastic_beanstalk_applicationMapper(r *Aws_elastic_beanstalk_application) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elastic_beanstalk_applicationUnmapper(state map[string]interface{}) *Aws_elastic_beanstalk_application {
	r := &Aws_elastic_beanstalk_application{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elastic_beanstalk_application_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_elastic_beanstalk_applicationHandler ...
type Aws_elastic_beanstalk_applicationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elastic_beanstalk_applicationHandler) Create(desired *Aws_elastic_beanstalk_application) (*Aws_elastic_beanstalk_application, string, error) {
	rState := Aws_elastic_beanstalk_applicationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elastic_beanstalk_application", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elastic_beanstalk_applicationHandler) Read(externalID string) (*Aws_elastic_beanstalk_application, error) {
	actual, err := bridge.Read(h.provider, "aws_elastic_beanstalk_application", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elastic_beanstalk_applicationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elastic_beanstalk_applicationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elastic_beanstalk_application", externalID)
}

type Aws_s3_bucket_policy struct {
     Aws_s3_bucket_policy_id *string
     Bucket string
     Policy string
}


func Aws_s3_bucket_policyMapper(r *Aws_s3_bucket_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["bucket"] = r.Bucket
    config["policy"] = r.Policy
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_s3_bucket_policyUnmapper(state map[string]interface{}) *Aws_s3_bucket_policy {
	r := &Aws_s3_bucket_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_s3_bucket_policy_id = &x
}

if x, ok := state["bucket"]; ok {
	r.Bucket = x.(string)
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}
	return r
}


// Aws_s3_bucket_policyHandler ...
type Aws_s3_bucket_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_s3_bucket_policyHandler) Create(desired *Aws_s3_bucket_policy) (*Aws_s3_bucket_policy, string, error) {
	rState := Aws_s3_bucket_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_s3_bucket_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_s3_bucket_policyHandler) Read(externalID string) (*Aws_s3_bucket_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_s3_bucket_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_s3_bucket_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_s3_bucket_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_s3_bucket_policy", externalID)
}

type Aws_lb_listener struct {
     Aws_lb_listener_id *string
     Certificate_arn *string
     Arn *string
     Load_balancer_arn string
     Protocol *string
     Ssl_policy *string
}


func Aws_lb_listenerMapper(r *Aws_lb_listener) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["load_balancer_arn"] = r.Load_balancer_arn
if r.Protocol != nil {
    config["protocol"] = *r.Protocol
}
if r.Ssl_policy != nil {
    config["ssl_policy"] = *r.Ssl_policy
}
if r.Certificate_arn != nil {
    config["certificate_arn"] = *r.Certificate_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lb_listenerUnmapper(state map[string]interface{}) *Aws_lb_listener {
	r := &Aws_lb_listener{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lb_listener_id = &x
}

if x, ok := state["protocol"]; ok {
	x := x.(string)
	r.Protocol = &x
}

if x, ok := state["ssl_policy"]; ok {
	x := x.(string)
	r.Ssl_policy = &x
}

if x, ok := state["certificate_arn"]; ok {
	x := x.(string)
	r.Certificate_arn = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["load_balancer_arn"]; ok {
	r.Load_balancer_arn = x.(string)
}
	return r
}


// Aws_lb_listenerHandler ...
type Aws_lb_listenerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lb_listenerHandler) Create(desired *Aws_lb_listener) (*Aws_lb_listener, string, error) {
	rState := Aws_lb_listenerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lb_listener", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lb_listenerHandler) Read(externalID string) (*Aws_lb_listener, error) {
	actual, err := bridge.Read(h.provider, "aws_lb_listener", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lb_listenerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lb_listenerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lb_listener", externalID)
}

type Aws_secretsmanager_secret struct {
     Aws_secretsmanager_secret_id *string
     Kms_key_id *string
     Name_prefix *string
     Policy *string
     Rotation_enabled *bool
     Arn *string
     Description *string
     Tags *map[string]string
     Name *string
     Rotation_lambda_arn *string
}


func Aws_secretsmanager_secretMapper(r *Aws_secretsmanager_secret) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Policy != nil {
    config["policy"] = *r.Policy
}
if r.Rotation_enabled != nil {
    config["rotation_enabled"] = *r.Rotation_enabled
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Rotation_lambda_arn != nil {
    config["rotation_lambda_arn"] = *r.Rotation_lambda_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_secretsmanager_secretUnmapper(state map[string]interface{}) *Aws_secretsmanager_secret {
	r := &Aws_secretsmanager_secret{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_secretsmanager_secret_id = &x
}

if x, ok := state["rotation_enabled"]; ok {
	x := x.(bool)
	r.Rotation_enabled = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["policy"]; ok {
	x := x.(string)
	r.Policy = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["rotation_lambda_arn"]; ok {
	x := x.(string)
	r.Rotation_lambda_arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_secretsmanager_secretHandler ...
type Aws_secretsmanager_secretHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_secretsmanager_secretHandler) Create(desired *Aws_secretsmanager_secret) (*Aws_secretsmanager_secret, string, error) {
	rState := Aws_secretsmanager_secretMapper(desired)
	id, err := bridge.Create(h.provider, "aws_secretsmanager_secret", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_secretsmanager_secretHandler) Read(externalID string) (*Aws_secretsmanager_secret, error) {
	actual, err := bridge.Read(h.provider, "aws_secretsmanager_secret", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_secretsmanager_secretUnmapper(actual), nil
}

// Delete ...
func (h *Aws_secretsmanager_secretHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_secretsmanager_secret", externalID)
}

type Aws_alb struct {
     Aws_alb_id *string
     Enable_cross_zone_load_balancing *bool
     Vpc_id *string
     Dns_name *string
     Enable_deletion_protection *bool
     Tags *map[string]string
     Enable_http2 *bool
     Ip_address_type *string
     Zone_id *string
     Arn *string
     Arn_suffix *string
     Name *string
     Name_prefix *string
     Internal *bool
     Load_balancer_type *string
}


func Aws_albMapper(r *Aws_alb) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Enable_cross_zone_load_balancing != nil {
    config["enable_cross_zone_load_balancing"] = *r.Enable_cross_zone_load_balancing
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Dns_name != nil {
    config["dns_name"] = *r.Dns_name
}
if r.Enable_deletion_protection != nil {
    config["enable_deletion_protection"] = *r.Enable_deletion_protection
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Zone_id != nil {
    config["zone_id"] = *r.Zone_id
}
if r.Enable_http2 != nil {
    config["enable_http2"] = *r.Enable_http2
}
if r.Ip_address_type != nil {
    config["ip_address_type"] = *r.Ip_address_type
}
if r.Internal != nil {
    config["internal"] = *r.Internal
}
if r.Load_balancer_type != nil {
    config["load_balancer_type"] = *r.Load_balancer_type
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Arn_suffix != nil {
    config["arn_suffix"] = *r.Arn_suffix
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_albUnmapper(state map[string]interface{}) *Aws_alb {
	r := &Aws_alb{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_alb_id = &x
}

if x, ok := state["enable_deletion_protection"]; ok {
	x := x.(bool)
	r.Enable_deletion_protection = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["enable_http2"]; ok {
	x := x.(bool)
	r.Enable_http2 = &x
}

if x, ok := state["ip_address_type"]; ok {
	x := x.(string)
	r.Ip_address_type = &x
}

if x, ok := state["zone_id"]; ok {
	x := x.(string)
	r.Zone_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["internal"]; ok {
	x := x.(bool)
	r.Internal = &x
}

if x, ok := state["load_balancer_type"]; ok {
	x := x.(string)
	r.Load_balancer_type = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["arn_suffix"]; ok {
	x := x.(string)
	r.Arn_suffix = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["dns_name"]; ok {
	x := x.(string)
	r.Dns_name = &x
}

if x, ok := state["enable_cross_zone_load_balancing"]; ok {
	x := x.(bool)
	r.Enable_cross_zone_load_balancing = &x
}
	return r
}


// Aws_albHandler ...
type Aws_albHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_albHandler) Create(desired *Aws_alb) (*Aws_alb, string, error) {
	rState := Aws_albMapper(desired)
	id, err := bridge.Create(h.provider, "aws_alb", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_albHandler) Read(externalID string) (*Aws_alb, error) {
	actual, err := bridge.Read(h.provider, "aws_alb", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_albUnmapper(actual), nil
}

// Delete ...
func (h *Aws_albHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_alb", externalID)
}

type Aws_cloudfront_public_key struct {
     Aws_cloudfront_public_key_id *string
     Name *string
     Name_prefix *string
     Caller_reference *string
     Comment *string
     Encoded_key string
     Etag *string
}


func Aws_cloudfront_public_keyMapper(r *Aws_cloudfront_public_key) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Comment != nil {
    config["comment"] = *r.Comment
}
    config["encoded_key"] = r.Encoded_key
if r.Etag != nil {
    config["etag"] = *r.Etag
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Caller_reference != nil {
    config["caller_reference"] = *r.Caller_reference
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudfront_public_keyUnmapper(state map[string]interface{}) *Aws_cloudfront_public_key {
	r := &Aws_cloudfront_public_key{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudfront_public_key_id = &x
}

if x, ok := state["caller_reference"]; ok {
	x := x.(string)
	r.Caller_reference = &x
}

if x, ok := state["comment"]; ok {
	x := x.(string)
	r.Comment = &x
}

if x, ok := state["encoded_key"]; ok {
	r.Encoded_key = x.(string)
}

if x, ok := state["etag"]; ok {
	x := x.(string)
	r.Etag = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}
	return r
}


// Aws_cloudfront_public_keyHandler ...
type Aws_cloudfront_public_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudfront_public_keyHandler) Create(desired *Aws_cloudfront_public_key) (*Aws_cloudfront_public_key, string, error) {
	rState := Aws_cloudfront_public_keyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudfront_public_key", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudfront_public_keyHandler) Read(externalID string) (*Aws_cloudfront_public_key, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudfront_public_key", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudfront_public_keyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudfront_public_keyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudfront_public_key", externalID)
}

type Aws_iam_user struct {
     Aws_iam_user_id *string
     Tags *map[string]string
     Arn *string
     Unique_id *string
     Name string
     Path *string
     Permissions_boundary *string
     Force_destroy *bool
}


func Aws_iam_userMapper(r *Aws_iam_user) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Unique_id != nil {
    config["unique_id"] = *r.Unique_id
}
    config["name"] = r.Name
if r.Path != nil {
    config["path"] = *r.Path
}
if r.Permissions_boundary != nil {
    config["permissions_boundary"] = *r.Permissions_boundary
}
if r.Force_destroy != nil {
    config["force_destroy"] = *r.Force_destroy
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_userUnmapper(state map[string]interface{}) *Aws_iam_user {
	r := &Aws_iam_user{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_user_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["unique_id"]; ok {
	x := x.(string)
	r.Unique_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["path"]; ok {
	x := x.(string)
	r.Path = &x
}

if x, ok := state["permissions_boundary"]; ok {
	x := x.(string)
	r.Permissions_boundary = &x
}

if x, ok := state["force_destroy"]; ok {
	x := x.(bool)
	r.Force_destroy = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_iam_userHandler ...
type Aws_iam_userHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_userHandler) Create(desired *Aws_iam_user) (*Aws_iam_user, string, error) {
	rState := Aws_iam_userMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_user", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_userHandler) Read(externalID string) (*Aws_iam_user, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_user", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_userUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_userHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_user", externalID)
}

type Aws_volume_attachment struct {
     Aws_volume_attachment_id *string
     Force_detach *bool
     Skip_destroy *bool
     Device_name string
     Instance_id string
     Volume_id string
}


func Aws_volume_attachmentMapper(r *Aws_volume_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["instance_id"] = r.Instance_id
    config["volume_id"] = r.Volume_id
if r.Force_detach != nil {
    config["force_detach"] = *r.Force_detach
}
if r.Skip_destroy != nil {
    config["skip_destroy"] = *r.Skip_destroy
}
    config["device_name"] = r.Device_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_volume_attachmentUnmapper(state map[string]interface{}) *Aws_volume_attachment {
	r := &Aws_volume_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_volume_attachment_id = &x
}

if x, ok := state["force_detach"]; ok {
	x := x.(bool)
	r.Force_detach = &x
}

if x, ok := state["skip_destroy"]; ok {
	x := x.(bool)
	r.Skip_destroy = &x
}

if x, ok := state["device_name"]; ok {
	r.Device_name = x.(string)
}

if x, ok := state["instance_id"]; ok {
	r.Instance_id = x.(string)
}

if x, ok := state["volume_id"]; ok {
	r.Volume_id = x.(string)
}
	return r
}


// Aws_volume_attachmentHandler ...
type Aws_volume_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_volume_attachmentHandler) Create(desired *Aws_volume_attachment) (*Aws_volume_attachment, string, error) {
	rState := Aws_volume_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_volume_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_volume_attachmentHandler) Read(externalID string) (*Aws_volume_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_volume_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_volume_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_volume_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_volume_attachment", externalID)
}

type Aws_waf_size_constraint_set struct {
     Aws_waf_size_constraint_set_id *string
     Name string
}


func Aws_waf_size_constraint_setMapper(r *Aws_waf_size_constraint_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_size_constraint_setUnmapper(state map[string]interface{}) *Aws_waf_size_constraint_set {
	r := &Aws_waf_size_constraint_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_size_constraint_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_waf_size_constraint_setHandler ...
type Aws_waf_size_constraint_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_size_constraint_setHandler) Create(desired *Aws_waf_size_constraint_set) (*Aws_waf_size_constraint_set, string, error) {
	rState := Aws_waf_size_constraint_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_size_constraint_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_size_constraint_setHandler) Read(externalID string) (*Aws_waf_size_constraint_set, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_size_constraint_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_size_constraint_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_size_constraint_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_size_constraint_set", externalID)
}

type Aws_ebs_snapshot_copy struct {
     Aws_ebs_snapshot_copy_id *string
     Description *string
     Kms_key_id *string
     Source_region string
     Tags *map[string]string
     Data_encryption_key_id *string
     Source_snapshot_id string
     Volume_id *string
     Owner_id *string
     Owner_alias *string
     Encrypted *bool
}


func Aws_ebs_snapshot_copyMapper(r *Aws_ebs_snapshot_copy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
if r.Owner_alias != nil {
    config["owner_alias"] = *r.Owner_alias
}
if r.Encrypted != nil {
    config["encrypted"] = *r.Encrypted
}
if r.Data_encryption_key_id != nil {
    config["data_encryption_key_id"] = *r.Data_encryption_key_id
}
    config["source_snapshot_id"] = r.Source_snapshot_id
if r.Volume_id != nil {
    config["volume_id"] = *r.Volume_id
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
    config["source_region"] = r.Source_region
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ebs_snapshot_copyUnmapper(state map[string]interface{}) *Aws_ebs_snapshot_copy {
	r := &Aws_ebs_snapshot_copy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ebs_snapshot_copy_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["source_region"]; ok {
	r.Source_region = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["volume_id"]; ok {
	x := x.(string)
	r.Volume_id = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["owner_alias"]; ok {
	x := x.(string)
	r.Owner_alias = &x
}

if x, ok := state["encrypted"]; ok {
	x := x.(bool)
	r.Encrypted = &x
}

if x, ok := state["data_encryption_key_id"]; ok {
	x := x.(string)
	r.Data_encryption_key_id = &x
}

if x, ok := state["source_snapshot_id"]; ok {
	r.Source_snapshot_id = x.(string)
}
	return r
}


// Aws_ebs_snapshot_copyHandler ...
type Aws_ebs_snapshot_copyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ebs_snapshot_copyHandler) Create(desired *Aws_ebs_snapshot_copy) (*Aws_ebs_snapshot_copy, string, error) {
	rState := Aws_ebs_snapshot_copyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ebs_snapshot_copy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ebs_snapshot_copyHandler) Read(externalID string) (*Aws_ebs_snapshot_copy, error) {
	actual, err := bridge.Read(h.provider, "aws_ebs_snapshot_copy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ebs_snapshot_copyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ebs_snapshot_copyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ebs_snapshot_copy", externalID)
}

type Aws_s3_bucket_metric struct {
     Aws_s3_bucket_metric_id *string
     Bucket string
     Name string
}


func Aws_s3_bucket_metricMapper(r *Aws_s3_bucket_metric) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["bucket"] = r.Bucket
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_s3_bucket_metricUnmapper(state map[string]interface{}) *Aws_s3_bucket_metric {
	r := &Aws_s3_bucket_metric{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_s3_bucket_metric_id = &x
}

if x, ok := state["bucket"]; ok {
	r.Bucket = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_s3_bucket_metricHandler ...
type Aws_s3_bucket_metricHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_s3_bucket_metricHandler) Create(desired *Aws_s3_bucket_metric) (*Aws_s3_bucket_metric, string, error) {
	rState := Aws_s3_bucket_metricMapper(desired)
	id, err := bridge.Create(h.provider, "aws_s3_bucket_metric", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_s3_bucket_metricHandler) Read(externalID string) (*Aws_s3_bucket_metric, error) {
	actual, err := bridge.Read(h.provider, "aws_s3_bucket_metric", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_s3_bucket_metricUnmapper(actual), nil
}

// Delete ...
func (h *Aws_s3_bucket_metricHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_s3_bucket_metric", externalID)
}

type Aws_opsworks_rds_db_instance struct {
     Aws_opsworks_rds_db_instance_id *string
     Stack_id string
     Rds_db_instance_arn string
     Db_password string
     Db_user string
}


func Aws_opsworks_rds_db_instanceMapper(r *Aws_opsworks_rds_db_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["stack_id"] = r.Stack_id
    config["rds_db_instance_arn"] = r.Rds_db_instance_arn
    config["db_password"] = r.Db_password
    config["db_user"] = r.Db_user
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_rds_db_instanceUnmapper(state map[string]interface{}) *Aws_opsworks_rds_db_instance {
	r := &Aws_opsworks_rds_db_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_rds_db_instance_id = &x
}

if x, ok := state["db_password"]; ok {
	r.Db_password = x.(string)
}

if x, ok := state["db_user"]; ok {
	r.Db_user = x.(string)
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["rds_db_instance_arn"]; ok {
	r.Rds_db_instance_arn = x.(string)
}
	return r
}


// Aws_opsworks_rds_db_instanceHandler ...
type Aws_opsworks_rds_db_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_rds_db_instanceHandler) Create(desired *Aws_opsworks_rds_db_instance) (*Aws_opsworks_rds_db_instance, string, error) {
	rState := Aws_opsworks_rds_db_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_rds_db_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_rds_db_instanceHandler) Read(externalID string) (*Aws_opsworks_rds_db_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_rds_db_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_rds_db_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_rds_db_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_rds_db_instance", externalID)
}

type Aws_ssm_document struct {
     Aws_ssm_document_id *string
     Document_type string
     Schema_version *string
     Created_date *string
     Tags *map[string]string
     Document_format *string
     Hash *string
     Default_version *string
     Description *string
     Hash_type *string
     Latest_version *string
     Permissions *map[string]string
     Arn *string
     Name string
     Content string
     Owner *string
     Status *string
}


func Aws_ssm_documentMapper(r *Aws_ssm_document) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["document_type"] = r.Document_type
if r.Schema_version != nil {
    config["schema_version"] = *r.Schema_version
}
if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
if r.Document_format != nil {
    config["document_format"] = *r.Document_format
}
if r.Hash != nil {
    config["hash"] = *r.Hash
}
if r.Latest_version != nil {
    config["latest_version"] = *r.Latest_version
}
if r.Default_version != nil {
    config["default_version"] = *r.Default_version
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Hash_type != nil {
    config["hash_type"] = *r.Hash_type
}
if r.Owner != nil {
    config["owner"] = *r.Owner
}
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Permissions != nil {
    config["permissions"] = *r.Permissions
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
    config["content"] = r.Content
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_documentUnmapper(state map[string]interface{}) *Aws_ssm_document {
	r := &Aws_ssm_document{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_document_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["document_type"]; ok {
	r.Document_type = x.(string)
}

if x, ok := state["schema_version"]; ok {
	x := x.(string)
	r.Schema_version = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}

if x, ok := state["document_format"]; ok {
	x := x.(string)
	r.Document_format = &x
}

if x, ok := state["hash"]; ok {
	x := x.(string)
	r.Hash = &x
}

if x, ok := state["latest_version"]; ok {
	x := x.(string)
	r.Latest_version = &x
}

if x, ok := state["default_version"]; ok {
	x := x.(string)
	r.Default_version = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["hash_type"]; ok {
	x := x.(string)
	r.Hash_type = &x
}

if x, ok := state["owner"]; ok {
	x := x.(string)
	r.Owner = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["permissions"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Permissions = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["content"]; ok {
	r.Content = x.(string)
}
	return r
}


// Aws_ssm_documentHandler ...
type Aws_ssm_documentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_documentHandler) Create(desired *Aws_ssm_document) (*Aws_ssm_document, string, error) {
	rState := Aws_ssm_documentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_document", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_documentHandler) Read(externalID string) (*Aws_ssm_document, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_document", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_documentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_documentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_document", externalID)
}

type Aws_vpc_endpoint_service struct {
     Aws_vpc_endpoint_service_id *string
     State *string
     Service_name *string
     Service_type *string
     Private_dns_name *string
     Acceptance_required bool
}


func Aws_vpc_endpoint_serviceMapper(r *Aws_vpc_endpoint_service) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["acceptance_required"] = r.Acceptance_required
if r.Service_name != nil {
    config["service_name"] = *r.Service_name
}
if r.Service_type != nil {
    config["service_type"] = *r.Service_type
}
if r.Private_dns_name != nil {
    config["private_dns_name"] = *r.Private_dns_name
}
if r.State != nil {
    config["state"] = *r.State
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_endpoint_serviceUnmapper(state map[string]interface{}) *Aws_vpc_endpoint_service {
	r := &Aws_vpc_endpoint_service{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_endpoint_service_id = &x
}

if x, ok := state["acceptance_required"]; ok {
	r.Acceptance_required = x.(bool)
}

if x, ok := state["state"]; ok {
	x := x.(string)
	r.State = &x
}

if x, ok := state["service_name"]; ok {
	x := x.(string)
	r.Service_name = &x
}

if x, ok := state["service_type"]; ok {
	x := x.(string)
	r.Service_type = &x
}

if x, ok := state["private_dns_name"]; ok {
	x := x.(string)
	r.Private_dns_name = &x
}
	return r
}


// Aws_vpc_endpoint_serviceHandler ...
type Aws_vpc_endpoint_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_endpoint_serviceHandler) Create(desired *Aws_vpc_endpoint_service) (*Aws_vpc_endpoint_service, string, error) {
	rState := Aws_vpc_endpoint_serviceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_endpoint_service", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_endpoint_serviceHandler) Read(externalID string) (*Aws_vpc_endpoint_service, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_endpoint_service", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_endpoint_serviceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_endpoint_serviceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_endpoint_service", externalID)
}

type Aws_cloudwatch_metric_alarm struct {
     Aws_cloudwatch_metric_alarm_id *string
     Unit *string
     Alarm_name string
     Arn *string
     Statistic *string
     Metric_name string
     Namespace string
     Actions_enabled *bool
     Evaluate_low_sample_count_percentiles *string
     Comparison_operator string
     Treat_missing_data *string
     Extended_statistic *string
     Alarm_description *string
     Dimensions *map[string]string
}


func Aws_cloudwatch_metric_alarmMapper(r *Aws_cloudwatch_metric_alarm) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Treat_missing_data != nil {
    config["treat_missing_data"] = *r.Treat_missing_data
}
if r.Evaluate_low_sample_count_percentiles != nil {
    config["evaluate_low_sample_count_percentiles"] = *r.Evaluate_low_sample_count_percentiles
}
    config["comparison_operator"] = r.Comparison_operator
if r.Extended_statistic != nil {
    config["extended_statistic"] = *r.Extended_statistic
}
if r.Alarm_description != nil {
    config["alarm_description"] = *r.Alarm_description
}
if r.Dimensions != nil {
    config["dimensions"] = *r.Dimensions
}
if r.Unit != nil {
    config["unit"] = *r.Unit
}
    config["alarm_name"] = r.Alarm_name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Statistic != nil {
    config["statistic"] = *r.Statistic
}
if r.Actions_enabled != nil {
    config["actions_enabled"] = *r.Actions_enabled
}
    config["metric_name"] = r.Metric_name
    config["namespace"] = r.Namespace
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_metric_alarmUnmapper(state map[string]interface{}) *Aws_cloudwatch_metric_alarm {
	r := &Aws_cloudwatch_metric_alarm{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_metric_alarm_id = &x
}

if x, ok := state["metric_name"]; ok {
	r.Metric_name = x.(string)
}

if x, ok := state["namespace"]; ok {
	r.Namespace = x.(string)
}

if x, ok := state["actions_enabled"]; ok {
	x := x.(bool)
	r.Actions_enabled = &x
}

if x, ok := state["comparison_operator"]; ok {
	r.Comparison_operator = x.(string)
}

if x, ok := state["treat_missing_data"]; ok {
	x := x.(string)
	r.Treat_missing_data = &x
}

if x, ok := state["evaluate_low_sample_count_percentiles"]; ok {
	x := x.(string)
	r.Evaluate_low_sample_count_percentiles = &x
}

if x, ok := state["alarm_description"]; ok {
	x := x.(string)
	r.Alarm_description = &x
}

if x, ok := state["dimensions"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Dimensions = &x
}

if x, ok := state["extended_statistic"]; ok {
	x := x.(string)
	r.Extended_statistic = &x
}

if x, ok := state["alarm_name"]; ok {
	r.Alarm_name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["statistic"]; ok {
	x := x.(string)
	r.Statistic = &x
}

if x, ok := state["unit"]; ok {
	x := x.(string)
	r.Unit = &x
}
	return r
}


// Aws_cloudwatch_metric_alarmHandler ...
type Aws_cloudwatch_metric_alarmHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_metric_alarmHandler) Create(desired *Aws_cloudwatch_metric_alarm) (*Aws_cloudwatch_metric_alarm, string, error) {
	rState := Aws_cloudwatch_metric_alarmMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_metric_alarm", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_metric_alarmHandler) Read(externalID string) (*Aws_cloudwatch_metric_alarm, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_metric_alarm", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_metric_alarmUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_metric_alarmHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_metric_alarm", externalID)
}

type Aws_dynamodb_table struct {
     Aws_dynamodb_table_id *string
     Arn *string
     Billing_mode *string
     Stream_enabled *bool
     Stream_view_type *string
     Name string
     Hash_key string
     Range_key *string
     Stream_arn *string
     Tags *map[string]string
     Stream_label *string
}


func Aws_dynamodb_tableMapper(r *Aws_dynamodb_table) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Range_key != nil {
    config["range_key"] = *r.Range_key
}
if r.Stream_arn != nil {
    config["stream_arn"] = *r.Stream_arn
}
if r.Stream_label != nil {
    config["stream_label"] = *r.Stream_label
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Billing_mode != nil {
    config["billing_mode"] = *r.Billing_mode
}
if r.Stream_enabled != nil {
    config["stream_enabled"] = *r.Stream_enabled
}
if r.Stream_view_type != nil {
    config["stream_view_type"] = *r.Stream_view_type
}
    config["name"] = r.Name
    config["hash_key"] = r.Hash_key
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dynamodb_tableUnmapper(state map[string]interface{}) *Aws_dynamodb_table {
	r := &Aws_dynamodb_table{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dynamodb_table_id = &x
}

if x, ok := state["stream_view_type"]; ok {
	x := x.(string)
	r.Stream_view_type = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["hash_key"]; ok {
	r.Hash_key = x.(string)
}

if x, ok := state["stream_enabled"]; ok {
	x := x.(bool)
	r.Stream_enabled = &x
}

if x, ok := state["range_key"]; ok {
	x := x.(string)
	r.Range_key = &x
}

if x, ok := state["stream_arn"]; ok {
	x := x.(string)
	r.Stream_arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["stream_label"]; ok {
	x := x.(string)
	r.Stream_label = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["billing_mode"]; ok {
	x := x.(string)
	r.Billing_mode = &x
}
	return r
}


// Aws_dynamodb_tableHandler ...
type Aws_dynamodb_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dynamodb_tableHandler) Create(desired *Aws_dynamodb_table) (*Aws_dynamodb_table, string, error) {
	rState := Aws_dynamodb_tableMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dynamodb_table", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dynamodb_tableHandler) Read(externalID string) (*Aws_dynamodb_table, error) {
	actual, err := bridge.Read(h.provider, "aws_dynamodb_table", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dynamodb_tableUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dynamodb_tableHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dynamodb_table", externalID)
}

type Aws_ecs_cluster struct {
     Aws_ecs_cluster_id *string
     Name string
     Tags *map[string]string
     Arn *string
}


func Aws_ecs_clusterMapper(r *Aws_ecs_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ecs_clusterUnmapper(state map[string]interface{}) *Aws_ecs_cluster {
	r := &Aws_ecs_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ecs_cluster_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_ecs_clusterHandler ...
type Aws_ecs_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ecs_clusterHandler) Create(desired *Aws_ecs_cluster) (*Aws_ecs_cluster, string, error) {
	rState := Aws_ecs_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ecs_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ecs_clusterHandler) Read(externalID string) (*Aws_ecs_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_ecs_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ecs_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ecs_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ecs_cluster", externalID)
}

type Aws_sfn_state_machine struct {
     Aws_sfn_state_machine_id *string
     Role_arn string
     Creation_date *string
     Status *string
     Tags *map[string]string
     Definition string
     Name string
}


func Aws_sfn_state_machineMapper(r *Aws_sfn_state_machine) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["definition"] = r.Definition
    config["name"] = r.Name
    config["role_arn"] = r.Role_arn
if r.Creation_date != nil {
    config["creation_date"] = *r.Creation_date
}
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sfn_state_machineUnmapper(state map[string]interface{}) *Aws_sfn_state_machine {
	r := &Aws_sfn_state_machine{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sfn_state_machine_id = &x
}

if x, ok := state["definition"]; ok {
	r.Definition = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}

if x, ok := state["creation_date"]; ok {
	x := x.(string)
	r.Creation_date = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_sfn_state_machineHandler ...
type Aws_sfn_state_machineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sfn_state_machineHandler) Create(desired *Aws_sfn_state_machine) (*Aws_sfn_state_machine, string, error) {
	rState := Aws_sfn_state_machineMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sfn_state_machine", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sfn_state_machineHandler) Read(externalID string) (*Aws_sfn_state_machine, error) {
	actual, err := bridge.Read(h.provider, "aws_sfn_state_machine", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sfn_state_machineUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sfn_state_machineHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sfn_state_machine", externalID)
}

type Aws_wafregional_rate_based_rule struct {
     Aws_wafregional_rate_based_rule_id *string
     Rate_key string
     Name string
     Metric_name string
}


func Aws_wafregional_rate_based_ruleMapper(r *Aws_wafregional_rate_based_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["metric_name"] = r.Metric_name
    config["rate_key"] = r.Rate_key
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_rate_based_ruleUnmapper(state map[string]interface{}) *Aws_wafregional_rate_based_rule {
	r := &Aws_wafregional_rate_based_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_rate_based_rule_id = &x
}

if x, ok := state["metric_name"]; ok {
	r.Metric_name = x.(string)
}

if x, ok := state["rate_key"]; ok {
	r.Rate_key = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_wafregional_rate_based_ruleHandler ...
type Aws_wafregional_rate_based_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_rate_based_ruleHandler) Create(desired *Aws_wafregional_rate_based_rule) (*Aws_wafregional_rate_based_rule, string, error) {
	rState := Aws_wafregional_rate_based_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_rate_based_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_rate_based_ruleHandler) Read(externalID string) (*Aws_wafregional_rate_based_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_rate_based_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_rate_based_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_rate_based_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_rate_based_rule", externalID)
}

type Aws_api_gateway_usage_plan struct {
     Aws_api_gateway_usage_plan_id *string
     Name string
     Description *string
     Product_code *string
}


func Aws_api_gateway_usage_planMapper(r *Aws_api_gateway_usage_plan) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Product_code != nil {
    config["product_code"] = *r.Product_code
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_usage_planUnmapper(state map[string]interface{}) *Aws_api_gateway_usage_plan {
	r := &Aws_api_gateway_usage_plan{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_usage_plan_id = &x
}

if x, ok := state["product_code"]; ok {
	x := x.(string)
	r.Product_code = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_api_gateway_usage_planHandler ...
type Aws_api_gateway_usage_planHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_usage_planHandler) Create(desired *Aws_api_gateway_usage_plan) (*Aws_api_gateway_usage_plan, string, error) {
	rState := Aws_api_gateway_usage_planMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_usage_plan", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_usage_planHandler) Read(externalID string) (*Aws_api_gateway_usage_plan, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_usage_plan", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_usage_planUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_usage_planHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_usage_plan", externalID)
}

type Aws_autoscaling_schedule struct {
     Aws_autoscaling_schedule_id *string
     Start_time *string
     Recurrence *string
     Scheduled_action_name string
     Autoscaling_group_name string
     Arn *string
     End_time *string
}


func Aws_autoscaling_scheduleMapper(r *Aws_autoscaling_schedule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.End_time != nil {
    config["end_time"] = *r.End_time
}
if r.Recurrence != nil {
    config["recurrence"] = *r.Recurrence
}
    config["scheduled_action_name"] = r.Scheduled_action_name
    config["autoscaling_group_name"] = r.Autoscaling_group_name
if r.Start_time != nil {
    config["start_time"] = *r.Start_time
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_autoscaling_scheduleUnmapper(state map[string]interface{}) *Aws_autoscaling_schedule {
	r := &Aws_autoscaling_schedule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_autoscaling_schedule_id = &x
}

if x, ok := state["start_time"]; ok {
	x := x.(string)
	r.Start_time = &x
}

if x, ok := state["recurrence"]; ok {
	x := x.(string)
	r.Recurrence = &x
}

if x, ok := state["scheduled_action_name"]; ok {
	r.Scheduled_action_name = x.(string)
}

if x, ok := state["autoscaling_group_name"]; ok {
	r.Autoscaling_group_name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["end_time"]; ok {
	x := x.(string)
	r.End_time = &x
}
	return r
}


// Aws_autoscaling_scheduleHandler ...
type Aws_autoscaling_scheduleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_autoscaling_scheduleHandler) Create(desired *Aws_autoscaling_schedule) (*Aws_autoscaling_schedule, string, error) {
	rState := Aws_autoscaling_scheduleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_autoscaling_schedule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_autoscaling_scheduleHandler) Read(externalID string) (*Aws_autoscaling_schedule, error) {
	actual, err := bridge.Read(h.provider, "aws_autoscaling_schedule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_autoscaling_scheduleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_autoscaling_scheduleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_autoscaling_schedule", externalID)
}

type Aws_ssm_maintenance_window struct {
     Aws_ssm_maintenance_window_id *string
     Schedule_timezone *string
     Name string
     Allow_unassociated_targets *bool
     Enabled *bool
     End_date *string
     Start_date *string
     Schedule string
}


func Aws_ssm_maintenance_windowMapper(r *Aws_ssm_maintenance_window) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Schedule_timezone != nil {
    config["schedule_timezone"] = *r.Schedule_timezone
}
    config["name"] = r.Name
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.End_date != nil {
    config["end_date"] = *r.End_date
}
if r.Start_date != nil {
    config["start_date"] = *r.Start_date
}
    config["schedule"] = r.Schedule
if r.Allow_unassociated_targets != nil {
    config["allow_unassociated_targets"] = *r.Allow_unassociated_targets
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_maintenance_windowUnmapper(state map[string]interface{}) *Aws_ssm_maintenance_window {
	r := &Aws_ssm_maintenance_window{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_maintenance_window_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["schedule_timezone"]; ok {
	x := x.(string)
	r.Schedule_timezone = &x
}

if x, ok := state["start_date"]; ok {
	x := x.(string)
	r.Start_date = &x
}

if x, ok := state["schedule"]; ok {
	r.Schedule = x.(string)
}

if x, ok := state["allow_unassociated_targets"]; ok {
	x := x.(bool)
	r.Allow_unassociated_targets = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["end_date"]; ok {
	x := x.(string)
	r.End_date = &x
}
	return r
}


// Aws_ssm_maintenance_windowHandler ...
type Aws_ssm_maintenance_windowHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_maintenance_windowHandler) Create(desired *Aws_ssm_maintenance_window) (*Aws_ssm_maintenance_window, string, error) {
	rState := Aws_ssm_maintenance_windowMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_maintenance_window", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_maintenance_windowHandler) Read(externalID string) (*Aws_ssm_maintenance_window, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_maintenance_window", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_maintenance_windowUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_maintenance_windowHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_maintenance_window", externalID)
}

type Aws_dx_lag struct {
     Aws_dx_lag_id *string
     Arn *string
     Name string
     Connections_bandwidth string
     Location string
     Force_destroy *bool
     Tags *map[string]string
}


func Aws_dx_lagMapper(r *Aws_dx_lag) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["connections_bandwidth"] = r.Connections_bandwidth
    config["location"] = r.Location
if r.Force_destroy != nil {
    config["force_destroy"] = *r.Force_destroy
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dx_lagUnmapper(state map[string]interface{}) *Aws_dx_lag {
	r := &Aws_dx_lag{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dx_lag_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["connections_bandwidth"]; ok {
	r.Connections_bandwidth = x.(string)
}

if x, ok := state["location"]; ok {
	r.Location = x.(string)
}

if x, ok := state["force_destroy"]; ok {
	x := x.(bool)
	r.Force_destroy = &x
}
	return r
}


// Aws_dx_lagHandler ...
type Aws_dx_lagHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dx_lagHandler) Create(desired *Aws_dx_lag) (*Aws_dx_lag, string, error) {
	rState := Aws_dx_lagMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dx_lag", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dx_lagHandler) Read(externalID string) (*Aws_dx_lag, error) {
	actual, err := bridge.Read(h.provider, "aws_dx_lag", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dx_lagUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dx_lagHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dx_lag", externalID)
}

type Aws_route53_health_check struct {
     Aws_route53_health_check_id *string
     Search_string *string
     Measure_latency *bool
     Enable_sni *bool
     Tags *map[string]string
     Ip_address *string
     Invert_healthcheck *bool
     Fqdn *string
     Cloudwatch_alarm_region *string
     Reference_name *string
     Resource_type string
     Insufficient_data_health_status *string
     Resource_path *string
     Cloudwatch_alarm_name *string
}


func Aws_route53_health_checkMapper(r *Aws_route53_health_check) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Resource_path != nil {
    config["resource_path"] = *r.Resource_path
}
if r.Cloudwatch_alarm_name != nil {
    config["cloudwatch_alarm_name"] = *r.Cloudwatch_alarm_name
}
if r.Insufficient_data_health_status != nil {
    config["insufficient_data_health_status"] = *r.Insufficient_data_health_status
}
if r.Enable_sni != nil {
    config["enable_sni"] = *r.Enable_sni
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Ip_address != nil {
    config["ip_address"] = *r.Ip_address
}
if r.Invert_healthcheck != nil {
    config["invert_healthcheck"] = *r.Invert_healthcheck
}
if r.Search_string != nil {
    config["search_string"] = *r.Search_string
}
if r.Measure_latency != nil {
    config["measure_latency"] = *r.Measure_latency
}
if r.Fqdn != nil {
    config["fqdn"] = *r.Fqdn
}
if r.Cloudwatch_alarm_region != nil {
    config["cloudwatch_alarm_region"] = *r.Cloudwatch_alarm_region
}
if r.Reference_name != nil {
    config["reference_name"] = *r.Reference_name
}
    config["resource_type"] = r.Resource_type
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_route53_health_checkUnmapper(state map[string]interface{}) *Aws_route53_health_check {
	r := &Aws_route53_health_check{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_route53_health_check_id = &x
}

if x, ok := state["fqdn"]; ok {
	x := x.(string)
	r.Fqdn = &x
}

if x, ok := state["cloudwatch_alarm_region"]; ok {
	x := x.(string)
	r.Cloudwatch_alarm_region = &x
}

if x, ok := state["reference_name"]; ok {
	x := x.(string)
	r.Reference_name = &x
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["resource_path"]; ok {
	x := x.(string)
	r.Resource_path = &x
}

if x, ok := state["cloudwatch_alarm_name"]; ok {
	x := x.(string)
	r.Cloudwatch_alarm_name = &x
}

if x, ok := state["insufficient_data_health_status"]; ok {
	x := x.(string)
	r.Insufficient_data_health_status = &x
}

if x, ok := state["enable_sni"]; ok {
	x := x.(bool)
	r.Enable_sni = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["ip_address"]; ok {
	x := x.(string)
	r.Ip_address = &x
}

if x, ok := state["invert_healthcheck"]; ok {
	x := x.(bool)
	r.Invert_healthcheck = &x
}

if x, ok := state["search_string"]; ok {
	x := x.(string)
	r.Search_string = &x
}

if x, ok := state["measure_latency"]; ok {
	x := x.(bool)
	r.Measure_latency = &x
}
	return r
}


// Aws_route53_health_checkHandler ...
type Aws_route53_health_checkHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_route53_health_checkHandler) Create(desired *Aws_route53_health_check) (*Aws_route53_health_check, string, error) {
	rState := Aws_route53_health_checkMapper(desired)
	id, err := bridge.Create(h.provider, "aws_route53_health_check", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_route53_health_checkHandler) Read(externalID string) (*Aws_route53_health_check, error) {
	actual, err := bridge.Read(h.provider, "aws_route53_health_check", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_route53_health_checkUnmapper(actual), nil
}

// Delete ...
func (h *Aws_route53_health_checkHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_route53_health_check", externalID)
}

type Aws_nat_gateway struct {
     Aws_nat_gateway_id *string
     Subnet_id string
     Network_interface_id *string
     Private_ip *string
     Public_ip *string
     Tags *map[string]string
     Allocation_id string
}


func Aws_nat_gatewayMapper(r *Aws_nat_gateway) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["allocation_id"] = r.Allocation_id
    config["subnet_id"] = r.Subnet_id
if r.Network_interface_id != nil {
    config["network_interface_id"] = *r.Network_interface_id
}
if r.Private_ip != nil {
    config["private_ip"] = *r.Private_ip
}
if r.Public_ip != nil {
    config["public_ip"] = *r.Public_ip
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_nat_gatewayUnmapper(state map[string]interface{}) *Aws_nat_gateway {
	r := &Aws_nat_gateway{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_nat_gateway_id = &x
}

if x, ok := state["network_interface_id"]; ok {
	x := x.(string)
	r.Network_interface_id = &x
}

if x, ok := state["private_ip"]; ok {
	x := x.(string)
	r.Private_ip = &x
}

if x, ok := state["public_ip"]; ok {
	x := x.(string)
	r.Public_ip = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["allocation_id"]; ok {
	r.Allocation_id = x.(string)
}

if x, ok := state["subnet_id"]; ok {
	r.Subnet_id = x.(string)
}
	return r
}


// Aws_nat_gatewayHandler ...
type Aws_nat_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_nat_gatewayHandler) Create(desired *Aws_nat_gateway) (*Aws_nat_gateway, string, error) {
	rState := Aws_nat_gatewayMapper(desired)
	id, err := bridge.Create(h.provider, "aws_nat_gateway", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_nat_gatewayHandler) Read(externalID string) (*Aws_nat_gateway, error) {
	actual, err := bridge.Read(h.provider, "aws_nat_gateway", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_nat_gatewayUnmapper(actual), nil
}

// Delete ...
func (h *Aws_nat_gatewayHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_nat_gateway", externalID)
}

type Aws_neptune_parameter_group struct {
     Aws_neptune_parameter_group_id *string
     Name string
     Family string
     Description *string
     Tags *map[string]string
     Arn *string
}


func Aws_neptune_parameter_groupMapper(r *Aws_neptune_parameter_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
    config["family"] = r.Family
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_neptune_parameter_groupUnmapper(state map[string]interface{}) *Aws_neptune_parameter_group {
	r := &Aws_neptune_parameter_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_neptune_parameter_group_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["family"]; ok {
	r.Family = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_neptune_parameter_groupHandler ...
type Aws_neptune_parameter_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_neptune_parameter_groupHandler) Create(desired *Aws_neptune_parameter_group) (*Aws_neptune_parameter_group, string, error) {
	rState := Aws_neptune_parameter_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_neptune_parameter_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_neptune_parameter_groupHandler) Read(externalID string) (*Aws_neptune_parameter_group, error) {
	actual, err := bridge.Read(h.provider, "aws_neptune_parameter_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_neptune_parameter_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_neptune_parameter_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_neptune_parameter_group", externalID)
}

type Aws_elasticache_subnet_group struct {
     Aws_elasticache_subnet_group_id *string
     Description *string
     Name string
}


func Aws_elasticache_subnet_groupMapper(r *Aws_elasticache_subnet_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elasticache_subnet_groupUnmapper(state map[string]interface{}) *Aws_elasticache_subnet_group {
	r := &Aws_elasticache_subnet_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elasticache_subnet_group_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_elasticache_subnet_groupHandler ...
type Aws_elasticache_subnet_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elasticache_subnet_groupHandler) Create(desired *Aws_elasticache_subnet_group) (*Aws_elasticache_subnet_group, string, error) {
	rState := Aws_elasticache_subnet_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elasticache_subnet_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elasticache_subnet_groupHandler) Read(externalID string) (*Aws_elasticache_subnet_group, error) {
	actual, err := bridge.Read(h.provider, "aws_elasticache_subnet_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elasticache_subnet_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elasticache_subnet_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elasticache_subnet_group", externalID)
}

type Aws_licensemanager_association struct {
     Aws_licensemanager_association_id *string
     Resource_arn string
     License_configuration_arn string
}


func Aws_licensemanager_associationMapper(r *Aws_licensemanager_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["resource_arn"] = r.Resource_arn
    config["license_configuration_arn"] = r.License_configuration_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_licensemanager_associationUnmapper(state map[string]interface{}) *Aws_licensemanager_association {
	r := &Aws_licensemanager_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_licensemanager_association_id = &x
}

if x, ok := state["resource_arn"]; ok {
	r.Resource_arn = x.(string)
}

if x, ok := state["license_configuration_arn"]; ok {
	r.License_configuration_arn = x.(string)
}
	return r
}


// Aws_licensemanager_associationHandler ...
type Aws_licensemanager_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_licensemanager_associationHandler) Create(desired *Aws_licensemanager_association) (*Aws_licensemanager_association, string, error) {
	rState := Aws_licensemanager_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_licensemanager_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_licensemanager_associationHandler) Read(externalID string) (*Aws_licensemanager_association, error) {
	actual, err := bridge.Read(h.provider, "aws_licensemanager_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_licensemanager_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_licensemanager_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_licensemanager_association", externalID)
}

type Aws_opsworks_custom_layer struct {
     Aws_opsworks_custom_layer_id *string
     Install_updates_on_boot *bool
     Auto_assign_public_ips *bool
     Elastic_load_balancer *string
     Auto_assign_elastic_ips *bool
     Custom_instance_profile_arn *string
     Drain_elb_on_shutdown *bool
     Custom_json *string
     Use_ebs_optimized_instances *bool
     Name string
     Auto_healing *bool
     Stack_id string
     Short_name string
}


func Aws_opsworks_custom_layerMapper(r *Aws_opsworks_custom_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["short_name"] = r.Short_name
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
    config["stack_id"] = r.Stack_id
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_custom_layerUnmapper(state map[string]interface{}) *Aws_opsworks_custom_layer {
	r := &Aws_opsworks_custom_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_custom_layer_id = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["short_name"]; ok {
	r.Short_name = x.(string)
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}
	return r
}


// Aws_opsworks_custom_layerHandler ...
type Aws_opsworks_custom_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_custom_layerHandler) Create(desired *Aws_opsworks_custom_layer) (*Aws_opsworks_custom_layer, string, error) {
	rState := Aws_opsworks_custom_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_custom_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_custom_layerHandler) Read(externalID string) (*Aws_opsworks_custom_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_custom_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_custom_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_custom_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_custom_layer", externalID)
}

type Aws_datasync_location_efs struct {
     Aws_datasync_location_efs_id *string
     Efs_file_system_arn string
     Subdirectory *string
     Tags *map[string]string
     Uri *string
     Arn *string
}


func Aws_datasync_location_efsMapper(r *Aws_datasync_location_efs) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["efs_file_system_arn"] = r.Efs_file_system_arn
if r.Subdirectory != nil {
    config["subdirectory"] = *r.Subdirectory
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Uri != nil {
    config["uri"] = *r.Uri
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_datasync_location_efsUnmapper(state map[string]interface{}) *Aws_datasync_location_efs {
	r := &Aws_datasync_location_efs{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_datasync_location_efs_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["efs_file_system_arn"]; ok {
	r.Efs_file_system_arn = x.(string)
}

if x, ok := state["subdirectory"]; ok {
	x := x.(string)
	r.Subdirectory = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["uri"]; ok {
	x := x.(string)
	r.Uri = &x
}
	return r
}


// Aws_datasync_location_efsHandler ...
type Aws_datasync_location_efsHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_datasync_location_efsHandler) Create(desired *Aws_datasync_location_efs) (*Aws_datasync_location_efs, string, error) {
	rState := Aws_datasync_location_efsMapper(desired)
	id, err := bridge.Create(h.provider, "aws_datasync_location_efs", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_datasync_location_efsHandler) Read(externalID string) (*Aws_datasync_location_efs, error) {
	actual, err := bridge.Read(h.provider, "aws_datasync_location_efs", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_datasync_location_efsUnmapper(actual), nil
}

// Delete ...
func (h *Aws_datasync_location_efsHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_datasync_location_efs", externalID)
}

type Aws_vpn_connection struct {
     Aws_vpn_connection_id *string
     Tunnel1_preshared_key *string
     Tags *map[string]string
     Tunnel1_vgw_inside_address *string
     Tunnel2_bgp_asn *string
     Customer_gateway_id string
     Resource_type string
     Tunnel2_inside_cidr *string
     Tunnel2_vgw_inside_address *string
     Tunnel1_cgw_inside_address *string
     Tunnel1_bgp_asn *string
     Tunnel2_address *string
     Vpn_gateway_id *string
     Static_routes_only *bool
     Tunnel1_inside_cidr *string
     Tunnel2_preshared_key *string
     Tunnel1_address *string
     Tunnel2_cgw_inside_address *string
     Transit_gateway_id *string
     Customer_gateway_configuration *string
}


func Aws_vpn_connectionMapper(r *Aws_vpn_connection) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tunnel2_vgw_inside_address != nil {
    config["tunnel2_vgw_inside_address"] = *r.Tunnel2_vgw_inside_address
}
    config["customer_gateway_id"] = r.Customer_gateway_id
    config["resource_type"] = r.Resource_type
if r.Tunnel2_inside_cidr != nil {
    config["tunnel2_inside_cidr"] = *r.Tunnel2_inside_cidr
}
if r.Tunnel2_preshared_key != nil {
    config["tunnel2_preshared_key"] = *r.Tunnel2_preshared_key
}
if r.Tunnel1_address != nil {
    config["tunnel1_address"] = *r.Tunnel1_address
}
if r.Tunnel1_cgw_inside_address != nil {
    config["tunnel1_cgw_inside_address"] = *r.Tunnel1_cgw_inside_address
}
if r.Tunnel1_bgp_asn != nil {
    config["tunnel1_bgp_asn"] = *r.Tunnel1_bgp_asn
}
if r.Tunnel2_address != nil {
    config["tunnel2_address"] = *r.Tunnel2_address
}
if r.Vpn_gateway_id != nil {
    config["vpn_gateway_id"] = *r.Vpn_gateway_id
}
if r.Static_routes_only != nil {
    config["static_routes_only"] = *r.Static_routes_only
}
if r.Tunnel1_inside_cidr != nil {
    config["tunnel1_inside_cidr"] = *r.Tunnel1_inside_cidr
}
if r.Tunnel2_cgw_inside_address != nil {
    config["tunnel2_cgw_inside_address"] = *r.Tunnel2_cgw_inside_address
}
if r.Transit_gateway_id != nil {
    config["transit_gateway_id"] = *r.Transit_gateway_id
}
if r.Customer_gateway_configuration != nil {
    config["customer_gateway_configuration"] = *r.Customer_gateway_configuration
}
if r.Tunnel2_bgp_asn != nil {
    config["tunnel2_bgp_asn"] = *r.Tunnel2_bgp_asn
}
if r.Tunnel1_preshared_key != nil {
    config["tunnel1_preshared_key"] = *r.Tunnel1_preshared_key
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Tunnel1_vgw_inside_address != nil {
    config["tunnel1_vgw_inside_address"] = *r.Tunnel1_vgw_inside_address
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpn_connectionUnmapper(state map[string]interface{}) *Aws_vpn_connection {
	r := &Aws_vpn_connection{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpn_connection_id = &x
}

if x, ok := state["tunnel1_cgw_inside_address"]; ok {
	x := x.(string)
	r.Tunnel1_cgw_inside_address = &x
}

if x, ok := state["tunnel1_bgp_asn"]; ok {
	x := x.(string)
	r.Tunnel1_bgp_asn = &x
}

if x, ok := state["tunnel2_address"]; ok {
	x := x.(string)
	r.Tunnel2_address = &x
}

if x, ok := state["vpn_gateway_id"]; ok {
	x := x.(string)
	r.Vpn_gateway_id = &x
}

if x, ok := state["static_routes_only"]; ok {
	x := x.(bool)
	r.Static_routes_only = &x
}

if x, ok := state["tunnel1_inside_cidr"]; ok {
	x := x.(string)
	r.Tunnel1_inside_cidr = &x
}

if x, ok := state["tunnel2_preshared_key"]; ok {
	x := x.(string)
	r.Tunnel2_preshared_key = &x
}

if x, ok := state["tunnel1_address"]; ok {
	x := x.(string)
	r.Tunnel1_address = &x
}

if x, ok := state["tunnel2_cgw_inside_address"]; ok {
	x := x.(string)
	r.Tunnel2_cgw_inside_address = &x
}

if x, ok := state["transit_gateway_id"]; ok {
	x := x.(string)
	r.Transit_gateway_id = &x
}

if x, ok := state["customer_gateway_configuration"]; ok {
	x := x.(string)
	r.Customer_gateway_configuration = &x
}

if x, ok := state["tunnel1_preshared_key"]; ok {
	x := x.(string)
	r.Tunnel1_preshared_key = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["tunnel1_vgw_inside_address"]; ok {
	x := x.(string)
	r.Tunnel1_vgw_inside_address = &x
}

if x, ok := state["tunnel2_bgp_asn"]; ok {
	x := x.(string)
	r.Tunnel2_bgp_asn = &x
}

if x, ok := state["customer_gateway_id"]; ok {
	r.Customer_gateway_id = x.(string)
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["tunnel2_inside_cidr"]; ok {
	x := x.(string)
	r.Tunnel2_inside_cidr = &x
}

if x, ok := state["tunnel2_vgw_inside_address"]; ok {
	x := x.(string)
	r.Tunnel2_vgw_inside_address = &x
}
	return r
}


// Aws_vpn_connectionHandler ...
type Aws_vpn_connectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpn_connectionHandler) Create(desired *Aws_vpn_connection) (*Aws_vpn_connection, string, error) {
	rState := Aws_vpn_connectionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpn_connection", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpn_connectionHandler) Read(externalID string) (*Aws_vpn_connection, error) {
	actual, err := bridge.Read(h.provider, "aws_vpn_connection", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpn_connectionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpn_connectionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpn_connection", externalID)
}

type Aws_elasticsearch_domain_policy struct {
     Aws_elasticsearch_domain_policy_id *string
     Domain_name string
     Access_policies string
}


func Aws_elasticsearch_domain_policyMapper(r *Aws_elasticsearch_domain_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["domain_name"] = r.Domain_name
    config["access_policies"] = r.Access_policies
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elasticsearch_domain_policyUnmapper(state map[string]interface{}) *Aws_elasticsearch_domain_policy {
	r := &Aws_elasticsearch_domain_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elasticsearch_domain_policy_id = &x
}

if x, ok := state["domain_name"]; ok {
	r.Domain_name = x.(string)
}

if x, ok := state["access_policies"]; ok {
	r.Access_policies = x.(string)
}
	return r
}


// Aws_elasticsearch_domain_policyHandler ...
type Aws_elasticsearch_domain_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elasticsearch_domain_policyHandler) Create(desired *Aws_elasticsearch_domain_policy) (*Aws_elasticsearch_domain_policy, string, error) {
	rState := Aws_elasticsearch_domain_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elasticsearch_domain_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elasticsearch_domain_policyHandler) Read(externalID string) (*Aws_elasticsearch_domain_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_elasticsearch_domain_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elasticsearch_domain_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elasticsearch_domain_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elasticsearch_domain_policy", externalID)
}

type Aws_opsworks_static_web_layer struct {
     Aws_opsworks_static_web_layer_id *string
     Auto_assign_public_ips *bool
     Elastic_load_balancer *string
     Stack_id string
     Auto_assign_elastic_ips *bool
     Custom_json *string
     Drain_elb_on_shutdown *bool
     Name *string
     Auto_healing *bool
     Custom_instance_profile_arn *string
     Install_updates_on_boot *bool
     Use_ebs_optimized_instances *bool
}


func Aws_opsworks_static_web_layerMapper(r *Aws_opsworks_static_web_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
    config["stack_id"] = r.Stack_id
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_static_web_layerUnmapper(state map[string]interface{}) *Aws_opsworks_static_web_layer {
	r := &Aws_opsworks_static_web_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_static_web_layer_id = &x
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}
	return r
}


// Aws_opsworks_static_web_layerHandler ...
type Aws_opsworks_static_web_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_static_web_layerHandler) Create(desired *Aws_opsworks_static_web_layer) (*Aws_opsworks_static_web_layer, string, error) {
	rState := Aws_opsworks_static_web_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_static_web_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_static_web_layerHandler) Read(externalID string) (*Aws_opsworks_static_web_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_static_web_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_static_web_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_static_web_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_static_web_layer", externalID)
}

type Aws_ami_copy struct {
     Aws_ami_copy_id *string
     Root_device_name *string
     Source_ami_id string
     Architecture *string
     Description *string
     Encrypted *bool
     Image_location *string
     Kernel_id *string
     Source_ami_region string
     Root_snapshot_id *string
     Sriov_net_support *string
     Virtualization_type *string
     Manage_ebs_snapshots *bool
     Name string
     Tags *map[string]string
     Ena_support *bool
     Kms_key_id *string
     Ramdisk_id *string
}


func Aws_ami_copyMapper(r *Aws_ami_copy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Manage_ebs_snapshots != nil {
    config["manage_ebs_snapshots"] = *r.Manage_ebs_snapshots
}
    config["name"] = r.Name
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Ena_support != nil {
    config["ena_support"] = *r.Ena_support
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Ramdisk_id != nil {
    config["ramdisk_id"] = *r.Ramdisk_id
}
if r.Image_location != nil {
    config["image_location"] = *r.Image_location
}
if r.Kernel_id != nil {
    config["kernel_id"] = *r.Kernel_id
}
if r.Root_device_name != nil {
    config["root_device_name"] = *r.Root_device_name
}
    config["source_ami_id"] = r.Source_ami_id
if r.Architecture != nil {
    config["architecture"] = *r.Architecture
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Encrypted != nil {
    config["encrypted"] = *r.Encrypted
}
    config["source_ami_region"] = r.Source_ami_region
if r.Root_snapshot_id != nil {
    config["root_snapshot_id"] = *r.Root_snapshot_id
}
if r.Sriov_net_support != nil {
    config["sriov_net_support"] = *r.Sriov_net_support
}
if r.Virtualization_type != nil {
    config["virtualization_type"] = *r.Virtualization_type
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ami_copyUnmapper(state map[string]interface{}) *Aws_ami_copy {
	r := &Aws_ami_copy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ami_copy_id = &x
}

if x, ok := state["ena_support"]; ok {
	x := x.(bool)
	r.Ena_support = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["ramdisk_id"]; ok {
	x := x.(string)
	r.Ramdisk_id = &x
}

if x, ok := state["image_location"]; ok {
	x := x.(string)
	r.Image_location = &x
}

if x, ok := state["kernel_id"]; ok {
	x := x.(string)
	r.Kernel_id = &x
}

if x, ok := state["root_device_name"]; ok {
	x := x.(string)
	r.Root_device_name = &x
}

if x, ok := state["source_ami_id"]; ok {
	r.Source_ami_id = x.(string)
}

if x, ok := state["architecture"]; ok {
	x := x.(string)
	r.Architecture = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["encrypted"]; ok {
	x := x.(bool)
	r.Encrypted = &x
}

if x, ok := state["source_ami_region"]; ok {
	r.Source_ami_region = x.(string)
}

if x, ok := state["root_snapshot_id"]; ok {
	x := x.(string)
	r.Root_snapshot_id = &x
}

if x, ok := state["sriov_net_support"]; ok {
	x := x.(string)
	r.Sriov_net_support = &x
}

if x, ok := state["virtualization_type"]; ok {
	x := x.(string)
	r.Virtualization_type = &x
}

if x, ok := state["manage_ebs_snapshots"]; ok {
	x := x.(bool)
	r.Manage_ebs_snapshots = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_ami_copyHandler ...
type Aws_ami_copyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ami_copyHandler) Create(desired *Aws_ami_copy) (*Aws_ami_copy, string, error) {
	rState := Aws_ami_copyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ami_copy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ami_copyHandler) Read(externalID string) (*Aws_ami_copy, error) {
	actual, err := bridge.Read(h.provider, "aws_ami_copy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ami_copyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ami_copyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ami_copy", externalID)
}

type Aws_docdb_cluster_parameter_group struct {
     Aws_docdb_cluster_parameter_group_id *string
     Name *string
     Name_prefix *string
     Family string
     Description *string
     Tags *map[string]string
     Arn *string
}


func Aws_docdb_cluster_parameter_groupMapper(r *Aws_docdb_cluster_parameter_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["family"] = r.Family
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_docdb_cluster_parameter_groupUnmapper(state map[string]interface{}) *Aws_docdb_cluster_parameter_group {
	r := &Aws_docdb_cluster_parameter_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_docdb_cluster_parameter_group_id = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["family"]; ok {
	r.Family = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}
	return r
}


// Aws_docdb_cluster_parameter_groupHandler ...
type Aws_docdb_cluster_parameter_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_docdb_cluster_parameter_groupHandler) Create(desired *Aws_docdb_cluster_parameter_group) (*Aws_docdb_cluster_parameter_group, string, error) {
	rState := Aws_docdb_cluster_parameter_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_docdb_cluster_parameter_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_docdb_cluster_parameter_groupHandler) Read(externalID string) (*Aws_docdb_cluster_parameter_group, error) {
	actual, err := bridge.Read(h.provider, "aws_docdb_cluster_parameter_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_docdb_cluster_parameter_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_docdb_cluster_parameter_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_docdb_cluster_parameter_group", externalID)
}

type Aws_datasync_agent struct {
     Aws_datasync_agent_id *string
     Arn *string
     Activation_key *string
     Ip_address *string
     Name *string
     Tags *map[string]string
}


func Aws_datasync_agentMapper(r *Aws_datasync_agent) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Activation_key != nil {
    config["activation_key"] = *r.Activation_key
}
if r.Ip_address != nil {
    config["ip_address"] = *r.Ip_address
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_datasync_agentUnmapper(state map[string]interface{}) *Aws_datasync_agent {
	r := &Aws_datasync_agent{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_datasync_agent_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["activation_key"]; ok {
	x := x.(string)
	r.Activation_key = &x
}

if x, ok := state["ip_address"]; ok {
	x := x.(string)
	r.Ip_address = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_datasync_agentHandler ...
type Aws_datasync_agentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_datasync_agentHandler) Create(desired *Aws_datasync_agent) (*Aws_datasync_agent, string, error) {
	rState := Aws_datasync_agentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_datasync_agent", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_datasync_agentHandler) Read(externalID string) (*Aws_datasync_agent, error) {
	actual, err := bridge.Read(h.provider, "aws_datasync_agent", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_datasync_agentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_datasync_agentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_datasync_agent", externalID)
}

type Aws_appmesh_virtual_node struct {
     Aws_appmesh_virtual_node_id *string
     Mesh_name string
     Arn *string
     Created_date *string
     Last_updated_date *string
     Name string
}


func Aws_appmesh_virtual_nodeMapper(r *Aws_appmesh_virtual_node) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
if r.Last_updated_date != nil {
    config["last_updated_date"] = *r.Last_updated_date
}
    config["name"] = r.Name
    config["mesh_name"] = r.Mesh_name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appmesh_virtual_nodeUnmapper(state map[string]interface{}) *Aws_appmesh_virtual_node {
	r := &Aws_appmesh_virtual_node{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appmesh_virtual_node_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["mesh_name"]; ok {
	r.Mesh_name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}

if x, ok := state["last_updated_date"]; ok {
	x := x.(string)
	r.Last_updated_date = &x
}
	return r
}


// Aws_appmesh_virtual_nodeHandler ...
type Aws_appmesh_virtual_nodeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appmesh_virtual_nodeHandler) Create(desired *Aws_appmesh_virtual_node) (*Aws_appmesh_virtual_node, string, error) {
	rState := Aws_appmesh_virtual_nodeMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appmesh_virtual_node", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appmesh_virtual_nodeHandler) Read(externalID string) (*Aws_appmesh_virtual_node, error) {
	actual, err := bridge.Read(h.provider, "aws_appmesh_virtual_node", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appmesh_virtual_nodeUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appmesh_virtual_nodeHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appmesh_virtual_node", externalID)
}

type Aws_cognito_user_group struct {
     Aws_cognito_user_group_id *string
     Name string
     Role_arn *string
     User_pool_id string
     Description *string
}


func Aws_cognito_user_groupMapper(r *Aws_cognito_user_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Role_arn != nil {
    config["role_arn"] = *r.Role_arn
}
    config["user_pool_id"] = r.User_pool_id
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cognito_user_groupUnmapper(state map[string]interface{}) *Aws_cognito_user_group {
	r := &Aws_cognito_user_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cognito_user_group_id = &x
}

if x, ok := state["role_arn"]; ok {
	x := x.(string)
	r.Role_arn = &x
}

if x, ok := state["user_pool_id"]; ok {
	r.User_pool_id = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_cognito_user_groupHandler ...
type Aws_cognito_user_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cognito_user_groupHandler) Create(desired *Aws_cognito_user_group) (*Aws_cognito_user_group, string, error) {
	rState := Aws_cognito_user_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cognito_user_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cognito_user_groupHandler) Read(externalID string) (*Aws_cognito_user_group, error) {
	actual, err := bridge.Read(h.provider, "aws_cognito_user_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cognito_user_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cognito_user_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cognito_user_group", externalID)
}

type Aws_default_route_table struct {
     Aws_default_route_table_id *string
     Default_route_table_id string
     Vpc_id *string
     Tags *map[string]string
     Owner_id *string
}


func Aws_default_route_tableMapper(r *Aws_default_route_table) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
    config["default_route_table_id"] = r.Default_route_table_id
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_default_route_tableUnmapper(state map[string]interface{}) *Aws_default_route_table {
	r := &Aws_default_route_table{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_default_route_table_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["default_route_table_id"]; ok {
	r.Default_route_table_id = x.(string)
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}
	return r
}


// Aws_default_route_tableHandler ...
type Aws_default_route_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_default_route_tableHandler) Create(desired *Aws_default_route_table) (*Aws_default_route_table, string, error) {
	rState := Aws_default_route_tableMapper(desired)
	id, err := bridge.Create(h.provider, "aws_default_route_table", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_default_route_tableHandler) Read(externalID string) (*Aws_default_route_table, error) {
	actual, err := bridge.Read(h.provider, "aws_default_route_table", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_default_route_tableUnmapper(actual), nil
}

// Delete ...
func (h *Aws_default_route_tableHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_default_route_table", externalID)
}

type Aws_ssm_parameter struct {
     Aws_ssm_parameter_id *string
     Description *string
     Resource_type string
     Key_id *string
     Overwrite *bool
     Tags *map[string]string
     Name string
     Arn *string
     Allowed_pattern *string
     Value string
}


func Aws_ssm_parameterMapper(r *Aws_ssm_parameter) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["resource_type"] = r.Resource_type
if r.Key_id != nil {
    config["key_id"] = *r.Key_id
}
if r.Overwrite != nil {
    config["overwrite"] = *r.Overwrite
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Allowed_pattern != nil {
    config["allowed_pattern"] = *r.Allowed_pattern
}
    config["value"] = r.Value
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_parameterUnmapper(state map[string]interface{}) *Aws_ssm_parameter {
	r := &Aws_ssm_parameter{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_parameter_id = &x
}

if x, ok := state["value"]; ok {
	r.Value = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["allowed_pattern"]; ok {
	x := x.(string)
	r.Allowed_pattern = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["key_id"]; ok {
	x := x.(string)
	r.Key_id = &x
}

if x, ok := state["overwrite"]; ok {
	x := x.(bool)
	r.Overwrite = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_ssm_parameterHandler ...
type Aws_ssm_parameterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_parameterHandler) Create(desired *Aws_ssm_parameter) (*Aws_ssm_parameter, string, error) {
	rState := Aws_ssm_parameterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_parameter", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_parameterHandler) Read(externalID string) (*Aws_ssm_parameter, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_parameter", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_parameterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_parameterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_parameter", externalID)
}

type Aws_ami struct {
     Aws_ami_id *string
     Ena_support *bool
     Sriov_net_support *string
     Tags *map[string]string
     Architecture *string
     Name string
     Ramdisk_id *string
     Virtualization_type *string
     Kernel_id *string
     Image_location *string
     Manage_ebs_snapshots *bool
     Root_device_name *string
     Root_snapshot_id *string
     Description *string
}


func Aws_amiMapper(r *Aws_ami) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Ena_support != nil {
    config["ena_support"] = *r.Ena_support
}
if r.Sriov_net_support != nil {
    config["sriov_net_support"] = *r.Sriov_net_support
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Architecture != nil {
    config["architecture"] = *r.Architecture
}
    config["name"] = r.Name
if r.Ramdisk_id != nil {
    config["ramdisk_id"] = *r.Ramdisk_id
}
if r.Virtualization_type != nil {
    config["virtualization_type"] = *r.Virtualization_type
}
if r.Kernel_id != nil {
    config["kernel_id"] = *r.Kernel_id
}
if r.Image_location != nil {
    config["image_location"] = *r.Image_location
}
if r.Manage_ebs_snapshots != nil {
    config["manage_ebs_snapshots"] = *r.Manage_ebs_snapshots
}
if r.Root_device_name != nil {
    config["root_device_name"] = *r.Root_device_name
}
if r.Root_snapshot_id != nil {
    config["root_snapshot_id"] = *r.Root_snapshot_id
}
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_amiUnmapper(state map[string]interface{}) *Aws_ami {
	r := &Aws_ami{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ami_id = &x
}

if x, ok := state["kernel_id"]; ok {
	x := x.(string)
	r.Kernel_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["ramdisk_id"]; ok {
	x := x.(string)
	r.Ramdisk_id = &x
}

if x, ok := state["virtualization_type"]; ok {
	x := x.(string)
	r.Virtualization_type = &x
}

if x, ok := state["image_location"]; ok {
	x := x.(string)
	r.Image_location = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["manage_ebs_snapshots"]; ok {
	x := x.(bool)
	r.Manage_ebs_snapshots = &x
}

if x, ok := state["root_device_name"]; ok {
	x := x.(string)
	r.Root_device_name = &x
}

if x, ok := state["root_snapshot_id"]; ok {
	x := x.(string)
	r.Root_snapshot_id = &x
}

if x, ok := state["architecture"]; ok {
	x := x.(string)
	r.Architecture = &x
}

if x, ok := state["ena_support"]; ok {
	x := x.(bool)
	r.Ena_support = &x
}

if x, ok := state["sriov_net_support"]; ok {
	x := x.(string)
	r.Sriov_net_support = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_amiHandler ...
type Aws_amiHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_amiHandler) Create(desired *Aws_ami) (*Aws_ami, string, error) {
	rState := Aws_amiMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ami", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_amiHandler) Read(externalID string) (*Aws_ami, error) {
	actual, err := bridge.Read(h.provider, "aws_ami", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_amiUnmapper(actual), nil
}

// Delete ...
func (h *Aws_amiHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ami", externalID)
}

type Aws_elastic_beanstalk_environment struct {
     Aws_elastic_beanstalk_environment_id *string
     Arn *string
     Application string
     Platform_arn *string
     Description *string
     Version_label *string
     Solution_stack_name *string
     Tags *map[string]string
     Template_name *string
     Wait_for_ready_timeout *string
     Poll_interval *string
     Name string
     Cname *string
     Cname_prefix *string
     Tier *string
}


func Aws_elastic_beanstalk_environmentMapper(r *Aws_elastic_beanstalk_environment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Template_name != nil {
    config["template_name"] = *r.Template_name
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["name"] = r.Name
if r.Cname != nil {
    config["cname"] = *r.Cname
}
if r.Cname_prefix != nil {
    config["cname_prefix"] = *r.Cname_prefix
}
if r.Tier != nil {
    config["tier"] = *r.Tier
}
if r.Wait_for_ready_timeout != nil {
    config["wait_for_ready_timeout"] = *r.Wait_for_ready_timeout
}
if r.Poll_interval != nil {
    config["poll_interval"] = *r.Poll_interval
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["application"] = r.Application
if r.Platform_arn != nil {
    config["platform_arn"] = *r.Platform_arn
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Version_label != nil {
    config["version_label"] = *r.Version_label
}
if r.Solution_stack_name != nil {
    config["solution_stack_name"] = *r.Solution_stack_name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elastic_beanstalk_environmentUnmapper(state map[string]interface{}) *Aws_elastic_beanstalk_environment {
	r := &Aws_elastic_beanstalk_environment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elastic_beanstalk_environment_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["version_label"]; ok {
	x := x.(string)
	r.Version_label = &x
}

if x, ok := state["solution_stack_name"]; ok {
	x := x.(string)
	r.Solution_stack_name = &x
}

if x, ok := state["template_name"]; ok {
	x := x.(string)
	r.Template_name = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["cname"]; ok {
	x := x.(string)
	r.Cname = &x
}

if x, ok := state["cname_prefix"]; ok {
	x := x.(string)
	r.Cname_prefix = &x
}

if x, ok := state["tier"]; ok {
	x := x.(string)
	r.Tier = &x
}

if x, ok := state["wait_for_ready_timeout"]; ok {
	x := x.(string)
	r.Wait_for_ready_timeout = &x
}

if x, ok := state["poll_interval"]; ok {
	x := x.(string)
	r.Poll_interval = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["application"]; ok {
	r.Application = x.(string)
}

if x, ok := state["platform_arn"]; ok {
	x := x.(string)
	r.Platform_arn = &x
}
	return r
}


// Aws_elastic_beanstalk_environmentHandler ...
type Aws_elastic_beanstalk_environmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elastic_beanstalk_environmentHandler) Create(desired *Aws_elastic_beanstalk_environment) (*Aws_elastic_beanstalk_environment, string, error) {
	rState := Aws_elastic_beanstalk_environmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elastic_beanstalk_environment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elastic_beanstalk_environmentHandler) Read(externalID string) (*Aws_elastic_beanstalk_environment, error) {
	actual, err := bridge.Read(h.provider, "aws_elastic_beanstalk_environment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elastic_beanstalk_environmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elastic_beanstalk_environmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elastic_beanstalk_environment", externalID)
}

type Aws_iam_account_password_policy struct {
     Aws_iam_account_password_policy_id *string
     Expire_passwords *bool
     Hard_expiry *bool
     Require_numbers *bool
     Require_symbols *bool
     Allow_users_to_change_password *bool
     Require_lowercase_characters *bool
     Require_uppercase_characters *bool
}


func Aws_iam_account_password_policyMapper(r *Aws_iam_account_password_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Expire_passwords != nil {
    config["expire_passwords"] = *r.Expire_passwords
}
if r.Hard_expiry != nil {
    config["hard_expiry"] = *r.Hard_expiry
}
if r.Require_numbers != nil {
    config["require_numbers"] = *r.Require_numbers
}
if r.Require_symbols != nil {
    config["require_symbols"] = *r.Require_symbols
}
if r.Allow_users_to_change_password != nil {
    config["allow_users_to_change_password"] = *r.Allow_users_to_change_password
}
if r.Require_lowercase_characters != nil {
    config["require_lowercase_characters"] = *r.Require_lowercase_characters
}
if r.Require_uppercase_characters != nil {
    config["require_uppercase_characters"] = *r.Require_uppercase_characters
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_account_password_policyUnmapper(state map[string]interface{}) *Aws_iam_account_password_policy {
	r := &Aws_iam_account_password_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_account_password_policy_id = &x
}

if x, ok := state["allow_users_to_change_password"]; ok {
	x := x.(bool)
	r.Allow_users_to_change_password = &x
}

if x, ok := state["require_lowercase_characters"]; ok {
	x := x.(bool)
	r.Require_lowercase_characters = &x
}

if x, ok := state["require_uppercase_characters"]; ok {
	x := x.(bool)
	r.Require_uppercase_characters = &x
}

if x, ok := state["expire_passwords"]; ok {
	x := x.(bool)
	r.Expire_passwords = &x
}

if x, ok := state["hard_expiry"]; ok {
	x := x.(bool)
	r.Hard_expiry = &x
}

if x, ok := state["require_numbers"]; ok {
	x := x.(bool)
	r.Require_numbers = &x
}

if x, ok := state["require_symbols"]; ok {
	x := x.(bool)
	r.Require_symbols = &x
}
	return r
}


// Aws_iam_account_password_policyHandler ...
type Aws_iam_account_password_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_account_password_policyHandler) Create(desired *Aws_iam_account_password_policy) (*Aws_iam_account_password_policy, string, error) {
	rState := Aws_iam_account_password_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_account_password_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_account_password_policyHandler) Read(externalID string) (*Aws_iam_account_password_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_account_password_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_account_password_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_account_password_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_account_password_policy", externalID)
}

type Aws_inspector_resource_group struct {
     Aws_inspector_resource_group_id *string
     Tags map[string]string
     Arn *string
}


func Aws_inspector_resource_groupMapper(r *Aws_inspector_resource_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["tags"] = unconvertMap(r.Tags)
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_inspector_resource_groupUnmapper(state map[string]interface{}) *Aws_inspector_resource_group {
	r := &Aws_inspector_resource_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_inspector_resource_group_id = &x
}

if x, ok := state["tags"]; ok {
	r.Tags = x.(map[string]string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_inspector_resource_groupHandler ...
type Aws_inspector_resource_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_inspector_resource_groupHandler) Create(desired *Aws_inspector_resource_group) (*Aws_inspector_resource_group, string, error) {
	rState := Aws_inspector_resource_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_inspector_resource_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_inspector_resource_groupHandler) Read(externalID string) (*Aws_inspector_resource_group, error) {
	actual, err := bridge.Read(h.provider, "aws_inspector_resource_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_inspector_resource_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_inspector_resource_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_inspector_resource_group", externalID)
}

type Aws_service_discovery_service struct {
     Aws_service_discovery_service_id *string
     Name string
     Description *string
     Arn *string
}


func Aws_service_discovery_serviceMapper(r *Aws_service_discovery_service) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_service_discovery_serviceUnmapper(state map[string]interface{}) *Aws_service_discovery_service {
	r := &Aws_service_discovery_service{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_service_discovery_service_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_service_discovery_serviceHandler ...
type Aws_service_discovery_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_service_discovery_serviceHandler) Create(desired *Aws_service_discovery_service) (*Aws_service_discovery_service, string, error) {
	rState := Aws_service_discovery_serviceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_service_discovery_service", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_service_discovery_serviceHandler) Read(externalID string) (*Aws_service_discovery_service, error) {
	actual, err := bridge.Read(h.provider, "aws_service_discovery_service", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_service_discovery_serviceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_service_discovery_serviceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_service_discovery_service", externalID)
}

type Aws_api_gateway_gateway_response struct {
     Aws_api_gateway_gateway_response_id *string
     Rest_api_id string
     Response_type string
     Status_code *string
     Response_templates *map[string]string
     Response_parameters *map[string]string
}


func Aws_api_gateway_gateway_responseMapper(r *Aws_api_gateway_gateway_response) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["rest_api_id"] = r.Rest_api_id
    config["response_type"] = r.Response_type
if r.Status_code != nil {
    config["status_code"] = *r.Status_code
}
if r.Response_templates != nil {
    config["response_templates"] = *r.Response_templates
}
if r.Response_parameters != nil {
    config["response_parameters"] = *r.Response_parameters
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_gateway_responseUnmapper(state map[string]interface{}) *Aws_api_gateway_gateway_response {
	r := &Aws_api_gateway_gateway_response{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_gateway_response_id = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["response_type"]; ok {
	r.Response_type = x.(string)
}

if x, ok := state["status_code"]; ok {
	x := x.(string)
	r.Status_code = &x
}

if x, ok := state["response_templates"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Response_templates = &x
}

if x, ok := state["response_parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Response_parameters = &x
}
	return r
}


// Aws_api_gateway_gateway_responseHandler ...
type Aws_api_gateway_gateway_responseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_gateway_responseHandler) Create(desired *Aws_api_gateway_gateway_response) (*Aws_api_gateway_gateway_response, string, error) {
	rState := Aws_api_gateway_gateway_responseMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_gateway_response", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_gateway_responseHandler) Read(externalID string) (*Aws_api_gateway_gateway_response, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_gateway_response", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_gateway_responseUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_gateway_responseHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_gateway_response", externalID)
}

type Aws_db_snapshot struct {
     Aws_db_snapshot_id *string
     Encrypted *bool
     Engine_version *string
     Status *string
     Storage_type *string
     Db_snapshot_identifier string
     Db_instance_identifier string
     Kms_key_id *string
     Vpc_id *string
     Option_group_name *string
     Source_db_snapshot_identifier *string
     Tags *map[string]string
     Engine *string
     License_model *string
     Source_region *string
     Snapshot_type *string
     Availability_zone *string
     Db_snapshot_arn *string
}


func Aws_db_snapshotMapper(r *Aws_db_snapshot) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Status != nil {
    config["status"] = *r.Status
}
if r.Storage_type != nil {
    config["storage_type"] = *r.Storage_type
}
    config["db_snapshot_identifier"] = r.Db_snapshot_identifier
    config["db_instance_identifier"] = r.Db_instance_identifier
if r.Encrypted != nil {
    config["encrypted"] = *r.Encrypted
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Option_group_name != nil {
    config["option_group_name"] = *r.Option_group_name
}
if r.Source_db_snapshot_identifier != nil {
    config["source_db_snapshot_identifier"] = *r.Source_db_snapshot_identifier
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Snapshot_type != nil {
    config["snapshot_type"] = *r.Snapshot_type
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Db_snapshot_arn != nil {
    config["db_snapshot_arn"] = *r.Db_snapshot_arn
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.License_model != nil {
    config["license_model"] = *r.License_model
}
if r.Source_region != nil {
    config["source_region"] = *r.Source_region
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_db_snapshotUnmapper(state map[string]interface{}) *Aws_db_snapshot {
	r := &Aws_db_snapshot{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_db_snapshot_id = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["option_group_name"]; ok {
	x := x.(string)
	r.Option_group_name = &x
}

if x, ok := state["source_db_snapshot_identifier"]; ok {
	x := x.(string)
	r.Source_db_snapshot_identifier = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["db_snapshot_arn"]; ok {
	x := x.(string)
	r.Db_snapshot_arn = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["license_model"]; ok {
	x := x.(string)
	r.License_model = &x
}

if x, ok := state["source_region"]; ok {
	x := x.(string)
	r.Source_region = &x
}

if x, ok := state["snapshot_type"]; ok {
	x := x.(string)
	r.Snapshot_type = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["db_instance_identifier"]; ok {
	r.Db_instance_identifier = x.(string)
}

if x, ok := state["encrypted"]; ok {
	x := x.(bool)
	r.Encrypted = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["storage_type"]; ok {
	x := x.(string)
	r.Storage_type = &x
}

if x, ok := state["db_snapshot_identifier"]; ok {
	r.Db_snapshot_identifier = x.(string)
}
	return r
}


// Aws_db_snapshotHandler ...
type Aws_db_snapshotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_db_snapshotHandler) Create(desired *Aws_db_snapshot) (*Aws_db_snapshot, string, error) {
	rState := Aws_db_snapshotMapper(desired)
	id, err := bridge.Create(h.provider, "aws_db_snapshot", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_db_snapshotHandler) Read(externalID string) (*Aws_db_snapshot, error) {
	actual, err := bridge.Read(h.provider, "aws_db_snapshot", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_db_snapshotUnmapper(actual), nil
}

// Delete ...
func (h *Aws_db_snapshotHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_db_snapshot", externalID)
}

type Aws_transfer_server struct {
     Aws_transfer_server_id *string
     Tags *map[string]string
     Arn *string
     Endpoint *string
     Invocation_role *string
     Url *string
     Identity_provider_type *string
     Logging_role *string
     Force_destroy *bool
}


func Aws_transfer_serverMapper(r *Aws_transfer_server) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
if r.Invocation_role != nil {
    config["invocation_role"] = *r.Invocation_role
}
if r.Url != nil {
    config["url"] = *r.Url
}
if r.Identity_provider_type != nil {
    config["identity_provider_type"] = *r.Identity_provider_type
}
if r.Logging_role != nil {
    config["logging_role"] = *r.Logging_role
}
if r.Force_destroy != nil {
    config["force_destroy"] = *r.Force_destroy
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_transfer_serverUnmapper(state map[string]interface{}) *Aws_transfer_server {
	r := &Aws_transfer_server{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_transfer_server_id = &x
}

if x, ok := state["url"]; ok {
	x := x.(string)
	r.Url = &x
}

if x, ok := state["identity_provider_type"]; ok {
	x := x.(string)
	r.Identity_provider_type = &x
}

if x, ok := state["logging_role"]; ok {
	x := x.(string)
	r.Logging_role = &x
}

if x, ok := state["force_destroy"]; ok {
	x := x.(bool)
	r.Force_destroy = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["invocation_role"]; ok {
	x := x.(string)
	r.Invocation_role = &x
}
	return r
}


// Aws_transfer_serverHandler ...
type Aws_transfer_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_transfer_serverHandler) Create(desired *Aws_transfer_server) (*Aws_transfer_server, string, error) {
	rState := Aws_transfer_serverMapper(desired)
	id, err := bridge.Create(h.provider, "aws_transfer_server", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_transfer_serverHandler) Read(externalID string) (*Aws_transfer_server, error) {
	actual, err := bridge.Read(h.provider, "aws_transfer_server", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_transfer_serverUnmapper(actual), nil
}

// Delete ...
func (h *Aws_transfer_serverHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_transfer_server", externalID)
}

type Aws_wafregional_rule_group struct {
     Aws_wafregional_rule_group_id *string
     Name string
     Metric_name string
}


func Aws_wafregional_rule_groupMapper(r *Aws_wafregional_rule_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["metric_name"] = r.Metric_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_rule_groupUnmapper(state map[string]interface{}) *Aws_wafregional_rule_group {
	r := &Aws_wafregional_rule_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_rule_group_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["metric_name"]; ok {
	r.Metric_name = x.(string)
}
	return r
}


// Aws_wafregional_rule_groupHandler ...
type Aws_wafregional_rule_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_rule_groupHandler) Create(desired *Aws_wafregional_rule_group) (*Aws_wafregional_rule_group, string, error) {
	rState := Aws_wafregional_rule_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_rule_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_rule_groupHandler) Read(externalID string) (*Aws_wafregional_rule_group, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_rule_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_rule_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_rule_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_rule_group", externalID)
}

type Aws_db_cluster_snapshot struct {
     Aws_db_cluster_snapshot_id *string
     Db_cluster_snapshot_arn *string
     Kms_key_id *string
     License_model *string
     Db_cluster_snapshot_identifier string
     Storage_encrypted *bool
     Engine *string
     Engine_version *string
     Status *string
     Db_cluster_identifier string
     Source_db_cluster_snapshot_arn *string
     Snapshot_type *string
     Vpc_id *string
}


func Aws_db_cluster_snapshotMapper(r *Aws_db_cluster_snapshot) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["db_cluster_snapshot_identifier"] = r.Db_cluster_snapshot_identifier
if r.Storage_encrypted != nil {
    config["storage_encrypted"] = *r.Storage_encrypted
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Status != nil {
    config["status"] = *r.Status
}
    config["db_cluster_identifier"] = r.Db_cluster_identifier
if r.Source_db_cluster_snapshot_arn != nil {
    config["source_db_cluster_snapshot_arn"] = *r.Source_db_cluster_snapshot_arn
}
if r.Snapshot_type != nil {
    config["snapshot_type"] = *r.Snapshot_type
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Db_cluster_snapshot_arn != nil {
    config["db_cluster_snapshot_arn"] = *r.Db_cluster_snapshot_arn
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.License_model != nil {
    config["license_model"] = *r.License_model
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_db_cluster_snapshotUnmapper(state map[string]interface{}) *Aws_db_cluster_snapshot {
	r := &Aws_db_cluster_snapshot{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_db_cluster_snapshot_id = &x
}

if x, ok := state["db_cluster_identifier"]; ok {
	r.Db_cluster_identifier = x.(string)
}

if x, ok := state["source_db_cluster_snapshot_arn"]; ok {
	x := x.(string)
	r.Source_db_cluster_snapshot_arn = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["snapshot_type"]; ok {
	x := x.(string)
	r.Snapshot_type = &x
}

if x, ok := state["db_cluster_snapshot_arn"]; ok {
	x := x.(string)
	r.Db_cluster_snapshot_arn = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["license_model"]; ok {
	x := x.(string)
	r.License_model = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["db_cluster_snapshot_identifier"]; ok {
	r.Db_cluster_snapshot_identifier = x.(string)
}

if x, ok := state["storage_encrypted"]; ok {
	x := x.(bool)
	r.Storage_encrypted = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}
	return r
}


// Aws_db_cluster_snapshotHandler ...
type Aws_db_cluster_snapshotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_db_cluster_snapshotHandler) Create(desired *Aws_db_cluster_snapshot) (*Aws_db_cluster_snapshot, string, error) {
	rState := Aws_db_cluster_snapshotMapper(desired)
	id, err := bridge.Create(h.provider, "aws_db_cluster_snapshot", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_db_cluster_snapshotHandler) Read(externalID string) (*Aws_db_cluster_snapshot, error) {
	actual, err := bridge.Read(h.provider, "aws_db_cluster_snapshot", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_db_cluster_snapshotUnmapper(actual), nil
}

// Delete ...
func (h *Aws_db_cluster_snapshotHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_db_cluster_snapshot", externalID)
}

type Aws_ec2_fleet struct {
     Aws_ec2_fleet_id *string
     Replace_unhealthy_instances *bool
     Terminate_instances *bool
     Tags *map[string]string
     Terminate_instances_with_expiration *bool
     Resource_type *string
     Excess_capacity_termination_policy *string
}


func Aws_ec2_fleetMapper(r *Aws_ec2_fleet) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Excess_capacity_termination_policy != nil {
    config["excess_capacity_termination_policy"] = *r.Excess_capacity_termination_policy
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Terminate_instances_with_expiration != nil {
    config["terminate_instances_with_expiration"] = *r.Terminate_instances_with_expiration
}
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
if r.Replace_unhealthy_instances != nil {
    config["replace_unhealthy_instances"] = *r.Replace_unhealthy_instances
}
if r.Terminate_instances != nil {
    config["terminate_instances"] = *r.Terminate_instances
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ec2_fleetUnmapper(state map[string]interface{}) *Aws_ec2_fleet {
	r := &Aws_ec2_fleet{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ec2_fleet_id = &x
}

if x, ok := state["replace_unhealthy_instances"]; ok {
	x := x.(bool)
	r.Replace_unhealthy_instances = &x
}

if x, ok := state["terminate_instances"]; ok {
	x := x.(bool)
	r.Terminate_instances = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["terminate_instances_with_expiration"]; ok {
	x := x.(bool)
	r.Terminate_instances_with_expiration = &x
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}

if x, ok := state["excess_capacity_termination_policy"]; ok {
	x := x.(string)
	r.Excess_capacity_termination_policy = &x
}
	return r
}


// Aws_ec2_fleetHandler ...
type Aws_ec2_fleetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ec2_fleetHandler) Create(desired *Aws_ec2_fleet) (*Aws_ec2_fleet, string, error) {
	rState := Aws_ec2_fleetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ec2_fleet", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ec2_fleetHandler) Read(externalID string) (*Aws_ec2_fleet, error) {
	actual, err := bridge.Read(h.provider, "aws_ec2_fleet", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ec2_fleetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ec2_fleetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ec2_fleet", externalID)
}

type Aws_redshift_event_subscription struct {
     Aws_redshift_event_subscription_id *string
     Enabled *bool
     Severity *string
     Customer_aws_id *string
     Sns_topic_arn string
     Status *string
     Source_type *string
     Tags *map[string]string
     Name string
}


func Aws_redshift_event_subscriptionMapper(r *Aws_redshift_event_subscription) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["sns_topic_arn"] = r.Sns_topic_arn
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Source_type != nil {
    config["source_type"] = *r.Source_type
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.Severity != nil {
    config["severity"] = *r.Severity
}
if r.Customer_aws_id != nil {
    config["customer_aws_id"] = *r.Customer_aws_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_redshift_event_subscriptionUnmapper(state map[string]interface{}) *Aws_redshift_event_subscription {
	r := &Aws_redshift_event_subscription{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_redshift_event_subscription_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["sns_topic_arn"]; ok {
	r.Sns_topic_arn = x.(string)
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["source_type"]; ok {
	x := x.(string)
	r.Source_type = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["severity"]; ok {
	x := x.(string)
	r.Severity = &x
}

if x, ok := state["customer_aws_id"]; ok {
	x := x.(string)
	r.Customer_aws_id = &x
}
	return r
}


// Aws_redshift_event_subscriptionHandler ...
type Aws_redshift_event_subscriptionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_redshift_event_subscriptionHandler) Create(desired *Aws_redshift_event_subscription) (*Aws_redshift_event_subscription, string, error) {
	rState := Aws_redshift_event_subscriptionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_redshift_event_subscription", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_redshift_event_subscriptionHandler) Read(externalID string) (*Aws_redshift_event_subscription, error) {
	actual, err := bridge.Read(h.provider, "aws_redshift_event_subscription", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_redshift_event_subscriptionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_redshift_event_subscriptionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_redshift_event_subscription", externalID)
}

type Aws_ses_event_destination struct {
     Aws_ses_event_destination_id *string
     Name string
     Configuration_set_name string
     Enabled *bool
}


func Aws_ses_event_destinationMapper(r *Aws_ses_event_destination) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["configuration_set_name"] = r.Configuration_set_name
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_event_destinationUnmapper(state map[string]interface{}) *Aws_ses_event_destination {
	r := &Aws_ses_event_destination{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_event_destination_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["configuration_set_name"]; ok {
	r.Configuration_set_name = x.(string)
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}
	return r
}


// Aws_ses_event_destinationHandler ...
type Aws_ses_event_destinationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_event_destinationHandler) Create(desired *Aws_ses_event_destination) (*Aws_ses_event_destination, string, error) {
	rState := Aws_ses_event_destinationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_event_destination", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_event_destinationHandler) Read(externalID string) (*Aws_ses_event_destination, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_event_destination", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_event_destinationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_event_destinationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_event_destination", externalID)
}

type Aws_codedeploy_app struct {
     Aws_codedeploy_app_id *string
     Name string
     Compute_platform *string
     Unique_id *string
}


func Aws_codedeploy_appMapper(r *Aws_codedeploy_app) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Compute_platform != nil {
    config["compute_platform"] = *r.Compute_platform
}
if r.Unique_id != nil {
    config["unique_id"] = *r.Unique_id
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_codedeploy_appUnmapper(state map[string]interface{}) *Aws_codedeploy_app {
	r := &Aws_codedeploy_app{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_codedeploy_app_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["compute_platform"]; ok {
	x := x.(string)
	r.Compute_platform = &x
}

if x, ok := state["unique_id"]; ok {
	x := x.(string)
	r.Unique_id = &x
}
	return r
}


// Aws_codedeploy_appHandler ...
type Aws_codedeploy_appHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_codedeploy_appHandler) Create(desired *Aws_codedeploy_app) (*Aws_codedeploy_app, string, error) {
	rState := Aws_codedeploy_appMapper(desired)
	id, err := bridge.Create(h.provider, "aws_codedeploy_app", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_codedeploy_appHandler) Read(externalID string) (*Aws_codedeploy_app, error) {
	actual, err := bridge.Read(h.provider, "aws_codedeploy_app", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_codedeploy_appUnmapper(actual), nil
}

// Delete ...
func (h *Aws_codedeploy_appHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_codedeploy_app", externalID)
}

type Aws_glue_trigger struct {
     Aws_glue_trigger_id *string
     Resource_type string
     Description *string
     Enabled *bool
     Name string
     Schedule *string
}


func Aws_glue_triggerMapper(r *Aws_glue_trigger) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
    config["name"] = r.Name
if r.Schedule != nil {
    config["schedule"] = *r.Schedule
}
    config["resource_type"] = r.Resource_type
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glue_triggerUnmapper(state map[string]interface{}) *Aws_glue_trigger {
	r := &Aws_glue_trigger{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glue_trigger_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["schedule"]; ok {
	x := x.(string)
	r.Schedule = &x
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}
	return r
}


// Aws_glue_triggerHandler ...
type Aws_glue_triggerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glue_triggerHandler) Create(desired *Aws_glue_trigger) (*Aws_glue_trigger, string, error) {
	rState := Aws_glue_triggerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glue_trigger", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glue_triggerHandler) Read(externalID string) (*Aws_glue_trigger, error) {
	actual, err := bridge.Read(h.provider, "aws_glue_trigger", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glue_triggerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glue_triggerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glue_trigger", externalID)
}

type Aws_config_config_rule struct {
     Aws_config_config_rule_id *string
     Name string
     Rule_id *string
     Arn *string
     Description *string
     Input_parameters *string
     Maximum_execution_frequency *string
}


func Aws_config_config_ruleMapper(r *Aws_config_config_rule) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Input_parameters != nil {
    config["input_parameters"] = *r.Input_parameters
}
if r.Maximum_execution_frequency != nil {
    config["maximum_execution_frequency"] = *r.Maximum_execution_frequency
}
    config["name"] = r.Name
if r.Rule_id != nil {
    config["rule_id"] = *r.Rule_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_config_config_ruleUnmapper(state map[string]interface{}) *Aws_config_config_rule {
	r := &Aws_config_config_rule{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_config_config_rule_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["rule_id"]; ok {
	x := x.(string)
	r.Rule_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["input_parameters"]; ok {
	x := x.(string)
	r.Input_parameters = &x
}

if x, ok := state["maximum_execution_frequency"]; ok {
	x := x.(string)
	r.Maximum_execution_frequency = &x
}
	return r
}


// Aws_config_config_ruleHandler ...
type Aws_config_config_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_config_config_ruleHandler) Create(desired *Aws_config_config_rule) (*Aws_config_config_rule, string, error) {
	rState := Aws_config_config_ruleMapper(desired)
	id, err := bridge.Create(h.provider, "aws_config_config_rule", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_config_config_ruleHandler) Read(externalID string) (*Aws_config_config_rule, error) {
	actual, err := bridge.Read(h.provider, "aws_config_config_rule", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_config_config_ruleUnmapper(actual), nil
}

// Delete ...
func (h *Aws_config_config_ruleHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_config_config_rule", externalID)
}

type Aws_iam_policy_attachment struct {
     Aws_iam_policy_attachment_id *string
     Policy_arn string
     Name string
}


func Aws_iam_policy_attachmentMapper(r *Aws_iam_policy_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["policy_arn"] = r.Policy_arn
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_policy_attachmentUnmapper(state map[string]interface{}) *Aws_iam_policy_attachment {
	r := &Aws_iam_policy_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_policy_attachment_id = &x
}

if x, ok := state["policy_arn"]; ok {
	r.Policy_arn = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_iam_policy_attachmentHandler ...
type Aws_iam_policy_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_policy_attachmentHandler) Create(desired *Aws_iam_policy_attachment) (*Aws_iam_policy_attachment, string, error) {
	rState := Aws_iam_policy_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_policy_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_policy_attachmentHandler) Read(externalID string) (*Aws_iam_policy_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_policy_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_policy_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_policy_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_policy_attachment", externalID)
}

type Aws_sns_topic_subscription struct {
     Aws_sns_topic_subscription_id *string
     Arn *string
     Protocol string
     Endpoint_auto_confirms *bool
     Delivery_policy *string
     Raw_message_delivery *bool
     Filter_policy *string
     Endpoint string
     Topic_arn string
}


func Aws_sns_topic_subscriptionMapper(r *Aws_sns_topic_subscription) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Endpoint_auto_confirms != nil {
    config["endpoint_auto_confirms"] = *r.Endpoint_auto_confirms
}
if r.Delivery_policy != nil {
    config["delivery_policy"] = *r.Delivery_policy
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["protocol"] = r.Protocol
    config["topic_arn"] = r.Topic_arn
if r.Raw_message_delivery != nil {
    config["raw_message_delivery"] = *r.Raw_message_delivery
}
if r.Filter_policy != nil {
    config["filter_policy"] = *r.Filter_policy
}
    config["endpoint"] = r.Endpoint
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sns_topic_subscriptionUnmapper(state map[string]interface{}) *Aws_sns_topic_subscription {
	r := &Aws_sns_topic_subscription{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sns_topic_subscription_id = &x
}

if x, ok := state["filter_policy"]; ok {
	x := x.(string)
	r.Filter_policy = &x
}

if x, ok := state["endpoint"]; ok {
	r.Endpoint = x.(string)
}

if x, ok := state["topic_arn"]; ok {
	r.Topic_arn = x.(string)
}

if x, ok := state["raw_message_delivery"]; ok {
	x := x.(bool)
	r.Raw_message_delivery = &x
}

if x, ok := state["protocol"]; ok {
	r.Protocol = x.(string)
}

if x, ok := state["endpoint_auto_confirms"]; ok {
	x := x.(bool)
	r.Endpoint_auto_confirms = &x
}

if x, ok := state["delivery_policy"]; ok {
	x := x.(string)
	r.Delivery_policy = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_sns_topic_subscriptionHandler ...
type Aws_sns_topic_subscriptionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sns_topic_subscriptionHandler) Create(desired *Aws_sns_topic_subscription) (*Aws_sns_topic_subscription, string, error) {
	rState := Aws_sns_topic_subscriptionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sns_topic_subscription", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sns_topic_subscriptionHandler) Read(externalID string) (*Aws_sns_topic_subscription, error) {
	actual, err := bridge.Read(h.provider, "aws_sns_topic_subscription", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sns_topic_subscriptionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sns_topic_subscriptionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sns_topic_subscription", externalID)
}

type Aws_glue_catalog_database struct {
     Aws_glue_catalog_database_id *string
     Catalog_id *string
     Name string
     Description *string
     Location_uri *string
     Parameters *map[string]string
}


func Aws_glue_catalog_databaseMapper(r *Aws_glue_catalog_database) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Location_uri != nil {
    config["location_uri"] = *r.Location_uri
}
if r.Parameters != nil {
    config["parameters"] = *r.Parameters
}
if r.Catalog_id != nil {
    config["catalog_id"] = *r.Catalog_id
}
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glue_catalog_databaseUnmapper(state map[string]interface{}) *Aws_glue_catalog_database {
	r := &Aws_glue_catalog_database{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glue_catalog_database_id = &x
}

if x, ok := state["parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Parameters = &x
}

if x, ok := state["catalog_id"]; ok {
	x := x.(string)
	r.Catalog_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["location_uri"]; ok {
	x := x.(string)
	r.Location_uri = &x
}
	return r
}


// Aws_glue_catalog_databaseHandler ...
type Aws_glue_catalog_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glue_catalog_databaseHandler) Create(desired *Aws_glue_catalog_database) (*Aws_glue_catalog_database, string, error) {
	rState := Aws_glue_catalog_databaseMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glue_catalog_database", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glue_catalog_databaseHandler) Read(externalID string) (*Aws_glue_catalog_database, error) {
	actual, err := bridge.Read(h.provider, "aws_glue_catalog_database", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glue_catalog_databaseUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glue_catalog_databaseHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glue_catalog_database", externalID)
}

type Aws_neptune_subnet_group struct {
     Aws_neptune_subnet_group_id *string
     Name *string
     Name_prefix *string
     Description *string
     Tags *map[string]string
     Arn *string
}


func Aws_neptune_subnet_groupMapper(r *Aws_neptune_subnet_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_neptune_subnet_groupUnmapper(state map[string]interface{}) *Aws_neptune_subnet_group {
	r := &Aws_neptune_subnet_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_neptune_subnet_group_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_neptune_subnet_groupHandler ...
type Aws_neptune_subnet_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_neptune_subnet_groupHandler) Create(desired *Aws_neptune_subnet_group) (*Aws_neptune_subnet_group, string, error) {
	rState := Aws_neptune_subnet_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_neptune_subnet_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_neptune_subnet_groupHandler) Read(externalID string) (*Aws_neptune_subnet_group, error) {
	actual, err := bridge.Read(h.provider, "aws_neptune_subnet_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_neptune_subnet_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_neptune_subnet_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_neptune_subnet_group", externalID)
}

type Aws_route_table_association struct {
     Aws_route_table_association_id *string
     Subnet_id string
     Route_table_id string
}


func Aws_route_table_associationMapper(r *Aws_route_table_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["subnet_id"] = r.Subnet_id
    config["route_table_id"] = r.Route_table_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_route_table_associationUnmapper(state map[string]interface{}) *Aws_route_table_association {
	r := &Aws_route_table_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_route_table_association_id = &x
}

if x, ok := state["subnet_id"]; ok {
	r.Subnet_id = x.(string)
}

if x, ok := state["route_table_id"]; ok {
	r.Route_table_id = x.(string)
}
	return r
}


// Aws_route_table_associationHandler ...
type Aws_route_table_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_route_table_associationHandler) Create(desired *Aws_route_table_association) (*Aws_route_table_association, string, error) {
	rState := Aws_route_table_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_route_table_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_route_table_associationHandler) Read(externalID string) (*Aws_route_table_association, error) {
	actual, err := bridge.Read(h.provider, "aws_route_table_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_route_table_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_route_table_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_route_table_association", externalID)
}

type Aws_s3_bucket struct {
     Aws_s3_bucket_id *string
     Bucket_domain_name *string
     Hosted_zone_id *string
     Request_payer *string
     Force_destroy *bool
     Bucket_prefix *string
     Bucket_regional_domain_name *string
     Arn *string
     Acl *string
     Website_domain *string
     Tags *map[string]string
     Region *string
     Bucket *string
     Policy *string
     Website_endpoint *string
     Acceleration_status *string
}


func Aws_s3_bucketMapper(r *Aws_s3_bucket) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Acceleration_status != nil {
    config["acceleration_status"] = *r.Acceleration_status
}
if r.Bucket != nil {
    config["bucket"] = *r.Bucket
}
if r.Policy != nil {
    config["policy"] = *r.Policy
}
if r.Website_endpoint != nil {
    config["website_endpoint"] = *r.Website_endpoint
}
if r.Bucket_domain_name != nil {
    config["bucket_domain_name"] = *r.Bucket_domain_name
}
if r.Hosted_zone_id != nil {
    config["hosted_zone_id"] = *r.Hosted_zone_id
}
if r.Request_payer != nil {
    config["request_payer"] = *r.Request_payer
}
if r.Website_domain != nil {
    config["website_domain"] = *r.Website_domain
}
if r.Force_destroy != nil {
    config["force_destroy"] = *r.Force_destroy
}
if r.Bucket_prefix != nil {
    config["bucket_prefix"] = *r.Bucket_prefix
}
if r.Bucket_regional_domain_name != nil {
    config["bucket_regional_domain_name"] = *r.Bucket_regional_domain_name
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Acl != nil {
    config["acl"] = *r.Acl
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Region != nil {
    config["region"] = *r.Region
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_s3_bucketUnmapper(state map[string]interface{}) *Aws_s3_bucket {
	r := &Aws_s3_bucket{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_s3_bucket_id = &x
}

if x, ok := state["bucket"]; ok {
	x := x.(string)
	r.Bucket = &x
}

if x, ok := state["policy"]; ok {
	x := x.(string)
	r.Policy = &x
}

if x, ok := state["website_endpoint"]; ok {
	x := x.(string)
	r.Website_endpoint = &x
}

if x, ok := state["acceleration_status"]; ok {
	x := x.(string)
	r.Acceleration_status = &x
}

if x, ok := state["bucket_domain_name"]; ok {
	x := x.(string)
	r.Bucket_domain_name = &x
}

if x, ok := state["hosted_zone_id"]; ok {
	x := x.(string)
	r.Hosted_zone_id = &x
}

if x, ok := state["request_payer"]; ok {
	x := x.(string)
	r.Request_payer = &x
}

if x, ok := state["force_destroy"]; ok {
	x := x.(bool)
	r.Force_destroy = &x
}

if x, ok := state["bucket_prefix"]; ok {
	x := x.(string)
	r.Bucket_prefix = &x
}

if x, ok := state["bucket_regional_domain_name"]; ok {
	x := x.(string)
	r.Bucket_regional_domain_name = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["acl"]; ok {
	x := x.(string)
	r.Acl = &x
}

if x, ok := state["website_domain"]; ok {
	x := x.(string)
	r.Website_domain = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["region"]; ok {
	x := x.(string)
	r.Region = &x
}
	return r
}


// Aws_s3_bucketHandler ...
type Aws_s3_bucketHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_s3_bucketHandler) Create(desired *Aws_s3_bucket) (*Aws_s3_bucket, string, error) {
	rState := Aws_s3_bucketMapper(desired)
	id, err := bridge.Create(h.provider, "aws_s3_bucket", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_s3_bucketHandler) Read(externalID string) (*Aws_s3_bucket, error) {
	actual, err := bridge.Read(h.provider, "aws_s3_bucket", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_s3_bucketUnmapper(actual), nil
}

// Delete ...
func (h *Aws_s3_bucketHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_s3_bucket", externalID)
}

type Aws_api_gateway_domain_name struct {
     Aws_api_gateway_domain_name_id *string
     Regional_certificate_arn *string
     Regional_domain_name *string
     Certificate_body *string
     Certificate_arn *string
     Regional_certificate_name *string
     Regional_zone_id *string
     Certificate_chain *string
     Certificate_name *string
     Certificate_private_key *string
     Domain_name string
     Cloudfront_domain_name *string
     Certificate_upload_date *string
     Cloudfront_zone_id *string
}


func Aws_api_gateway_domain_nameMapper(r *Aws_api_gateway_domain_name) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Cloudfront_domain_name != nil {
    config["cloudfront_domain_name"] = *r.Cloudfront_domain_name
}
if r.Regional_certificate_name != nil {
    config["regional_certificate_name"] = *r.Regional_certificate_name
}
if r.Regional_zone_id != nil {
    config["regional_zone_id"] = *r.Regional_zone_id
}
if r.Certificate_chain != nil {
    config["certificate_chain"] = *r.Certificate_chain
}
if r.Certificate_name != nil {
    config["certificate_name"] = *r.Certificate_name
}
if r.Certificate_private_key != nil {
    config["certificate_private_key"] = *r.Certificate_private_key
}
    config["domain_name"] = r.Domain_name
if r.Certificate_upload_date != nil {
    config["certificate_upload_date"] = *r.Certificate_upload_date
}
if r.Cloudfront_zone_id != nil {
    config["cloudfront_zone_id"] = *r.Cloudfront_zone_id
}
if r.Regional_certificate_arn != nil {
    config["regional_certificate_arn"] = *r.Regional_certificate_arn
}
if r.Regional_domain_name != nil {
    config["regional_domain_name"] = *r.Regional_domain_name
}
if r.Certificate_body != nil {
    config["certificate_body"] = *r.Certificate_body
}
if r.Certificate_arn != nil {
    config["certificate_arn"] = *r.Certificate_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_domain_nameUnmapper(state map[string]interface{}) *Aws_api_gateway_domain_name {
	r := &Aws_api_gateway_domain_name{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_domain_name_id = &x
}

if x, ok := state["certificate_body"]; ok {
	x := x.(string)
	r.Certificate_body = &x
}

if x, ok := state["certificate_arn"]; ok {
	x := x.(string)
	r.Certificate_arn = &x
}

if x, ok := state["regional_certificate_name"]; ok {
	x := x.(string)
	r.Regional_certificate_name = &x
}

if x, ok := state["regional_zone_id"]; ok {
	x := x.(string)
	r.Regional_zone_id = &x
}

if x, ok := state["certificate_chain"]; ok {
	x := x.(string)
	r.Certificate_chain = &x
}

if x, ok := state["certificate_name"]; ok {
	x := x.(string)
	r.Certificate_name = &x
}

if x, ok := state["certificate_private_key"]; ok {
	x := x.(string)
	r.Certificate_private_key = &x
}

if x, ok := state["domain_name"]; ok {
	r.Domain_name = x.(string)
}

if x, ok := state["cloudfront_domain_name"]; ok {
	x := x.(string)
	r.Cloudfront_domain_name = &x
}

if x, ok := state["certificate_upload_date"]; ok {
	x := x.(string)
	r.Certificate_upload_date = &x
}

if x, ok := state["cloudfront_zone_id"]; ok {
	x := x.(string)
	r.Cloudfront_zone_id = &x
}

if x, ok := state["regional_certificate_arn"]; ok {
	x := x.(string)
	r.Regional_certificate_arn = &x
}

if x, ok := state["regional_domain_name"]; ok {
	x := x.(string)
	r.Regional_domain_name = &x
}
	return r
}


// Aws_api_gateway_domain_nameHandler ...
type Aws_api_gateway_domain_nameHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_domain_nameHandler) Create(desired *Aws_api_gateway_domain_name) (*Aws_api_gateway_domain_name, string, error) {
	rState := Aws_api_gateway_domain_nameMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_domain_name", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_domain_nameHandler) Read(externalID string) (*Aws_api_gateway_domain_name, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_domain_name", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_domain_nameUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_domain_nameHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_domain_name", externalID)
}

type Aws_ec2_transit_gateway struct {
     Aws_ec2_transit_gateway_id *string
     Owner_id *string
     Arn *string
     Description *string
     Auto_accept_shared_attachments *string
     Default_route_table_association *string
     Default_route_table_propagation *string
     Dns_support *string
     Propagation_default_route_table_id *string
     Tags *map[string]string
     Association_default_route_table_id *string
     Vpn_ecmp_support *string
}


func Aws_ec2_transit_gatewayMapper(r *Aws_ec2_transit_gateway) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Default_route_table_association != nil {
    config["default_route_table_association"] = *r.Default_route_table_association
}
if r.Default_route_table_propagation != nil {
    config["default_route_table_propagation"] = *r.Default_route_table_propagation
}
if r.Dns_support != nil {
    config["dns_support"] = *r.Dns_support
}
if r.Propagation_default_route_table_id != nil {
    config["propagation_default_route_table_id"] = *r.Propagation_default_route_table_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Association_default_route_table_id != nil {
    config["association_default_route_table_id"] = *r.Association_default_route_table_id
}
if r.Auto_accept_shared_attachments != nil {
    config["auto_accept_shared_attachments"] = *r.Auto_accept_shared_attachments
}
if r.Vpn_ecmp_support != nil {
    config["vpn_ecmp_support"] = *r.Vpn_ecmp_support
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ec2_transit_gatewayUnmapper(state map[string]interface{}) *Aws_ec2_transit_gateway {
	r := &Aws_ec2_transit_gateway{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ec2_transit_gateway_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["association_default_route_table_id"]; ok {
	x := x.(string)
	r.Association_default_route_table_id = &x
}

if x, ok := state["auto_accept_shared_attachments"]; ok {
	x := x.(string)
	r.Auto_accept_shared_attachments = &x
}

if x, ok := state["default_route_table_association"]; ok {
	x := x.(string)
	r.Default_route_table_association = &x
}

if x, ok := state["default_route_table_propagation"]; ok {
	x := x.(string)
	r.Default_route_table_propagation = &x
}

if x, ok := state["dns_support"]; ok {
	x := x.(string)
	r.Dns_support = &x
}

if x, ok := state["propagation_default_route_table_id"]; ok {
	x := x.(string)
	r.Propagation_default_route_table_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["vpn_ecmp_support"]; ok {
	x := x.(string)
	r.Vpn_ecmp_support = &x
}
	return r
}


// Aws_ec2_transit_gatewayHandler ...
type Aws_ec2_transit_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ec2_transit_gatewayHandler) Create(desired *Aws_ec2_transit_gateway) (*Aws_ec2_transit_gateway, string, error) {
	rState := Aws_ec2_transit_gatewayMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ec2_transit_gateway", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ec2_transit_gatewayHandler) Read(externalID string) (*Aws_ec2_transit_gateway, error) {
	actual, err := bridge.Read(h.provider, "aws_ec2_transit_gateway", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ec2_transit_gatewayUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ec2_transit_gatewayHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ec2_transit_gateway", externalID)
}

type Aws_ssm_patch_baseline struct {
     Aws_ssm_patch_baseline_id *string
     Operating_system *string
     Approved_patches_compliance_level *string
     Name string
     Description *string
}


func Aws_ssm_patch_baselineMapper(r *Aws_ssm_patch_baseline) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Operating_system != nil {
    config["operating_system"] = *r.Operating_system
}
if r.Approved_patches_compliance_level != nil {
    config["approved_patches_compliance_level"] = *r.Approved_patches_compliance_level
}
    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_patch_baselineUnmapper(state map[string]interface{}) *Aws_ssm_patch_baseline {
	r := &Aws_ssm_patch_baseline{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_patch_baseline_id = &x
}

if x, ok := state["operating_system"]; ok {
	x := x.(string)
	r.Operating_system = &x
}

if x, ok := state["approved_patches_compliance_level"]; ok {
	x := x.(string)
	r.Approved_patches_compliance_level = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_ssm_patch_baselineHandler ...
type Aws_ssm_patch_baselineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_patch_baselineHandler) Create(desired *Aws_ssm_patch_baseline) (*Aws_ssm_patch_baseline, string, error) {
	rState := Aws_ssm_patch_baselineMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_patch_baseline", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_patch_baselineHandler) Read(externalID string) (*Aws_ssm_patch_baseline, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_patch_baseline", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_patch_baselineUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_patch_baselineHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_patch_baseline", externalID)
}

type Aws_route53_query_log struct {
     Aws_route53_query_log_id *string
     Cloudwatch_log_group_arn string
     Zone_id string
}


func Aws_route53_query_logMapper(r *Aws_route53_query_log) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["cloudwatch_log_group_arn"] = r.Cloudwatch_log_group_arn
    config["zone_id"] = r.Zone_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_route53_query_logUnmapper(state map[string]interface{}) *Aws_route53_query_log {
	r := &Aws_route53_query_log{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_route53_query_log_id = &x
}

if x, ok := state["cloudwatch_log_group_arn"]; ok {
	r.Cloudwatch_log_group_arn = x.(string)
}

if x, ok := state["zone_id"]; ok {
	r.Zone_id = x.(string)
}
	return r
}


// Aws_route53_query_logHandler ...
type Aws_route53_query_logHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_route53_query_logHandler) Create(desired *Aws_route53_query_log) (*Aws_route53_query_log, string, error) {
	rState := Aws_route53_query_logMapper(desired)
	id, err := bridge.Create(h.provider, "aws_route53_query_log", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_route53_query_logHandler) Read(externalID string) (*Aws_route53_query_log, error) {
	actual, err := bridge.Read(h.provider, "aws_route53_query_log", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_route53_query_logUnmapper(actual), nil
}

// Delete ...
func (h *Aws_route53_query_logHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_route53_query_log", externalID)
}

type Aws_ses_domain_dkim struct {
     Aws_ses_domain_dkim_id *string
     Domain string
}


func Aws_ses_domain_dkimMapper(r *Aws_ses_domain_dkim) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["domain"] = r.Domain
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_domain_dkimUnmapper(state map[string]interface{}) *Aws_ses_domain_dkim {
	r := &Aws_ses_domain_dkim{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_domain_dkim_id = &x
}

if x, ok := state["domain"]; ok {
	r.Domain = x.(string)
}
	return r
}


// Aws_ses_domain_dkimHandler ...
type Aws_ses_domain_dkimHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_domain_dkimHandler) Create(desired *Aws_ses_domain_dkim) (*Aws_ses_domain_dkim, string, error) {
	rState := Aws_ses_domain_dkimMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_domain_dkim", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_domain_dkimHandler) Read(externalID string) (*Aws_ses_domain_dkim, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_domain_dkim", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_domain_dkimUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_domain_dkimHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_domain_dkim", externalID)
}

type Aws_egress_only_internet_gateway struct {
     Aws_egress_only_internet_gateway_id *string
     Vpc_id string
}


func Aws_egress_only_internet_gatewayMapper(r *Aws_egress_only_internet_gateway) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_id"] = r.Vpc_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_egress_only_internet_gatewayUnmapper(state map[string]interface{}) *Aws_egress_only_internet_gateway {
	r := &Aws_egress_only_internet_gateway{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_egress_only_internet_gateway_id = &x
}

if x, ok := state["vpc_id"]; ok {
	r.Vpc_id = x.(string)
}
	return r
}


// Aws_egress_only_internet_gatewayHandler ...
type Aws_egress_only_internet_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_egress_only_internet_gatewayHandler) Create(desired *Aws_egress_only_internet_gateway) (*Aws_egress_only_internet_gateway, string, error) {
	rState := Aws_egress_only_internet_gatewayMapper(desired)
	id, err := bridge.Create(h.provider, "aws_egress_only_internet_gateway", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_egress_only_internet_gatewayHandler) Read(externalID string) (*Aws_egress_only_internet_gateway, error) {
	actual, err := bridge.Read(h.provider, "aws_egress_only_internet_gateway", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_egress_only_internet_gatewayUnmapper(actual), nil
}

// Delete ...
func (h *Aws_egress_only_internet_gatewayHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_egress_only_internet_gateway", externalID)
}

type Aws_eip_association struct {
     Aws_eip_association_id *string
     Allocation_id *string
     Allow_reassociation *bool
     Instance_id *string
     Network_interface_id *string
     Private_ip_address *string
     Public_ip *string
}


func Aws_eip_associationMapper(r *Aws_eip_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Allocation_id != nil {
    config["allocation_id"] = *r.Allocation_id
}
if r.Allow_reassociation != nil {
    config["allow_reassociation"] = *r.Allow_reassociation
}
if r.Instance_id != nil {
    config["instance_id"] = *r.Instance_id
}
if r.Network_interface_id != nil {
    config["network_interface_id"] = *r.Network_interface_id
}
if r.Private_ip_address != nil {
    config["private_ip_address"] = *r.Private_ip_address
}
if r.Public_ip != nil {
    config["public_ip"] = *r.Public_ip
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_eip_associationUnmapper(state map[string]interface{}) *Aws_eip_association {
	r := &Aws_eip_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_eip_association_id = &x
}

if x, ok := state["allocation_id"]; ok {
	x := x.(string)
	r.Allocation_id = &x
}

if x, ok := state["allow_reassociation"]; ok {
	x := x.(bool)
	r.Allow_reassociation = &x
}

if x, ok := state["instance_id"]; ok {
	x := x.(string)
	r.Instance_id = &x
}

if x, ok := state["network_interface_id"]; ok {
	x := x.(string)
	r.Network_interface_id = &x
}

if x, ok := state["private_ip_address"]; ok {
	x := x.(string)
	r.Private_ip_address = &x
}

if x, ok := state["public_ip"]; ok {
	x := x.(string)
	r.Public_ip = &x
}
	return r
}


// Aws_eip_associationHandler ...
type Aws_eip_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_eip_associationHandler) Create(desired *Aws_eip_association) (*Aws_eip_association, string, error) {
	rState := Aws_eip_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_eip_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_eip_associationHandler) Read(externalID string) (*Aws_eip_association, error) {
	actual, err := bridge.Read(h.provider, "aws_eip_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_eip_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_eip_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_eip_association", externalID)
}

type Aws_neptune_cluster_instance struct {
     Aws_neptune_cluster_instance_id *string
     Neptune_subnet_group_name *string
     Preferred_maintenance_window *string
     Publicly_accessible *bool
     Storage_encrypted *bool
     Tags *map[string]string
     Endpoint *string
     Instance_class string
     Neptune_parameter_group_name *string
     Identifier_prefix *string
     Writer *bool
     Auto_minor_version_upgrade *bool
     Dbi_resource_id *string
     Engine_version *string
     Engine *string
     Apply_immediately *bool
     Arn *string
     Availability_zone *string
     Kms_key_arn *string
     Preferred_backup_window *string
     Address *string
     Cluster_identifier string
     Identifier *string
}


func Aws_neptune_cluster_instanceMapper(r *Aws_neptune_cluster_instance) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Apply_immediately != nil {
    config["apply_immediately"] = *r.Apply_immediately
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Address != nil {
    config["address"] = *r.Address
}
    config["cluster_identifier"] = r.Cluster_identifier
if r.Identifier != nil {
    config["identifier"] = *r.Identifier
}
if r.Kms_key_arn != nil {
    config["kms_key_arn"] = *r.Kms_key_arn
}
if r.Preferred_backup_window != nil {
    config["preferred_backup_window"] = *r.Preferred_backup_window
}
if r.Publicly_accessible != nil {
    config["publicly_accessible"] = *r.Publicly_accessible
}
if r.Storage_encrypted != nil {
    config["storage_encrypted"] = *r.Storage_encrypted
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
    config["instance_class"] = r.Instance_class
if r.Neptune_parameter_group_name != nil {
    config["neptune_parameter_group_name"] = *r.Neptune_parameter_group_name
}
if r.Neptune_subnet_group_name != nil {
    config["neptune_subnet_group_name"] = *r.Neptune_subnet_group_name
}
if r.Preferred_maintenance_window != nil {
    config["preferred_maintenance_window"] = *r.Preferred_maintenance_window
}
if r.Auto_minor_version_upgrade != nil {
    config["auto_minor_version_upgrade"] = *r.Auto_minor_version_upgrade
}
if r.Dbi_resource_id != nil {
    config["dbi_resource_id"] = *r.Dbi_resource_id
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Identifier_prefix != nil {
    config["identifier_prefix"] = *r.Identifier_prefix
}
if r.Writer != nil {
    config["writer"] = *r.Writer
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_neptune_cluster_instanceUnmapper(state map[string]interface{}) *Aws_neptune_cluster_instance {
	r := &Aws_neptune_cluster_instance{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_neptune_cluster_instance_id = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["apply_immediately"]; ok {
	x := x.(bool)
	r.Apply_immediately = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["identifier"]; ok {
	x := x.(string)
	r.Identifier = &x
}

if x, ok := state["kms_key_arn"]; ok {
	x := x.(string)
	r.Kms_key_arn = &x
}

if x, ok := state["preferred_backup_window"]; ok {
	x := x.(string)
	r.Preferred_backup_window = &x
}

if x, ok := state["address"]; ok {
	x := x.(string)
	r.Address = &x
}

if x, ok := state["cluster_identifier"]; ok {
	r.Cluster_identifier = x.(string)
}

if x, ok := state["neptune_parameter_group_name"]; ok {
	x := x.(string)
	r.Neptune_parameter_group_name = &x
}

if x, ok := state["neptune_subnet_group_name"]; ok {
	x := x.(string)
	r.Neptune_subnet_group_name = &x
}

if x, ok := state["preferred_maintenance_window"]; ok {
	x := x.(string)
	r.Preferred_maintenance_window = &x
}

if x, ok := state["publicly_accessible"]; ok {
	x := x.(bool)
	r.Publicly_accessible = &x
}

if x, ok := state["storage_encrypted"]; ok {
	x := x.(bool)
	r.Storage_encrypted = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["instance_class"]; ok {
	r.Instance_class = x.(string)
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["identifier_prefix"]; ok {
	x := x.(string)
	r.Identifier_prefix = &x
}

if x, ok := state["writer"]; ok {
	x := x.(bool)
	r.Writer = &x
}

if x, ok := state["auto_minor_version_upgrade"]; ok {
	x := x.(bool)
	r.Auto_minor_version_upgrade = &x
}

if x, ok := state["dbi_resource_id"]; ok {
	x := x.(string)
	r.Dbi_resource_id = &x
}
	return r
}


// Aws_neptune_cluster_instanceHandler ...
type Aws_neptune_cluster_instanceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_neptune_cluster_instanceHandler) Create(desired *Aws_neptune_cluster_instance) (*Aws_neptune_cluster_instance, string, error) {
	rState := Aws_neptune_cluster_instanceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_neptune_cluster_instance", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_neptune_cluster_instanceHandler) Read(externalID string) (*Aws_neptune_cluster_instance, error) {
	actual, err := bridge.Read(h.provider, "aws_neptune_cluster_instance", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_neptune_cluster_instanceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_neptune_cluster_instanceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_neptune_cluster_instance", externalID)
}

type Aws_alb_target_group_attachment struct {
     Aws_alb_target_group_attachment_id *string
     Target_group_arn string
     Target_id string
     Availability_zone *string
}


func Aws_alb_target_group_attachmentMapper(r *Aws_alb_target_group_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["target_group_arn"] = r.Target_group_arn
    config["target_id"] = r.Target_id
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_alb_target_group_attachmentUnmapper(state map[string]interface{}) *Aws_alb_target_group_attachment {
	r := &Aws_alb_target_group_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_alb_target_group_attachment_id = &x
}

if x, ok := state["target_group_arn"]; ok {
	r.Target_group_arn = x.(string)
}

if x, ok := state["target_id"]; ok {
	r.Target_id = x.(string)
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}
	return r
}


// Aws_alb_target_group_attachmentHandler ...
type Aws_alb_target_group_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_alb_target_group_attachmentHandler) Create(desired *Aws_alb_target_group_attachment) (*Aws_alb_target_group_attachment, string, error) {
	rState := Aws_alb_target_group_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_alb_target_group_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_alb_target_group_attachmentHandler) Read(externalID string) (*Aws_alb_target_group_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_alb_target_group_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_alb_target_group_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_alb_target_group_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_alb_target_group_attachment", externalID)
}

type Aws_api_gateway_request_validator struct {
     Aws_api_gateway_request_validator_id *string
     Rest_api_id string
     Name string
     Validate_request_body *bool
     Validate_request_parameters *bool
}


func Aws_api_gateway_request_validatorMapper(r *Aws_api_gateway_request_validator) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Validate_request_body != nil {
    config["validate_request_body"] = *r.Validate_request_body
}
if r.Validate_request_parameters != nil {
    config["validate_request_parameters"] = *r.Validate_request_parameters
}
    config["rest_api_id"] = r.Rest_api_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_request_validatorUnmapper(state map[string]interface{}) *Aws_api_gateway_request_validator {
	r := &Aws_api_gateway_request_validator{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_request_validator_id = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["validate_request_body"]; ok {
	x := x.(bool)
	r.Validate_request_body = &x
}

if x, ok := state["validate_request_parameters"]; ok {
	x := x.(bool)
	r.Validate_request_parameters = &x
}
	return r
}


// Aws_api_gateway_request_validatorHandler ...
type Aws_api_gateway_request_validatorHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_request_validatorHandler) Create(desired *Aws_api_gateway_request_validator) (*Aws_api_gateway_request_validator, string, error) {
	rState := Aws_api_gateway_request_validatorMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_request_validator", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_request_validatorHandler) Read(externalID string) (*Aws_api_gateway_request_validator, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_request_validator", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_request_validatorUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_request_validatorHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_request_validator", externalID)
}

type Aws_load_balancer_backend_server_policy struct {
     Aws_load_balancer_backend_server_policy_id *string
     Load_balancer_name string
}


func Aws_load_balancer_backend_server_policyMapper(r *Aws_load_balancer_backend_server_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["load_balancer_name"] = r.Load_balancer_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_load_balancer_backend_server_policyUnmapper(state map[string]interface{}) *Aws_load_balancer_backend_server_policy {
	r := &Aws_load_balancer_backend_server_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_load_balancer_backend_server_policy_id = &x
}

if x, ok := state["load_balancer_name"]; ok {
	r.Load_balancer_name = x.(string)
}
	return r
}


// Aws_load_balancer_backend_server_policyHandler ...
type Aws_load_balancer_backend_server_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_load_balancer_backend_server_policyHandler) Create(desired *Aws_load_balancer_backend_server_policy) (*Aws_load_balancer_backend_server_policy, string, error) {
	rState := Aws_load_balancer_backend_server_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_load_balancer_backend_server_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_load_balancer_backend_server_policyHandler) Read(externalID string) (*Aws_load_balancer_backend_server_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_load_balancer_backend_server_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_load_balancer_backend_server_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_load_balancer_backend_server_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_load_balancer_backend_server_policy", externalID)
}

type Aws_vpc_endpoint_subnet_association struct {
     Aws_vpc_endpoint_subnet_association_id *string
     Subnet_id string
     Vpc_endpoint_id string
}


func Aws_vpc_endpoint_subnet_associationMapper(r *Aws_vpc_endpoint_subnet_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_endpoint_id"] = r.Vpc_endpoint_id
    config["subnet_id"] = r.Subnet_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_endpoint_subnet_associationUnmapper(state map[string]interface{}) *Aws_vpc_endpoint_subnet_association {
	r := &Aws_vpc_endpoint_subnet_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_endpoint_subnet_association_id = &x
}

if x, ok := state["subnet_id"]; ok {
	r.Subnet_id = x.(string)
}

if x, ok := state["vpc_endpoint_id"]; ok {
	r.Vpc_endpoint_id = x.(string)
}
	return r
}


// Aws_vpc_endpoint_subnet_associationHandler ...
type Aws_vpc_endpoint_subnet_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_endpoint_subnet_associationHandler) Create(desired *Aws_vpc_endpoint_subnet_association) (*Aws_vpc_endpoint_subnet_association, string, error) {
	rState := Aws_vpc_endpoint_subnet_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_endpoint_subnet_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_endpoint_subnet_associationHandler) Read(externalID string) (*Aws_vpc_endpoint_subnet_association, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_endpoint_subnet_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_endpoint_subnet_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_endpoint_subnet_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_endpoint_subnet_association", externalID)
}

type Aws_waf_geo_match_set struct {
     Aws_waf_geo_match_set_id *string
     Name string
}


func Aws_waf_geo_match_setMapper(r *Aws_waf_geo_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_geo_match_setUnmapper(state map[string]interface{}) *Aws_waf_geo_match_set {
	r := &Aws_waf_geo_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_geo_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_waf_geo_match_setHandler ...
type Aws_waf_geo_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_geo_match_setHandler) Create(desired *Aws_waf_geo_match_set) (*Aws_waf_geo_match_set, string, error) {
	rState := Aws_waf_geo_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_geo_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_geo_match_setHandler) Read(externalID string) (*Aws_waf_geo_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_geo_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_geo_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_geo_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_geo_match_set", externalID)
}

type Aws_alb_target_group struct {
     Aws_alb_target_group_id *string
     Arn *string
     Arn_suffix *string
     Name *string
     Name_prefix *string
     Proxy_protocol_v2 *bool
     Tags *map[string]string
     Protocol *string
     Vpc_id *string
     Target_type *string
}


func Aws_alb_target_groupMapper(r *Aws_alb_target_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Protocol != nil {
    config["protocol"] = *r.Protocol
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
if r.Target_type != nil {
    config["target_type"] = *r.Target_type
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Arn_suffix != nil {
    config["arn_suffix"] = *r.Arn_suffix
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Proxy_protocol_v2 != nil {
    config["proxy_protocol_v2"] = *r.Proxy_protocol_v2
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_alb_target_groupUnmapper(state map[string]interface{}) *Aws_alb_target_group {
	r := &Aws_alb_target_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_alb_target_group_id = &x
}

if x, ok := state["target_type"]; ok {
	x := x.(string)
	r.Target_type = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["protocol"]; ok {
	x := x.(string)
	r.Protocol = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["arn_suffix"]; ok {
	x := x.(string)
	r.Arn_suffix = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["proxy_protocol_v2"]; ok {
	x := x.(bool)
	r.Proxy_protocol_v2 = &x
}
	return r
}


// Aws_alb_target_groupHandler ...
type Aws_alb_target_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_alb_target_groupHandler) Create(desired *Aws_alb_target_group) (*Aws_alb_target_group, string, error) {
	rState := Aws_alb_target_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_alb_target_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_alb_target_groupHandler) Read(externalID string) (*Aws_alb_target_group, error) {
	actual, err := bridge.Read(h.provider, "aws_alb_target_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_alb_target_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_alb_target_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_alb_target_group", externalID)
}

type Aws_iam_user_ssh_key struct {
     Aws_iam_user_ssh_key_id *string
     Ssh_public_key_id *string
     Fingerprint *string
     Username string
     Public_key string
     Encoding string
     Status *string
}


func Aws_iam_user_ssh_keyMapper(r *Aws_iam_user_ssh_key) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Ssh_public_key_id != nil {
    config["ssh_public_key_id"] = *r.Ssh_public_key_id
}
if r.Fingerprint != nil {
    config["fingerprint"] = *r.Fingerprint
}
    config["username"] = r.Username
    config["public_key"] = r.Public_key
    config["encoding"] = r.Encoding
if r.Status != nil {
    config["status"] = *r.Status
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_user_ssh_keyUnmapper(state map[string]interface{}) *Aws_iam_user_ssh_key {
	r := &Aws_iam_user_ssh_key{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_user_ssh_key_id = &x
}

if x, ok := state["ssh_public_key_id"]; ok {
	x := x.(string)
	r.Ssh_public_key_id = &x
}

if x, ok := state["fingerprint"]; ok {
	x := x.(string)
	r.Fingerprint = &x
}

if x, ok := state["username"]; ok {
	r.Username = x.(string)
}

if x, ok := state["public_key"]; ok {
	r.Public_key = x.(string)
}

if x, ok := state["encoding"]; ok {
	r.Encoding = x.(string)
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}
	return r
}


// Aws_iam_user_ssh_keyHandler ...
type Aws_iam_user_ssh_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_user_ssh_keyHandler) Create(desired *Aws_iam_user_ssh_key) (*Aws_iam_user_ssh_key, string, error) {
	rState := Aws_iam_user_ssh_keyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_user_ssh_key", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_user_ssh_keyHandler) Read(externalID string) (*Aws_iam_user_ssh_key, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_user_ssh_key", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_user_ssh_keyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_user_ssh_keyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_user_ssh_key", externalID)
}

type Aws_snapshot_create_volume_permission struct {
     Aws_snapshot_create_volume_permission_id *string
     Snapshot_id string
     Account_id string
}


func Aws_snapshot_create_volume_permissionMapper(r *Aws_snapshot_create_volume_permission) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["snapshot_id"] = r.Snapshot_id
    config["account_id"] = r.Account_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_snapshot_create_volume_permissionUnmapper(state map[string]interface{}) *Aws_snapshot_create_volume_permission {
	r := &Aws_snapshot_create_volume_permission{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_snapshot_create_volume_permission_id = &x
}

if x, ok := state["account_id"]; ok {
	r.Account_id = x.(string)
}

if x, ok := state["snapshot_id"]; ok {
	r.Snapshot_id = x.(string)
}
	return r
}


// Aws_snapshot_create_volume_permissionHandler ...
type Aws_snapshot_create_volume_permissionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_snapshot_create_volume_permissionHandler) Create(desired *Aws_snapshot_create_volume_permission) (*Aws_snapshot_create_volume_permission, string, error) {
	rState := Aws_snapshot_create_volume_permissionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_snapshot_create_volume_permission", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_snapshot_create_volume_permissionHandler) Read(externalID string) (*Aws_snapshot_create_volume_permission, error) {
	actual, err := bridge.Read(h.provider, "aws_snapshot_create_volume_permission", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_snapshot_create_volume_permissionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_snapshot_create_volume_permissionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_snapshot_create_volume_permission", externalID)
}

type Aws_lightsail_domain struct {
     Aws_lightsail_domain_id *string
     Domain_name string
     Arn *string
}


func Aws_lightsail_domainMapper(r *Aws_lightsail_domain) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["domain_name"] = r.Domain_name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lightsail_domainUnmapper(state map[string]interface{}) *Aws_lightsail_domain {
	r := &Aws_lightsail_domain{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lightsail_domain_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["domain_name"]; ok {
	r.Domain_name = x.(string)
}
	return r
}


// Aws_lightsail_domainHandler ...
type Aws_lightsail_domainHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lightsail_domainHandler) Create(desired *Aws_lightsail_domain) (*Aws_lightsail_domain, string, error) {
	rState := Aws_lightsail_domainMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lightsail_domain", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lightsail_domainHandler) Read(externalID string) (*Aws_lightsail_domain, error) {
	actual, err := bridge.Read(h.provider, "aws_lightsail_domain", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lightsail_domainUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lightsail_domainHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lightsail_domain", externalID)
}

type Aws_placement_group struct {
     Aws_placement_group_id *string
     Name string
     Strategy string
}


func Aws_placement_groupMapper(r *Aws_placement_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["strategy"] = r.Strategy
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_placement_groupUnmapper(state map[string]interface{}) *Aws_placement_group {
	r := &Aws_placement_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_placement_group_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["strategy"]; ok {
	r.Strategy = x.(string)
}
	return r
}


// Aws_placement_groupHandler ...
type Aws_placement_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_placement_groupHandler) Create(desired *Aws_placement_group) (*Aws_placement_group, string, error) {
	rState := Aws_placement_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_placement_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_placement_groupHandler) Read(externalID string) (*Aws_placement_group, error) {
	actual, err := bridge.Read(h.provider, "aws_placement_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_placement_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_placement_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_placement_group", externalID)
}

type Aws_default_vpc struct {
     Aws_default_vpc_id *string
     Instance_tenancy *string
     Enable_dns_hostnames *bool
     Enable_classiclink_dns_support *bool
     Enable_dns_support *bool
     Default_security_group_id *string
     Arn *string
     Tags *map[string]string
     Owner_id *string
     Cidr_block *string
     Enable_classiclink *bool
     Assign_generated_ipv6_cidr_block *bool
     Default_network_acl_id *string
     Dhcp_options_id *string
     Ipv6_association_id *string
     Ipv6_cidr_block *string
     Main_route_table_id *string
     Default_route_table_id *string
}


func Aws_default_vpcMapper(r *Aws_default_vpc) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Dhcp_options_id != nil {
    config["dhcp_options_id"] = *r.Dhcp_options_id
}
if r.Ipv6_association_id != nil {
    config["ipv6_association_id"] = *r.Ipv6_association_id
}
if r.Ipv6_cidr_block != nil {
    config["ipv6_cidr_block"] = *r.Ipv6_cidr_block
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
if r.Cidr_block != nil {
    config["cidr_block"] = *r.Cidr_block
}
if r.Enable_classiclink != nil {
    config["enable_classiclink"] = *r.Enable_classiclink
}
if r.Assign_generated_ipv6_cidr_block != nil {
    config["assign_generated_ipv6_cidr_block"] = *r.Assign_generated_ipv6_cidr_block
}
if r.Default_network_acl_id != nil {
    config["default_network_acl_id"] = *r.Default_network_acl_id
}
if r.Main_route_table_id != nil {
    config["main_route_table_id"] = *r.Main_route_table_id
}
if r.Default_route_table_id != nil {
    config["default_route_table_id"] = *r.Default_route_table_id
}
if r.Instance_tenancy != nil {
    config["instance_tenancy"] = *r.Instance_tenancy
}
if r.Enable_dns_hostnames != nil {
    config["enable_dns_hostnames"] = *r.Enable_dns_hostnames
}
if r.Enable_classiclink_dns_support != nil {
    config["enable_classiclink_dns_support"] = *r.Enable_classiclink_dns_support
}
if r.Enable_dns_support != nil {
    config["enable_dns_support"] = *r.Enable_dns_support
}
if r.Default_security_group_id != nil {
    config["default_security_group_id"] = *r.Default_security_group_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_default_vpcUnmapper(state map[string]interface{}) *Aws_default_vpc {
	r := &Aws_default_vpc{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_default_vpc_id = &x
}

if x, ok := state["ipv6_cidr_block"]; ok {
	x := x.(string)
	r.Ipv6_cidr_block = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["cidr_block"]; ok {
	x := x.(string)
	r.Cidr_block = &x
}

if x, ok := state["enable_classiclink"]; ok {
	x := x.(bool)
	r.Enable_classiclink = &x
}

if x, ok := state["assign_generated_ipv6_cidr_block"]; ok {
	x := x.(bool)
	r.Assign_generated_ipv6_cidr_block = &x
}

if x, ok := state["default_network_acl_id"]; ok {
	x := x.(string)
	r.Default_network_acl_id = &x
}

if x, ok := state["dhcp_options_id"]; ok {
	x := x.(string)
	r.Dhcp_options_id = &x
}

if x, ok := state["ipv6_association_id"]; ok {
	x := x.(string)
	r.Ipv6_association_id = &x
}

if x, ok := state["main_route_table_id"]; ok {
	x := x.(string)
	r.Main_route_table_id = &x
}

if x, ok := state["default_route_table_id"]; ok {
	x := x.(string)
	r.Default_route_table_id = &x
}

if x, ok := state["instance_tenancy"]; ok {
	x := x.(string)
	r.Instance_tenancy = &x
}

if x, ok := state["enable_dns_hostnames"]; ok {
	x := x.(bool)
	r.Enable_dns_hostnames = &x
}

if x, ok := state["enable_classiclink_dns_support"]; ok {
	x := x.(bool)
	r.Enable_classiclink_dns_support = &x
}

if x, ok := state["enable_dns_support"]; ok {
	x := x.(bool)
	r.Enable_dns_support = &x
}

if x, ok := state["default_security_group_id"]; ok {
	x := x.(string)
	r.Default_security_group_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_default_vpcHandler ...
type Aws_default_vpcHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_default_vpcHandler) Create(desired *Aws_default_vpc) (*Aws_default_vpc, string, error) {
	rState := Aws_default_vpcMapper(desired)
	id, err := bridge.Create(h.provider, "aws_default_vpc", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_default_vpcHandler) Read(externalID string) (*Aws_default_vpc, error) {
	actual, err := bridge.Read(h.provider, "aws_default_vpc", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_default_vpcUnmapper(actual), nil
}

// Delete ...
func (h *Aws_default_vpcHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_default_vpc", externalID)
}

type Aws_wafregional_size_constraint_set struct {
     Aws_wafregional_size_constraint_set_id *string
     Name string
}


func Aws_wafregional_size_constraint_setMapper(r *Aws_wafregional_size_constraint_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_size_constraint_setUnmapper(state map[string]interface{}) *Aws_wafregional_size_constraint_set {
	r := &Aws_wafregional_size_constraint_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_size_constraint_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_wafregional_size_constraint_setHandler ...
type Aws_wafregional_size_constraint_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_size_constraint_setHandler) Create(desired *Aws_wafregional_size_constraint_set) (*Aws_wafregional_size_constraint_set, string, error) {
	rState := Aws_wafregional_size_constraint_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_size_constraint_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_size_constraint_setHandler) Read(externalID string) (*Aws_wafregional_size_constraint_set, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_size_constraint_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_size_constraint_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_size_constraint_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_size_constraint_set", externalID)
}

type Aws_db_event_subscription struct {
     Aws_db_event_subscription_id *string
     Arn *string
     Name *string
     Sns_topic string
     Source_type *string
     Tags *map[string]string
     Name_prefix *string
     Enabled *bool
     Customer_aws_id *string
}


func Aws_db_event_subscriptionMapper(r *Aws_db_event_subscription) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.Customer_aws_id != nil {
    config["customer_aws_id"] = *r.Customer_aws_id
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Source_type != nil {
    config["source_type"] = *r.Source_type
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Name != nil {
    config["name"] = *r.Name
}
    config["sns_topic"] = r.Sns_topic
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_db_event_subscriptionUnmapper(state map[string]interface{}) *Aws_db_event_subscription {
	r := &Aws_db_event_subscription{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_db_event_subscription_id = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["customer_aws_id"]; ok {
	x := x.(string)
	r.Customer_aws_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["sns_topic"]; ok {
	r.Sns_topic = x.(string)
}

if x, ok := state["source_type"]; ok {
	x := x.(string)
	r.Source_type = &x
}
	return r
}


// Aws_db_event_subscriptionHandler ...
type Aws_db_event_subscriptionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_db_event_subscriptionHandler) Create(desired *Aws_db_event_subscription) (*Aws_db_event_subscription, string, error) {
	rState := Aws_db_event_subscriptionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_db_event_subscription", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_db_event_subscriptionHandler) Read(externalID string) (*Aws_db_event_subscription, error) {
	actual, err := bridge.Read(h.provider, "aws_db_event_subscription", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_db_event_subscriptionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_db_event_subscriptionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_db_event_subscription", externalID)
}

type Aws_gamelift_alias struct {
     Aws_gamelift_alias_id *string
     Name string
     Description *string
     Arn *string
}


func Aws_gamelift_aliasMapper(r *Aws_gamelift_alias) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_gamelift_aliasUnmapper(state map[string]interface{}) *Aws_gamelift_alias {
	r := &Aws_gamelift_alias{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_gamelift_alias_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_gamelift_aliasHandler ...
type Aws_gamelift_aliasHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_gamelift_aliasHandler) Create(desired *Aws_gamelift_alias) (*Aws_gamelift_alias, string, error) {
	rState := Aws_gamelift_aliasMapper(desired)
	id, err := bridge.Create(h.provider, "aws_gamelift_alias", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_gamelift_aliasHandler) Read(externalID string) (*Aws_gamelift_alias, error) {
	actual, err := bridge.Read(h.provider, "aws_gamelift_alias", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_gamelift_aliasUnmapper(actual), nil
}

// Delete ...
func (h *Aws_gamelift_aliasHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_gamelift_alias", externalID)
}

type Aws_ses_domain_identity_verification struct {
     Aws_ses_domain_identity_verification_id *string
     Domain string
     Arn *string
}


func Aws_ses_domain_identity_verificationMapper(r *Aws_ses_domain_identity_verification) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["domain"] = r.Domain
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_domain_identity_verificationUnmapper(state map[string]interface{}) *Aws_ses_domain_identity_verification {
	r := &Aws_ses_domain_identity_verification{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_domain_identity_verification_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["domain"]; ok {
	r.Domain = x.(string)
}
	return r
}


// Aws_ses_domain_identity_verificationHandler ...
type Aws_ses_domain_identity_verificationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_domain_identity_verificationHandler) Create(desired *Aws_ses_domain_identity_verification) (*Aws_ses_domain_identity_verification, string, error) {
	rState := Aws_ses_domain_identity_verificationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_domain_identity_verification", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_domain_identity_verificationHandler) Read(externalID string) (*Aws_ses_domain_identity_verification, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_domain_identity_verification", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_domain_identity_verificationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_domain_identity_verificationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_domain_identity_verification", externalID)
}

type Aws_glacier_vault_lock struct {
     Aws_glacier_vault_lock_id *string
     Complete_lock bool
     Ignore_deletion_error *bool
     Policy string
     Vault_name string
}


func Aws_glacier_vault_lockMapper(r *Aws_glacier_vault_lock) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["complete_lock"] = r.Complete_lock
if r.Ignore_deletion_error != nil {
    config["ignore_deletion_error"] = *r.Ignore_deletion_error
}
    config["policy"] = r.Policy
    config["vault_name"] = r.Vault_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glacier_vault_lockUnmapper(state map[string]interface{}) *Aws_glacier_vault_lock {
	r := &Aws_glacier_vault_lock{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glacier_vault_lock_id = &x
}

if x, ok := state["complete_lock"]; ok {
	r.Complete_lock = x.(bool)
}

if x, ok := state["ignore_deletion_error"]; ok {
	x := x.(bool)
	r.Ignore_deletion_error = &x
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}

if x, ok := state["vault_name"]; ok {
	r.Vault_name = x.(string)
}
	return r
}


// Aws_glacier_vault_lockHandler ...
type Aws_glacier_vault_lockHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glacier_vault_lockHandler) Create(desired *Aws_glacier_vault_lock) (*Aws_glacier_vault_lock, string, error) {
	rState := Aws_glacier_vault_lockMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glacier_vault_lock", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glacier_vault_lockHandler) Read(externalID string) (*Aws_glacier_vault_lock, error) {
	actual, err := bridge.Read(h.provider, "aws_glacier_vault_lock", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glacier_vault_lockUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glacier_vault_lockHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glacier_vault_lock", externalID)
}

type Aws_sns_platform_application struct {
     Aws_sns_platform_application_id *string
     Event_endpoint_created_topic_arn *string
     Event_endpoint_deleted_topic_arn *string
     Event_endpoint_updated_topic_arn *string
     Failure_feedback_role_arn *string
     Platform_principal *string
     Name string
     Platform string
     Event_delivery_failure_topic_arn *string
     Success_feedback_role_arn *string
     Success_feedback_sample_rate *string
     Platform_credential string
     Arn *string
}


func Aws_sns_platform_applicationMapper(r *Aws_sns_platform_application) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["platform_credential"] = r.Platform_credential
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Platform_principal != nil {
    config["platform_principal"] = *r.Platform_principal
}
    config["name"] = r.Name
    config["platform"] = r.Platform
if r.Event_delivery_failure_topic_arn != nil {
    config["event_delivery_failure_topic_arn"] = *r.Event_delivery_failure_topic_arn
}
if r.Event_endpoint_created_topic_arn != nil {
    config["event_endpoint_created_topic_arn"] = *r.Event_endpoint_created_topic_arn
}
if r.Event_endpoint_deleted_topic_arn != nil {
    config["event_endpoint_deleted_topic_arn"] = *r.Event_endpoint_deleted_topic_arn
}
if r.Event_endpoint_updated_topic_arn != nil {
    config["event_endpoint_updated_topic_arn"] = *r.Event_endpoint_updated_topic_arn
}
if r.Failure_feedback_role_arn != nil {
    config["failure_feedback_role_arn"] = *r.Failure_feedback_role_arn
}
if r.Success_feedback_role_arn != nil {
    config["success_feedback_role_arn"] = *r.Success_feedback_role_arn
}
if r.Success_feedback_sample_rate != nil {
    config["success_feedback_sample_rate"] = *r.Success_feedback_sample_rate
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_sns_platform_applicationUnmapper(state map[string]interface{}) *Aws_sns_platform_application {
	r := &Aws_sns_platform_application{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_sns_platform_application_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["platform"]; ok {
	r.Platform = x.(string)
}

if x, ok := state["event_delivery_failure_topic_arn"]; ok {
	x := x.(string)
	r.Event_delivery_failure_topic_arn = &x
}

if x, ok := state["event_endpoint_created_topic_arn"]; ok {
	x := x.(string)
	r.Event_endpoint_created_topic_arn = &x
}

if x, ok := state["event_endpoint_deleted_topic_arn"]; ok {
	x := x.(string)
	r.Event_endpoint_deleted_topic_arn = &x
}

if x, ok := state["event_endpoint_updated_topic_arn"]; ok {
	x := x.(string)
	r.Event_endpoint_updated_topic_arn = &x
}

if x, ok := state["failure_feedback_role_arn"]; ok {
	x := x.(string)
	r.Failure_feedback_role_arn = &x
}

if x, ok := state["platform_principal"]; ok {
	x := x.(string)
	r.Platform_principal = &x
}

if x, ok := state["success_feedback_role_arn"]; ok {
	x := x.(string)
	r.Success_feedback_role_arn = &x
}

if x, ok := state["success_feedback_sample_rate"]; ok {
	x := x.(string)
	r.Success_feedback_sample_rate = &x
}

if x, ok := state["platform_credential"]; ok {
	r.Platform_credential = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_sns_platform_applicationHandler ...
type Aws_sns_platform_applicationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_sns_platform_applicationHandler) Create(desired *Aws_sns_platform_application) (*Aws_sns_platform_application, string, error) {
	rState := Aws_sns_platform_applicationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_sns_platform_application", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_sns_platform_applicationHandler) Read(externalID string) (*Aws_sns_platform_application, error) {
	actual, err := bridge.Read(h.provider, "aws_sns_platform_application", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_sns_platform_applicationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_sns_platform_applicationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_sns_platform_application", externalID)
}

type Aws_cloudwatch_log_destination_policy struct {
     Aws_cloudwatch_log_destination_policy_id *string
     Destination_name string
     Access_policy string
}


func Aws_cloudwatch_log_destination_policyMapper(r *Aws_cloudwatch_log_destination_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["destination_name"] = r.Destination_name
    config["access_policy"] = r.Access_policy
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_log_destination_policyUnmapper(state map[string]interface{}) *Aws_cloudwatch_log_destination_policy {
	r := &Aws_cloudwatch_log_destination_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_log_destination_policy_id = &x
}

if x, ok := state["destination_name"]; ok {
	r.Destination_name = x.(string)
}

if x, ok := state["access_policy"]; ok {
	r.Access_policy = x.(string)
}
	return r
}


// Aws_cloudwatch_log_destination_policyHandler ...
type Aws_cloudwatch_log_destination_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_log_destination_policyHandler) Create(desired *Aws_cloudwatch_log_destination_policy) (*Aws_cloudwatch_log_destination_policy, string, error) {
	rState := Aws_cloudwatch_log_destination_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_log_destination_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_log_destination_policyHandler) Read(externalID string) (*Aws_cloudwatch_log_destination_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_log_destination_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_log_destination_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_log_destination_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_log_destination_policy", externalID)
}

type Aws_emr_instance_group struct {
     Aws_emr_instance_group_id *string
     Status *string
     Name *string
     Ebs_optimized *bool
     Cluster_id string
     Instance_type string
}


func Aws_emr_instance_groupMapper(r *Aws_emr_instance_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Status != nil {
    config["status"] = *r.Status
}
if r.Name != nil {
    config["name"] = *r.Name
}
if r.Ebs_optimized != nil {
    config["ebs_optimized"] = *r.Ebs_optimized
}
    config["cluster_id"] = r.Cluster_id
    config["instance_type"] = r.Instance_type
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_emr_instance_groupUnmapper(state map[string]interface{}) *Aws_emr_instance_group {
	r := &Aws_emr_instance_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_emr_instance_group_id = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["ebs_optimized"]; ok {
	x := x.(bool)
	r.Ebs_optimized = &x
}

if x, ok := state["cluster_id"]; ok {
	r.Cluster_id = x.(string)
}

if x, ok := state["instance_type"]; ok {
	r.Instance_type = x.(string)
}
	return r
}


// Aws_emr_instance_groupHandler ...
type Aws_emr_instance_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_emr_instance_groupHandler) Create(desired *Aws_emr_instance_group) (*Aws_emr_instance_group, string, error) {
	rState := Aws_emr_instance_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_emr_instance_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_emr_instance_groupHandler) Read(externalID string) (*Aws_emr_instance_group, error) {
	actual, err := bridge.Read(h.provider, "aws_emr_instance_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_emr_instance_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_emr_instance_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_emr_instance_group", externalID)
}

type Aws_waf_regex_pattern_set struct {
     Aws_waf_regex_pattern_set_id *string
     Name string
}


func Aws_waf_regex_pattern_setMapper(r *Aws_waf_regex_pattern_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_waf_regex_pattern_setUnmapper(state map[string]interface{}) *Aws_waf_regex_pattern_set {
	r := &Aws_waf_regex_pattern_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_waf_regex_pattern_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_waf_regex_pattern_setHandler ...
type Aws_waf_regex_pattern_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_waf_regex_pattern_setHandler) Create(desired *Aws_waf_regex_pattern_set) (*Aws_waf_regex_pattern_set, string, error) {
	rState := Aws_waf_regex_pattern_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_waf_regex_pattern_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_waf_regex_pattern_setHandler) Read(externalID string) (*Aws_waf_regex_pattern_set, error) {
	actual, err := bridge.Read(h.provider, "aws_waf_regex_pattern_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_waf_regex_pattern_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_waf_regex_pattern_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_waf_regex_pattern_set", externalID)
}

type Aws_customer_gateway struct {
     Aws_customer_gateway_id *string
     Ip_address string
     Resource_type string
     Tags *map[string]string
}


func Aws_customer_gatewayMapper(r *Aws_customer_gateway) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["ip_address"] = r.Ip_address
    config["resource_type"] = r.Resource_type
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_customer_gatewayUnmapper(state map[string]interface{}) *Aws_customer_gateway {
	r := &Aws_customer_gateway{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_customer_gateway_id = &x
}

if x, ok := state["ip_address"]; ok {
	r.Ip_address = x.(string)
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_customer_gatewayHandler ...
type Aws_customer_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_customer_gatewayHandler) Create(desired *Aws_customer_gateway) (*Aws_customer_gateway, string, error) {
	rState := Aws_customer_gatewayMapper(desired)
	id, err := bridge.Create(h.provider, "aws_customer_gateway", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_customer_gatewayHandler) Read(externalID string) (*Aws_customer_gateway, error) {
	actual, err := bridge.Read(h.provider, "aws_customer_gateway", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_customer_gatewayUnmapper(actual), nil
}

// Delete ...
func (h *Aws_customer_gatewayHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_customer_gateway", externalID)
}

type Aws_organizations_account struct {
     Aws_organizations_account_id *string
     Email string
     Iam_user_access_to_billing *string
     Role_name *string
     Arn *string
     Joined_method *string
     Joined_timestamp *string
     Status *string
     Name string
}


func Aws_organizations_accountMapper(r *Aws_organizations_account) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Joined_timestamp != nil {
    config["joined_timestamp"] = *r.Joined_timestamp
}
if r.Status != nil {
    config["status"] = *r.Status
}
    config["name"] = r.Name
    config["email"] = r.Email
if r.Iam_user_access_to_billing != nil {
    config["iam_user_access_to_billing"] = *r.Iam_user_access_to_billing
}
if r.Role_name != nil {
    config["role_name"] = *r.Role_name
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Joined_method != nil {
    config["joined_method"] = *r.Joined_method
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_organizations_accountUnmapper(state map[string]interface{}) *Aws_organizations_account {
	r := &Aws_organizations_account{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_organizations_account_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["joined_method"]; ok {
	x := x.(string)
	r.Joined_method = &x
}

if x, ok := state["joined_timestamp"]; ok {
	x := x.(string)
	r.Joined_timestamp = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["email"]; ok {
	r.Email = x.(string)
}

if x, ok := state["iam_user_access_to_billing"]; ok {
	x := x.(string)
	r.Iam_user_access_to_billing = &x
}

if x, ok := state["role_name"]; ok {
	x := x.(string)
	r.Role_name = &x
}
	return r
}


// Aws_organizations_accountHandler ...
type Aws_organizations_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_organizations_accountHandler) Create(desired *Aws_organizations_account) (*Aws_organizations_account, string, error) {
	rState := Aws_organizations_accountMapper(desired)
	id, err := bridge.Create(h.provider, "aws_organizations_account", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_organizations_accountHandler) Read(externalID string) (*Aws_organizations_account, error) {
	actual, err := bridge.Read(h.provider, "aws_organizations_account", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_organizations_accountUnmapper(actual), nil
}

// Delete ...
func (h *Aws_organizations_accountHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_organizations_account", externalID)
}

type Aws_db_subnet_group struct {
     Aws_db_subnet_group_id *string
     Arn *string
     Name *string
     Name_prefix *string
     Description *string
     Tags *map[string]string
}


func Aws_db_subnet_groupMapper(r *Aws_db_subnet_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name != nil {
    config["name"] = *r.Name
}
if r.Name_prefix != nil {
    config["name_prefix"] = *r.Name_prefix
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_db_subnet_groupUnmapper(state map[string]interface{}) *Aws_db_subnet_group {
	r := &Aws_db_subnet_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_db_subnet_group_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["name_prefix"]; ok {
	x := x.(string)
	r.Name_prefix = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_db_subnet_groupHandler ...
type Aws_db_subnet_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_db_subnet_groupHandler) Create(desired *Aws_db_subnet_group) (*Aws_db_subnet_group, string, error) {
	rState := Aws_db_subnet_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_db_subnet_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_db_subnet_groupHandler) Read(externalID string) (*Aws_db_subnet_group, error) {
	actual, err := bridge.Read(h.provider, "aws_db_subnet_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_db_subnet_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_db_subnet_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_db_subnet_group", externalID)
}

type Aws_inspector_assessment_target struct {
     Aws_inspector_assessment_target_id *string
     Name string
     Arn *string
     Resource_group_arn *string
}


func Aws_inspector_assessment_targetMapper(r *Aws_inspector_assessment_target) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Resource_group_arn != nil {
    config["resource_group_arn"] = *r.Resource_group_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_inspector_assessment_targetUnmapper(state map[string]interface{}) *Aws_inspector_assessment_target {
	r := &Aws_inspector_assessment_target{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_inspector_assessment_target_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["resource_group_arn"]; ok {
	x := x.(string)
	r.Resource_group_arn = &x
}
	return r
}


// Aws_inspector_assessment_targetHandler ...
type Aws_inspector_assessment_targetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_inspector_assessment_targetHandler) Create(desired *Aws_inspector_assessment_target) (*Aws_inspector_assessment_target, string, error) {
	rState := Aws_inspector_assessment_targetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_inspector_assessment_target", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_inspector_assessment_targetHandler) Read(externalID string) (*Aws_inspector_assessment_target, error) {
	actual, err := bridge.Read(h.provider, "aws_inspector_assessment_target", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_inspector_assessment_targetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_inspector_assessment_targetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_inspector_assessment_target", externalID)
}

type Aws_lambda_permission struct {
     Aws_lambda_permission_id *string
     Qualifier *string
     Source_arn *string
     Statement_id *string
     Statement_id_prefix *string
     Action string
     Event_source_token *string
     Function_name string
     Principal string
     Source_account *string
}


func Aws_lambda_permissionMapper(r *Aws_lambda_permission) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Statement_id != nil {
    config["statement_id"] = *r.Statement_id
}
if r.Qualifier != nil {
    config["qualifier"] = *r.Qualifier
}
if r.Source_arn != nil {
    config["source_arn"] = *r.Source_arn
}
    config["function_name"] = r.Function_name
    config["principal"] = r.Principal
if r.Source_account != nil {
    config["source_account"] = *r.Source_account
}
if r.Statement_id_prefix != nil {
    config["statement_id_prefix"] = *r.Statement_id_prefix
}
    config["action"] = r.Action
if r.Event_source_token != nil {
    config["event_source_token"] = *r.Event_source_token
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lambda_permissionUnmapper(state map[string]interface{}) *Aws_lambda_permission {
	r := &Aws_lambda_permission{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lambda_permission_id = &x
}

if x, ok := state["qualifier"]; ok {
	x := x.(string)
	r.Qualifier = &x
}

if x, ok := state["source_arn"]; ok {
	x := x.(string)
	r.Source_arn = &x
}

if x, ok := state["statement_id"]; ok {
	x := x.(string)
	r.Statement_id = &x
}

if x, ok := state["statement_id_prefix"]; ok {
	x := x.(string)
	r.Statement_id_prefix = &x
}

if x, ok := state["action"]; ok {
	r.Action = x.(string)
}

if x, ok := state["event_source_token"]; ok {
	x := x.(string)
	r.Event_source_token = &x
}

if x, ok := state["function_name"]; ok {
	r.Function_name = x.(string)
}

if x, ok := state["principal"]; ok {
	r.Principal = x.(string)
}

if x, ok := state["source_account"]; ok {
	x := x.(string)
	r.Source_account = &x
}
	return r
}


// Aws_lambda_permissionHandler ...
type Aws_lambda_permissionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lambda_permissionHandler) Create(desired *Aws_lambda_permission) (*Aws_lambda_permission, string, error) {
	rState := Aws_lambda_permissionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lambda_permission", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lambda_permissionHandler) Read(externalID string) (*Aws_lambda_permission, error) {
	actual, err := bridge.Read(h.provider, "aws_lambda_permission", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lambda_permissionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lambda_permissionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lambda_permission", externalID)
}

type Aws_acmpca_certificate_authority struct {
     Aws_acmpca_certificate_authority_id *string
     Enabled *bool
     Not_after *string
     Serial *string
     Status *string
     Tags *map[string]string
     Resource_type *string
     Arn *string
     Certificate *string
     Certificate_chain *string
     Certificate_signing_request *string
     Not_before *string
}


func Aws_acmpca_certificate_authorityMapper(r *Aws_acmpca_certificate_authority) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.Not_after != nil {
    config["not_after"] = *r.Not_after
}
if r.Serial != nil {
    config["serial"] = *r.Serial
}
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Certificate != nil {
    config["certificate"] = *r.Certificate
}
if r.Certificate_chain != nil {
    config["certificate_chain"] = *r.Certificate_chain
}
if r.Certificate_signing_request != nil {
    config["certificate_signing_request"] = *r.Certificate_signing_request
}
if r.Not_before != nil {
    config["not_before"] = *r.Not_before
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_acmpca_certificate_authorityUnmapper(state map[string]interface{}) *Aws_acmpca_certificate_authority {
	r := &Aws_acmpca_certificate_authority{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_acmpca_certificate_authority_id = &x
}

if x, ok := state["certificate_chain"]; ok {
	x := x.(string)
	r.Certificate_chain = &x
}

if x, ok := state["certificate_signing_request"]; ok {
	x := x.(string)
	r.Certificate_signing_request = &x
}

if x, ok := state["not_before"]; ok {
	x := x.(string)
	r.Not_before = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["certificate"]; ok {
	x := x.(string)
	r.Certificate = &x
}

if x, ok := state["not_after"]; ok {
	x := x.(string)
	r.Not_after = &x
}

if x, ok := state["serial"]; ok {
	x := x.(string)
	r.Serial = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}
	return r
}


// Aws_acmpca_certificate_authorityHandler ...
type Aws_acmpca_certificate_authorityHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_acmpca_certificate_authorityHandler) Create(desired *Aws_acmpca_certificate_authority) (*Aws_acmpca_certificate_authority, string, error) {
	rState := Aws_acmpca_certificate_authorityMapper(desired)
	id, err := bridge.Create(h.provider, "aws_acmpca_certificate_authority", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_acmpca_certificate_authorityHandler) Read(externalID string) (*Aws_acmpca_certificate_authority, error) {
	actual, err := bridge.Read(h.provider, "aws_acmpca_certificate_authority", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_acmpca_certificate_authorityUnmapper(actual), nil
}

// Delete ...
func (h *Aws_acmpca_certificate_authorityHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_acmpca_certificate_authority", externalID)
}

type Aws_lambda_alias struct {
     Aws_lambda_alias_id *string
     Arn *string
     Invoke_arn *string
     Description *string
     Function_name string
     Function_version string
     Name string
}


func Aws_lambda_aliasMapper(r *Aws_lambda_alias) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
    config["function_name"] = r.Function_name
    config["function_version"] = r.Function_version
    config["name"] = r.Name
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Invoke_arn != nil {
    config["invoke_arn"] = *r.Invoke_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lambda_aliasUnmapper(state map[string]interface{}) *Aws_lambda_alias {
	r := &Aws_lambda_alias{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lambda_alias_id = &x
}

if x, ok := state["invoke_arn"]; ok {
	x := x.(string)
	r.Invoke_arn = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["function_name"]; ok {
	r.Function_name = x.(string)
}

if x, ok := state["function_version"]; ok {
	r.Function_version = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}
	return r
}


// Aws_lambda_aliasHandler ...
type Aws_lambda_aliasHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lambda_aliasHandler) Create(desired *Aws_lambda_alias) (*Aws_lambda_alias, string, error) {
	rState := Aws_lambda_aliasMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lambda_alias", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lambda_aliasHandler) Read(externalID string) (*Aws_lambda_alias, error) {
	actual, err := bridge.Read(h.provider, "aws_lambda_alias", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lambda_aliasUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lambda_aliasHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lambda_alias", externalID)
}

type Aws_vpc_endpoint_route_table_association struct {
     Aws_vpc_endpoint_route_table_association_id *string
     Vpc_endpoint_id string
     Route_table_id string
}


func Aws_vpc_endpoint_route_table_associationMapper(r *Aws_vpc_endpoint_route_table_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["vpc_endpoint_id"] = r.Vpc_endpoint_id
    config["route_table_id"] = r.Route_table_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_vpc_endpoint_route_table_associationUnmapper(state map[string]interface{}) *Aws_vpc_endpoint_route_table_association {
	r := &Aws_vpc_endpoint_route_table_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_vpc_endpoint_route_table_association_id = &x
}

if x, ok := state["vpc_endpoint_id"]; ok {
	r.Vpc_endpoint_id = x.(string)
}

if x, ok := state["route_table_id"]; ok {
	r.Route_table_id = x.(string)
}
	return r
}


// Aws_vpc_endpoint_route_table_associationHandler ...
type Aws_vpc_endpoint_route_table_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_vpc_endpoint_route_table_associationHandler) Create(desired *Aws_vpc_endpoint_route_table_association) (*Aws_vpc_endpoint_route_table_association, string, error) {
	rState := Aws_vpc_endpoint_route_table_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_vpc_endpoint_route_table_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_vpc_endpoint_route_table_associationHandler) Read(externalID string) (*Aws_vpc_endpoint_route_table_association, error) {
	actual, err := bridge.Read(h.provider, "aws_vpc_endpoint_route_table_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_vpc_endpoint_route_table_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_vpc_endpoint_route_table_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_vpc_endpoint_route_table_association", externalID)
}

type Aws_appautoscaling_policy struct {
     Aws_appautoscaling_policy_id *string
     Scalable_dimension string
     Service_namespace string
     Arn *string
     Adjustment_type *string
     Policy_type *string
     Resource_id string
     Name string
     Metric_aggregation_type *string
}


func Aws_appautoscaling_policyMapper(r *Aws_appautoscaling_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Metric_aggregation_type != nil {
    config["metric_aggregation_type"] = *r.Metric_aggregation_type
}
    config["scalable_dimension"] = r.Scalable_dimension
    config["service_namespace"] = r.Service_namespace
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Adjustment_type != nil {
    config["adjustment_type"] = *r.Adjustment_type
}
if r.Policy_type != nil {
    config["policy_type"] = *r.Policy_type
}
    config["resource_id"] = r.Resource_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appautoscaling_policyUnmapper(state map[string]interface{}) *Aws_appautoscaling_policy {
	r := &Aws_appautoscaling_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appautoscaling_policy_id = &x
}

if x, ok := state["scalable_dimension"]; ok {
	r.Scalable_dimension = x.(string)
}

if x, ok := state["service_namespace"]; ok {
	r.Service_namespace = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["adjustment_type"]; ok {
	x := x.(string)
	r.Adjustment_type = &x
}

if x, ok := state["policy_type"]; ok {
	x := x.(string)
	r.Policy_type = &x
}

if x, ok := state["resource_id"]; ok {
	r.Resource_id = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["metric_aggregation_type"]; ok {
	x := x.(string)
	r.Metric_aggregation_type = &x
}
	return r
}


// Aws_appautoscaling_policyHandler ...
type Aws_appautoscaling_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appautoscaling_policyHandler) Create(desired *Aws_appautoscaling_policy) (*Aws_appautoscaling_policy, string, error) {
	rState := Aws_appautoscaling_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appautoscaling_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appautoscaling_policyHandler) Read(externalID string) (*Aws_appautoscaling_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_appautoscaling_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appautoscaling_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appautoscaling_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appautoscaling_policy", externalID)
}

type Aws_organizations_policy_attachment struct {
     Aws_organizations_policy_attachment_id *string
     Policy_id string
     Target_id string
}


func Aws_organizations_policy_attachmentMapper(r *Aws_organizations_policy_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["policy_id"] = r.Policy_id
    config["target_id"] = r.Target_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_organizations_policy_attachmentUnmapper(state map[string]interface{}) *Aws_organizations_policy_attachment {
	r := &Aws_organizations_policy_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_organizations_policy_attachment_id = &x
}

if x, ok := state["target_id"]; ok {
	r.Target_id = x.(string)
}

if x, ok := state["policy_id"]; ok {
	r.Policy_id = x.(string)
}
	return r
}


// Aws_organizations_policy_attachmentHandler ...
type Aws_organizations_policy_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_organizations_policy_attachmentHandler) Create(desired *Aws_organizations_policy_attachment) (*Aws_organizations_policy_attachment, string, error) {
	rState := Aws_organizations_policy_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_organizations_policy_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_organizations_policy_attachmentHandler) Read(externalID string) (*Aws_organizations_policy_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_organizations_policy_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_organizations_policy_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_organizations_policy_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_organizations_policy_attachment", externalID)
}

type Aws_appmesh_route struct {
     Aws_appmesh_route_id *string
     Created_date *string
     Last_updated_date *string
     Name string
     Mesh_name string
     Virtual_router_name string
     Arn *string
}


func Aws_appmesh_routeMapper(r *Aws_appmesh_route) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Created_date != nil {
    config["created_date"] = *r.Created_date
}
if r.Last_updated_date != nil {
    config["last_updated_date"] = *r.Last_updated_date
}
    config["name"] = r.Name
    config["mesh_name"] = r.Mesh_name
    config["virtual_router_name"] = r.Virtual_router_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appmesh_routeUnmapper(state map[string]interface{}) *Aws_appmesh_route {
	r := &Aws_appmesh_route{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appmesh_route_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["created_date"]; ok {
	x := x.(string)
	r.Created_date = &x
}

if x, ok := state["last_updated_date"]; ok {
	x := x.(string)
	r.Last_updated_date = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["mesh_name"]; ok {
	r.Mesh_name = x.(string)
}

if x, ok := state["virtual_router_name"]; ok {
	r.Virtual_router_name = x.(string)
}
	return r
}


// Aws_appmesh_routeHandler ...
type Aws_appmesh_routeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appmesh_routeHandler) Create(desired *Aws_appmesh_route) (*Aws_appmesh_route, string, error) {
	rState := Aws_appmesh_routeMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appmesh_route", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appmesh_routeHandler) Read(externalID string) (*Aws_appmesh_route, error) {
	actual, err := bridge.Read(h.provider, "aws_appmesh_route", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appmesh_routeUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appmesh_routeHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appmesh_route", externalID)
}

type Aws_kinesis_analytics_application struct {
     Aws_kinesis_analytics_application_id *string
     Arn *string
     Create_timestamp *string
     Last_update_timestamp *string
     Status *string
     Name string
     Code *string
     Description *string
}


func Aws_kinesis_analytics_applicationMapper(r *Aws_kinesis_analytics_application) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Code != nil {
    config["code"] = *r.Code
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Create_timestamp != nil {
    config["create_timestamp"] = *r.Create_timestamp
}
if r.Last_update_timestamp != nil {
    config["last_update_timestamp"] = *r.Last_update_timestamp
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_kinesis_analytics_applicationUnmapper(state map[string]interface{}) *Aws_kinesis_analytics_application {
	r := &Aws_kinesis_analytics_application{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_kinesis_analytics_application_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["code"]; ok {
	x := x.(string)
	r.Code = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["create_timestamp"]; ok {
	x := x.(string)
	r.Create_timestamp = &x
}

if x, ok := state["last_update_timestamp"]; ok {
	x := x.(string)
	r.Last_update_timestamp = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}
	return r
}


// Aws_kinesis_analytics_applicationHandler ...
type Aws_kinesis_analytics_applicationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_kinesis_analytics_applicationHandler) Create(desired *Aws_kinesis_analytics_application) (*Aws_kinesis_analytics_application, string, error) {
	rState := Aws_kinesis_analytics_applicationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_kinesis_analytics_application", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_kinesis_analytics_applicationHandler) Read(externalID string) (*Aws_kinesis_analytics_application, error) {
	actual, err := bridge.Read(h.provider, "aws_kinesis_analytics_application", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_kinesis_analytics_applicationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_kinesis_analytics_applicationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_kinesis_analytics_application", externalID)
}

type Aws_kinesis_stream struct {
     Aws_kinesis_stream_id *string
     Kms_key_id *string
     Arn *string
     Tags *map[string]string
     Name string
     Encryption_type *string
}


func Aws_kinesis_streamMapper(r *Aws_kinesis_stream) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Encryption_type != nil {
    config["encryption_type"] = *r.Encryption_type
}
if r.Kms_key_id != nil {
    config["kms_key_id"] = *r.Kms_key_id
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_kinesis_streamUnmapper(state map[string]interface{}) *Aws_kinesis_stream {
	r := &Aws_kinesis_stream{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_kinesis_stream_id = &x
}

if x, ok := state["encryption_type"]; ok {
	x := x.(string)
	r.Encryption_type = &x
}

if x, ok := state["kms_key_id"]; ok {
	x := x.(string)
	r.Kms_key_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_kinesis_streamHandler ...
type Aws_kinesis_streamHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_kinesis_streamHandler) Create(desired *Aws_kinesis_stream) (*Aws_kinesis_stream, string, error) {
	rState := Aws_kinesis_streamMapper(desired)
	id, err := bridge.Create(h.provider, "aws_kinesis_stream", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_kinesis_streamHandler) Read(externalID string) (*Aws_kinesis_stream, error) {
	actual, err := bridge.Read(h.provider, "aws_kinesis_stream", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_kinesis_streamUnmapper(actual), nil
}

// Delete ...
func (h *Aws_kinesis_streamHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_kinesis_stream", externalID)
}

type Aws_config_configuration_recorder struct {
     Aws_config_configuration_recorder_id *string
     Name *string
     Role_arn string
}


func Aws_config_configuration_recorderMapper(r *Aws_config_configuration_recorder) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Name != nil {
    config["name"] = *r.Name
}
    config["role_arn"] = r.Role_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_config_configuration_recorderUnmapper(state map[string]interface{}) *Aws_config_configuration_recorder {
	r := &Aws_config_configuration_recorder{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_config_configuration_recorder_id = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}
	return r
}


// Aws_config_configuration_recorderHandler ...
type Aws_config_configuration_recorderHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_config_configuration_recorderHandler) Create(desired *Aws_config_configuration_recorder) (*Aws_config_configuration_recorder, string, error) {
	rState := Aws_config_configuration_recorderMapper(desired)
	id, err := bridge.Create(h.provider, "aws_config_configuration_recorder", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_config_configuration_recorderHandler) Read(externalID string) (*Aws_config_configuration_recorder, error) {
	actual, err := bridge.Read(h.provider, "aws_config_configuration_recorder", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_config_configuration_recorderUnmapper(actual), nil
}

// Delete ...
func (h *Aws_config_configuration_recorderHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_config_configuration_recorder", externalID)
}

type Aws_directory_service_directory struct {
     Aws_directory_service_directory_id *string
     Alias *string
     Description *string
     Edition *string
     Password string
     Size *string
     Short_name *string
     Enable_sso *bool
     Security_group_id *string
     Name string
     Tags *map[string]string
     Access_url *string
     Resource_type *string
}


func Aws_directory_service_directoryMapper(r *Aws_directory_service_directory) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Description != nil {
    config["description"] = *r.Description
}
if r.Edition != nil {
    config["edition"] = *r.Edition
}
    config["password"] = r.Password
if r.Size != nil {
    config["size"] = *r.Size
}
if r.Short_name != nil {
    config["short_name"] = *r.Short_name
}
if r.Enable_sso != nil {
    config["enable_sso"] = *r.Enable_sso
}
if r.Security_group_id != nil {
    config["security_group_id"] = *r.Security_group_id
}
    config["name"] = r.Name
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Access_url != nil {
    config["access_url"] = *r.Access_url
}
if r.Resource_type != nil {
    config["resource_type"] = *r.Resource_type
}
if r.Alias != nil {
    config["alias"] = *r.Alias
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_directory_service_directoryUnmapper(state map[string]interface{}) *Aws_directory_service_directory {
	r := &Aws_directory_service_directory{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_directory_service_directory_id = &x
}

if x, ok := state["alias"]; ok {
	x := x.(string)
	r.Alias = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["edition"]; ok {
	x := x.(string)
	r.Edition = &x
}

if x, ok := state["password"]; ok {
	r.Password = x.(string)
}

if x, ok := state["size"]; ok {
	x := x.(string)
	r.Size = &x
}

if x, ok := state["short_name"]; ok {
	x := x.(string)
	r.Short_name = &x
}

if x, ok := state["enable_sso"]; ok {
	x := x.(bool)
	r.Enable_sso = &x
}

if x, ok := state["security_group_id"]; ok {
	x := x.(string)
	r.Security_group_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["access_url"]; ok {
	x := x.(string)
	r.Access_url = &x
}

if x, ok := state["resource_type"]; ok {
	x := x.(string)
	r.Resource_type = &x
}
	return r
}


// Aws_directory_service_directoryHandler ...
type Aws_directory_service_directoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_directory_service_directoryHandler) Create(desired *Aws_directory_service_directory) (*Aws_directory_service_directory, string, error) {
	rState := Aws_directory_service_directoryMapper(desired)
	id, err := bridge.Create(h.provider, "aws_directory_service_directory", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_directory_service_directoryHandler) Read(externalID string) (*Aws_directory_service_directory, error) {
	actual, err := bridge.Read(h.provider, "aws_directory_service_directory", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_directory_service_directoryUnmapper(actual), nil
}

// Delete ...
func (h *Aws_directory_service_directoryHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_directory_service_directory", externalID)
}

type Aws_media_package_channel struct {
     Aws_media_package_channel_id *string
     Arn *string
     Channel_id string
     Description *string
}


func Aws_media_package_channelMapper(r *Aws_media_package_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
    config["channel_id"] = r.Channel_id
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_media_package_channelUnmapper(state map[string]interface{}) *Aws_media_package_channel {
	r := &Aws_media_package_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_media_package_channel_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["channel_id"]; ok {
	r.Channel_id = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_media_package_channelHandler ...
type Aws_media_package_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_media_package_channelHandler) Create(desired *Aws_media_package_channel) (*Aws_media_package_channel, string, error) {
	rState := Aws_media_package_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_media_package_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_media_package_channelHandler) Read(externalID string) (*Aws_media_package_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_media_package_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_media_package_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_media_package_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_media_package_channel", externalID)
}

type Aws_ses_active_receipt_rule_set struct {
     Aws_ses_active_receipt_rule_set_id *string
     Rule_set_name string
}


func Aws_ses_active_receipt_rule_setMapper(r *Aws_ses_active_receipt_rule_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["rule_set_name"] = r.Rule_set_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ses_active_receipt_rule_setUnmapper(state map[string]interface{}) *Aws_ses_active_receipt_rule_set {
	r := &Aws_ses_active_receipt_rule_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ses_active_receipt_rule_set_id = &x
}

if x, ok := state["rule_set_name"]; ok {
	r.Rule_set_name = x.(string)
}
	return r
}


// Aws_ses_active_receipt_rule_setHandler ...
type Aws_ses_active_receipt_rule_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ses_active_receipt_rule_setHandler) Create(desired *Aws_ses_active_receipt_rule_set) (*Aws_ses_active_receipt_rule_set, string, error) {
	rState := Aws_ses_active_receipt_rule_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ses_active_receipt_rule_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ses_active_receipt_rule_setHandler) Read(externalID string) (*Aws_ses_active_receipt_rule_set, error) {
	actual, err := bridge.Read(h.provider, "aws_ses_active_receipt_rule_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ses_active_receipt_rule_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ses_active_receipt_rule_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ses_active_receipt_rule_set", externalID)
}

type Aws_dax_cluster struct {
     Aws_dax_cluster_id *string
     Arn *string
     Description *string
     Cluster_address *string
     Node_type string
     Notification_topic_arn *string
     Configuration_endpoint *string
     Parameter_group_name *string
     Maintenance_window *string
     Cluster_name string
     Iam_role_arn string
     Subnet_group_name *string
     Tags *map[string]string
}


func Aws_dax_clusterMapper(r *Aws_dax_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Cluster_address != nil {
    config["cluster_address"] = *r.Cluster_address
}
    config["node_type"] = r.Node_type
if r.Notification_topic_arn != nil {
    config["notification_topic_arn"] = *r.Notification_topic_arn
}
if r.Configuration_endpoint != nil {
    config["configuration_endpoint"] = *r.Configuration_endpoint
}
if r.Parameter_group_name != nil {
    config["parameter_group_name"] = *r.Parameter_group_name
}
if r.Maintenance_window != nil {
    config["maintenance_window"] = *r.Maintenance_window
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["cluster_name"] = r.Cluster_name
    config["iam_role_arn"] = r.Iam_role_arn
if r.Subnet_group_name != nil {
    config["subnet_group_name"] = *r.Subnet_group_name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dax_clusterUnmapper(state map[string]interface{}) *Aws_dax_cluster {
	r := &Aws_dax_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dax_cluster_id = &x
}

if x, ok := state["parameter_group_name"]; ok {
	x := x.(string)
	r.Parameter_group_name = &x
}

if x, ok := state["maintenance_window"]; ok {
	x := x.(string)
	r.Maintenance_window = &x
}

if x, ok := state["cluster_name"]; ok {
	r.Cluster_name = x.(string)
}

if x, ok := state["iam_role_arn"]; ok {
	r.Iam_role_arn = x.(string)
}

if x, ok := state["subnet_group_name"]; ok {
	x := x.(string)
	r.Subnet_group_name = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["cluster_address"]; ok {
	x := x.(string)
	r.Cluster_address = &x
}

if x, ok := state["node_type"]; ok {
	r.Node_type = x.(string)
}

if x, ok := state["notification_topic_arn"]; ok {
	x := x.(string)
	r.Notification_topic_arn = &x
}

if x, ok := state["configuration_endpoint"]; ok {
	x := x.(string)
	r.Configuration_endpoint = &x
}
	return r
}


// Aws_dax_clusterHandler ...
type Aws_dax_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dax_clusterHandler) Create(desired *Aws_dax_cluster) (*Aws_dax_cluster, string, error) {
	rState := Aws_dax_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dax_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dax_clusterHandler) Read(externalID string) (*Aws_dax_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_dax_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dax_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dax_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dax_cluster", externalID)
}

type Aws_elasticache_cluster struct {
     Aws_elasticache_cluster_id *string
     Subnet_group_name *string
     Availability_zone *string
     Cluster_address *string
     Snapshot_name *string
     Cluster_id string
     Configuration_endpoint *string
     Engine_version *string
     Parameter_group_name *string
     Notification_topic_arn *string
     Tags *map[string]string
     Apply_immediately *bool
     Az_mode *string
     Engine *string
     Maintenance_window *string
     Node_type *string
     Replication_group_id *string
     Snapshot_window *string
}


func Aws_elasticache_clusterMapper(r *Aws_elasticache_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Snapshot_name != nil {
    config["snapshot_name"] = *r.Snapshot_name
}
if r.Subnet_group_name != nil {
    config["subnet_group_name"] = *r.Subnet_group_name
}
if r.Availability_zone != nil {
    config["availability_zone"] = *r.Availability_zone
}
if r.Cluster_address != nil {
    config["cluster_address"] = *r.Cluster_address
}
if r.Parameter_group_name != nil {
    config["parameter_group_name"] = *r.Parameter_group_name
}
    config["cluster_id"] = r.Cluster_id
if r.Configuration_endpoint != nil {
    config["configuration_endpoint"] = *r.Configuration_endpoint
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Notification_topic_arn != nil {
    config["notification_topic_arn"] = *r.Notification_topic_arn
}
if r.Node_type != nil {
    config["node_type"] = *r.Node_type
}
if r.Replication_group_id != nil {
    config["replication_group_id"] = *r.Replication_group_id
}
if r.Snapshot_window != nil {
    config["snapshot_window"] = *r.Snapshot_window
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Apply_immediately != nil {
    config["apply_immediately"] = *r.Apply_immediately
}
if r.Az_mode != nil {
    config["az_mode"] = *r.Az_mode
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Maintenance_window != nil {
    config["maintenance_window"] = *r.Maintenance_window
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elasticache_clusterUnmapper(state map[string]interface{}) *Aws_elasticache_cluster {
	r := &Aws_elasticache_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elasticache_cluster_id = &x
}

if x, ok := state["snapshot_name"]; ok {
	x := x.(string)
	r.Snapshot_name = &x
}

if x, ok := state["subnet_group_name"]; ok {
	x := x.(string)
	r.Subnet_group_name = &x
}

if x, ok := state["availability_zone"]; ok {
	x := x.(string)
	r.Availability_zone = &x
}

if x, ok := state["cluster_address"]; ok {
	x := x.(string)
	r.Cluster_address = &x
}

if x, ok := state["parameter_group_name"]; ok {
	x := x.(string)
	r.Parameter_group_name = &x
}

if x, ok := state["cluster_id"]; ok {
	r.Cluster_id = x.(string)
}

if x, ok := state["configuration_endpoint"]; ok {
	x := x.(string)
	r.Configuration_endpoint = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["notification_topic_arn"]; ok {
	x := x.(string)
	r.Notification_topic_arn = &x
}

if x, ok := state["node_type"]; ok {
	x := x.(string)
	r.Node_type = &x
}

if x, ok := state["replication_group_id"]; ok {
	x := x.(string)
	r.Replication_group_id = &x
}

if x, ok := state["snapshot_window"]; ok {
	x := x.(string)
	r.Snapshot_window = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["apply_immediately"]; ok {
	x := x.(bool)
	r.Apply_immediately = &x
}

if x, ok := state["az_mode"]; ok {
	x := x.(string)
	r.Az_mode = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["maintenance_window"]; ok {
	x := x.(string)
	r.Maintenance_window = &x
}
	return r
}


// Aws_elasticache_clusterHandler ...
type Aws_elasticache_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elasticache_clusterHandler) Create(desired *Aws_elasticache_cluster) (*Aws_elasticache_cluster, string, error) {
	rState := Aws_elasticache_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elasticache_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elasticache_clusterHandler) Read(externalID string) (*Aws_elasticache_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_elasticache_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elasticache_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elasticache_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elasticache_cluster", externalID)
}

type Aws_autoscaling_policy struct {
     Aws_autoscaling_policy_id *string
     Metric_aggregation_type *string
     Name string
     Adjustment_type *string
     Autoscaling_group_name string
     Arn *string
     Policy_type *string
}


func Aws_autoscaling_policyMapper(r *Aws_autoscaling_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Adjustment_type != nil {
    config["adjustment_type"] = *r.Adjustment_type
}
    config["autoscaling_group_name"] = r.Autoscaling_group_name
if r.Metric_aggregation_type != nil {
    config["metric_aggregation_type"] = *r.Metric_aggregation_type
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Policy_type != nil {
    config["policy_type"] = *r.Policy_type
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_autoscaling_policyUnmapper(state map[string]interface{}) *Aws_autoscaling_policy {
	r := &Aws_autoscaling_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_autoscaling_policy_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["adjustment_type"]; ok {
	x := x.(string)
	r.Adjustment_type = &x
}

if x, ok := state["autoscaling_group_name"]; ok {
	r.Autoscaling_group_name = x.(string)
}

if x, ok := state["metric_aggregation_type"]; ok {
	x := x.(string)
	r.Metric_aggregation_type = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["policy_type"]; ok {
	x := x.(string)
	r.Policy_type = &x
}
	return r
}


// Aws_autoscaling_policyHandler ...
type Aws_autoscaling_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_autoscaling_policyHandler) Create(desired *Aws_autoscaling_policy) (*Aws_autoscaling_policy, string, error) {
	rState := Aws_autoscaling_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_autoscaling_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_autoscaling_policyHandler) Read(externalID string) (*Aws_autoscaling_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_autoscaling_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_autoscaling_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_autoscaling_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_autoscaling_policy", externalID)
}

type Aws_ecs_service struct {
     Aws_ecs_service_id *string
     Platform_version *string
     Scheduling_strategy *string
     Iam_role *string
     Task_definition string
     Launch_type *string
     Cluster *string
     Enable_ecs_managed_tags *bool
     Tags *map[string]string
     Name string
     Propagate_tags *string
}


func Aws_ecs_serviceMapper(r *Aws_ecs_service) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Propagate_tags != nil {
    config["propagate_tags"] = *r.Propagate_tags
}
    config["task_definition"] = r.Task_definition
if r.Platform_version != nil {
    config["platform_version"] = *r.Platform_version
}
if r.Scheduling_strategy != nil {
    config["scheduling_strategy"] = *r.Scheduling_strategy
}
if r.Iam_role != nil {
    config["iam_role"] = *r.Iam_role
}
if r.Cluster != nil {
    config["cluster"] = *r.Cluster
}
if r.Enable_ecs_managed_tags != nil {
    config["enable_ecs_managed_tags"] = *r.Enable_ecs_managed_tags
}
if r.Launch_type != nil {
    config["launch_type"] = *r.Launch_type
}
    config["name"] = r.Name
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ecs_serviceUnmapper(state map[string]interface{}) *Aws_ecs_service {
	r := &Aws_ecs_service{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ecs_service_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["propagate_tags"]; ok {
	x := x.(string)
	r.Propagate_tags = &x
}

if x, ok := state["scheduling_strategy"]; ok {
	x := x.(string)
	r.Scheduling_strategy = &x
}

if x, ok := state["iam_role"]; ok {
	x := x.(string)
	r.Iam_role = &x
}

if x, ok := state["task_definition"]; ok {
	r.Task_definition = x.(string)
}

if x, ok := state["platform_version"]; ok {
	x := x.(string)
	r.Platform_version = &x
}

if x, ok := state["cluster"]; ok {
	x := x.(string)
	r.Cluster = &x
}

if x, ok := state["enable_ecs_managed_tags"]; ok {
	x := x.(bool)
	r.Enable_ecs_managed_tags = &x
}

if x, ok := state["launch_type"]; ok {
	x := x.(string)
	r.Launch_type = &x
}
	return r
}


// Aws_ecs_serviceHandler ...
type Aws_ecs_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ecs_serviceHandler) Create(desired *Aws_ecs_service) (*Aws_ecs_service, string, error) {
	rState := Aws_ecs_serviceMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ecs_service", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ecs_serviceHandler) Read(externalID string) (*Aws_ecs_service, error) {
	actual, err := bridge.Read(h.provider, "aws_ecs_service", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ecs_serviceUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ecs_serviceHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ecs_service", externalID)
}

type Aws_elb_attachment struct {
     Aws_elb_attachment_id *string
     Elb string
     Instance string
}


func Aws_elb_attachmentMapper(r *Aws_elb_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["elb"] = r.Elb
    config["instance"] = r.Instance
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_elb_attachmentUnmapper(state map[string]interface{}) *Aws_elb_attachment {
	r := &Aws_elb_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_elb_attachment_id = &x
}

if x, ok := state["elb"]; ok {
	r.Elb = x.(string)
}

if x, ok := state["instance"]; ok {
	r.Instance = x.(string)
}
	return r
}


// Aws_elb_attachmentHandler ...
type Aws_elb_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_elb_attachmentHandler) Create(desired *Aws_elb_attachment) (*Aws_elb_attachment, string, error) {
	rState := Aws_elb_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_elb_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_elb_attachmentHandler) Read(externalID string) (*Aws_elb_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_elb_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_elb_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_elb_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_elb_attachment", externalID)
}

type Aws_redshift_parameter_group struct {
     Aws_redshift_parameter_group_id *string
     Family string
     Description *string
     Name string
}


func Aws_redshift_parameter_groupMapper(r *Aws_redshift_parameter_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["family"] = r.Family
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_redshift_parameter_groupUnmapper(state map[string]interface{}) *Aws_redshift_parameter_group {
	r := &Aws_redshift_parameter_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_redshift_parameter_group_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["family"]; ok {
	r.Family = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}
	return r
}


// Aws_redshift_parameter_groupHandler ...
type Aws_redshift_parameter_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_redshift_parameter_groupHandler) Create(desired *Aws_redshift_parameter_group) (*Aws_redshift_parameter_group, string, error) {
	rState := Aws_redshift_parameter_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_redshift_parameter_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_redshift_parameter_groupHandler) Read(externalID string) (*Aws_redshift_parameter_group, error) {
	actual, err := bridge.Read(h.provider, "aws_redshift_parameter_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_redshift_parameter_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_redshift_parameter_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_redshift_parameter_group", externalID)
}

type Aws_storagegateway_smb_file_share struct {
     Aws_storagegateway_smb_file_share_id *string
     Default_storage_class *string
     Guess_mime_type_enabled *bool
     Fileshare_id *string
     Gateway_arn string
     Location_arn string
     Kms_key_arn *string
     Read_only *bool
     Requester_pays *bool
     Role_arn string
     Arn *string
     Authentication *string
     Kms_encrypted *bool
     Object_acl *string
}


func Aws_storagegateway_smb_file_shareMapper(r *Aws_storagegateway_smb_file_share) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Fileshare_id != nil {
    config["fileshare_id"] = *r.Fileshare_id
}
    config["gateway_arn"] = r.Gateway_arn
    config["location_arn"] = r.Location_arn
    config["role_arn"] = r.Role_arn
if r.Kms_key_arn != nil {
    config["kms_key_arn"] = *r.Kms_key_arn
}
if r.Read_only != nil {
    config["read_only"] = *r.Read_only
}
if r.Requester_pays != nil {
    config["requester_pays"] = *r.Requester_pays
}
if r.Object_acl != nil {
    config["object_acl"] = *r.Object_acl
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Authentication != nil {
    config["authentication"] = *r.Authentication
}
if r.Kms_encrypted != nil {
    config["kms_encrypted"] = *r.Kms_encrypted
}
if r.Default_storage_class != nil {
    config["default_storage_class"] = *r.Default_storage_class
}
if r.Guess_mime_type_enabled != nil {
    config["guess_mime_type_enabled"] = *r.Guess_mime_type_enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_storagegateway_smb_file_shareUnmapper(state map[string]interface{}) *Aws_storagegateway_smb_file_share {
	r := &Aws_storagegateway_smb_file_share{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_storagegateway_smb_file_share_id = &x
}

if x, ok := state["fileshare_id"]; ok {
	x := x.(string)
	r.Fileshare_id = &x
}

if x, ok := state["gateway_arn"]; ok {
	r.Gateway_arn = x.(string)
}

if x, ok := state["location_arn"]; ok {
	r.Location_arn = x.(string)
}

if x, ok := state["kms_key_arn"]; ok {
	x := x.(string)
	r.Kms_key_arn = &x
}

if x, ok := state["read_only"]; ok {
	x := x.(bool)
	r.Read_only = &x
}

if x, ok := state["requester_pays"]; ok {
	x := x.(bool)
	r.Requester_pays = &x
}

if x, ok := state["role_arn"]; ok {
	r.Role_arn = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["authentication"]; ok {
	x := x.(string)
	r.Authentication = &x
}

if x, ok := state["kms_encrypted"]; ok {
	x := x.(bool)
	r.Kms_encrypted = &x
}

if x, ok := state["object_acl"]; ok {
	x := x.(string)
	r.Object_acl = &x
}

if x, ok := state["default_storage_class"]; ok {
	x := x.(string)
	r.Default_storage_class = &x
}

if x, ok := state["guess_mime_type_enabled"]; ok {
	x := x.(bool)
	r.Guess_mime_type_enabled = &x
}
	return r
}


// Aws_storagegateway_smb_file_shareHandler ...
type Aws_storagegateway_smb_file_shareHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_storagegateway_smb_file_shareHandler) Create(desired *Aws_storagegateway_smb_file_share) (*Aws_storagegateway_smb_file_share, string, error) {
	rState := Aws_storagegateway_smb_file_shareMapper(desired)
	id, err := bridge.Create(h.provider, "aws_storagegateway_smb_file_share", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_storagegateway_smb_file_shareHandler) Read(externalID string) (*Aws_storagegateway_smb_file_share, error) {
	actual, err := bridge.Read(h.provider, "aws_storagegateway_smb_file_share", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_storagegateway_smb_file_shareUnmapper(actual), nil
}

// Delete ...
func (h *Aws_storagegateway_smb_file_shareHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_storagegateway_smb_file_share", externalID)
}

type Aws_appsync_graphql_api struct {
     Aws_appsync_graphql_api_id *string
     Name string
     Arn *string
     Uris *map[string]string
     Authentication_type string
}


func Aws_appsync_graphql_apiMapper(r *Aws_appsync_graphql_api) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Uris != nil {
    config["uris"] = *r.Uris
}
    config["authentication_type"] = r.Authentication_type
    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_appsync_graphql_apiUnmapper(state map[string]interface{}) *Aws_appsync_graphql_api {
	r := &Aws_appsync_graphql_api{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_appsync_graphql_api_id = &x
}

if x, ok := state["authentication_type"]; ok {
	r.Authentication_type = x.(string)
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["uris"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Uris = &x
}
	return r
}


// Aws_appsync_graphql_apiHandler ...
type Aws_appsync_graphql_apiHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_appsync_graphql_apiHandler) Create(desired *Aws_appsync_graphql_api) (*Aws_appsync_graphql_api, string, error) {
	rState := Aws_appsync_graphql_apiMapper(desired)
	id, err := bridge.Create(h.provider, "aws_appsync_graphql_api", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_appsync_graphql_apiHandler) Read(externalID string) (*Aws_appsync_graphql_api, error) {
	actual, err := bridge.Read(h.provider, "aws_appsync_graphql_api", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_appsync_graphql_apiUnmapper(actual), nil
}

// Delete ...
func (h *Aws_appsync_graphql_apiHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_appsync_graphql_api", externalID)
}

type Aws_autoscaling_attachment struct {
     Aws_autoscaling_attachment_id *string
     Elb *string
     Alb_target_group_arn *string
     Autoscaling_group_name string
}


func Aws_autoscaling_attachmentMapper(r *Aws_autoscaling_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["autoscaling_group_name"] = r.Autoscaling_group_name
if r.Elb != nil {
    config["elb"] = *r.Elb
}
if r.Alb_target_group_arn != nil {
    config["alb_target_group_arn"] = *r.Alb_target_group_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_autoscaling_attachmentUnmapper(state map[string]interface{}) *Aws_autoscaling_attachment {
	r := &Aws_autoscaling_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_autoscaling_attachment_id = &x
}

if x, ok := state["autoscaling_group_name"]; ok {
	r.Autoscaling_group_name = x.(string)
}

if x, ok := state["elb"]; ok {
	x := x.(string)
	r.Elb = &x
}

if x, ok := state["alb_target_group_arn"]; ok {
	x := x.(string)
	r.Alb_target_group_arn = &x
}
	return r
}


// Aws_autoscaling_attachmentHandler ...
type Aws_autoscaling_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_autoscaling_attachmentHandler) Create(desired *Aws_autoscaling_attachment) (*Aws_autoscaling_attachment, string, error) {
	rState := Aws_autoscaling_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_autoscaling_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_autoscaling_attachmentHandler) Read(externalID string) (*Aws_autoscaling_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_autoscaling_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_autoscaling_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_autoscaling_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_autoscaling_attachment", externalID)
}

type Aws_codedeploy_deployment_group struct {
     Aws_codedeploy_deployment_group_id *string
     Deployment_group_name string
     Service_role_arn string
     Deployment_config_name *string
     App_name string
}


func Aws_codedeploy_deployment_groupMapper(r *Aws_codedeploy_deployment_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["deployment_group_name"] = r.Deployment_group_name
    config["service_role_arn"] = r.Service_role_arn
if r.Deployment_config_name != nil {
    config["deployment_config_name"] = *r.Deployment_config_name
}
    config["app_name"] = r.App_name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_codedeploy_deployment_groupUnmapper(state map[string]interface{}) *Aws_codedeploy_deployment_group {
	r := &Aws_codedeploy_deployment_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_codedeploy_deployment_group_id = &x
}

if x, ok := state["deployment_config_name"]; ok {
	x := x.(string)
	r.Deployment_config_name = &x
}

if x, ok := state["app_name"]; ok {
	r.App_name = x.(string)
}

if x, ok := state["deployment_group_name"]; ok {
	r.Deployment_group_name = x.(string)
}

if x, ok := state["service_role_arn"]; ok {
	r.Service_role_arn = x.(string)
}
	return r
}


// Aws_codedeploy_deployment_groupHandler ...
type Aws_codedeploy_deployment_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_codedeploy_deployment_groupHandler) Create(desired *Aws_codedeploy_deployment_group) (*Aws_codedeploy_deployment_group, string, error) {
	rState := Aws_codedeploy_deployment_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_codedeploy_deployment_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_codedeploy_deployment_groupHandler) Read(externalID string) (*Aws_codedeploy_deployment_group, error) {
	actual, err := bridge.Read(h.provider, "aws_codedeploy_deployment_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_codedeploy_deployment_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_codedeploy_deployment_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_codedeploy_deployment_group", externalID)
}

type Aws_ecr_repository_policy struct {
     Aws_ecr_repository_policy_id *string
     Repository string
     Policy string
     Registry_id *string
}


func Aws_ecr_repository_policyMapper(r *Aws_ecr_repository_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["repository"] = r.Repository
    config["policy"] = r.Policy
if r.Registry_id != nil {
    config["registry_id"] = *r.Registry_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ecr_repository_policyUnmapper(state map[string]interface{}) *Aws_ecr_repository_policy {
	r := &Aws_ecr_repository_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ecr_repository_policy_id = &x
}

if x, ok := state["repository"]; ok {
	r.Repository = x.(string)
}

if x, ok := state["policy"]; ok {
	r.Policy = x.(string)
}

if x, ok := state["registry_id"]; ok {
	x := x.(string)
	r.Registry_id = &x
}
	return r
}


// Aws_ecr_repository_policyHandler ...
type Aws_ecr_repository_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ecr_repository_policyHandler) Create(desired *Aws_ecr_repository_policy) (*Aws_ecr_repository_policy, string, error) {
	rState := Aws_ecr_repository_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ecr_repository_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ecr_repository_policyHandler) Read(externalID string) (*Aws_ecr_repository_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_ecr_repository_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ecr_repository_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ecr_repository_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ecr_repository_policy", externalID)
}

type Aws_neptune_cluster struct {
     Aws_neptune_cluster_id *string
     Cluster_identifier *string
     Neptune_cluster_parameter_group_name *string
     Storage_encrypted *bool
     Cluster_identifier_prefix *string
     Endpoint *string
     Engine_version *string
     Tags *map[string]string
     Apply_immediately *bool
     Arn *string
     Engine *string
     Final_snapshot_identifier *string
     Snapshot_identifier *string
     Skip_final_snapshot *bool
     Preferred_backup_window *string
     Reader_endpoint *string
     Hosted_zone_id *string
     Replication_source_identifier *string
     Kms_key_arn *string
     Neptune_subnet_group_name *string
     Preferred_maintenance_window *string
     Cluster_resource_id *string
     Iam_database_authentication_enabled *bool
}


func Aws_neptune_clusterMapper(r *Aws_neptune_cluster) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Cluster_identifier != nil {
    config["cluster_identifier"] = *r.Cluster_identifier
}
if r.Neptune_cluster_parameter_group_name != nil {
    config["neptune_cluster_parameter_group_name"] = *r.Neptune_cluster_parameter_group_name
}
if r.Storage_encrypted != nil {
    config["storage_encrypted"] = *r.Storage_encrypted
}
if r.Cluster_identifier_prefix != nil {
    config["cluster_identifier_prefix"] = *r.Cluster_identifier_prefix
}
if r.Endpoint != nil {
    config["endpoint"] = *r.Endpoint
}
if r.Engine_version != nil {
    config["engine_version"] = *r.Engine_version
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Apply_immediately != nil {
    config["apply_immediately"] = *r.Apply_immediately
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Engine != nil {
    config["engine"] = *r.Engine
}
if r.Final_snapshot_identifier != nil {
    config["final_snapshot_identifier"] = *r.Final_snapshot_identifier
}
if r.Snapshot_identifier != nil {
    config["snapshot_identifier"] = *r.Snapshot_identifier
}
if r.Skip_final_snapshot != nil {
    config["skip_final_snapshot"] = *r.Skip_final_snapshot
}
if r.Preferred_backup_window != nil {
    config["preferred_backup_window"] = *r.Preferred_backup_window
}
if r.Reader_endpoint != nil {
    config["reader_endpoint"] = *r.Reader_endpoint
}
if r.Hosted_zone_id != nil {
    config["hosted_zone_id"] = *r.Hosted_zone_id
}
if r.Replication_source_identifier != nil {
    config["replication_source_identifier"] = *r.Replication_source_identifier
}
if r.Kms_key_arn != nil {
    config["kms_key_arn"] = *r.Kms_key_arn
}
if r.Neptune_subnet_group_name != nil {
    config["neptune_subnet_group_name"] = *r.Neptune_subnet_group_name
}
if r.Preferred_maintenance_window != nil {
    config["preferred_maintenance_window"] = *r.Preferred_maintenance_window
}
if r.Cluster_resource_id != nil {
    config["cluster_resource_id"] = *r.Cluster_resource_id
}
if r.Iam_database_authentication_enabled != nil {
    config["iam_database_authentication_enabled"] = *r.Iam_database_authentication_enabled
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_neptune_clusterUnmapper(state map[string]interface{}) *Aws_neptune_cluster {
	r := &Aws_neptune_cluster{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_neptune_cluster_id = &x
}

if x, ok := state["final_snapshot_identifier"]; ok {
	x := x.(string)
	r.Final_snapshot_identifier = &x
}

if x, ok := state["snapshot_identifier"]; ok {
	x := x.(string)
	r.Snapshot_identifier = &x
}

if x, ok := state["preferred_backup_window"]; ok {
	x := x.(string)
	r.Preferred_backup_window = &x
}

if x, ok := state["reader_endpoint"]; ok {
	x := x.(string)
	r.Reader_endpoint = &x
}

if x, ok := state["skip_final_snapshot"]; ok {
	x := x.(bool)
	r.Skip_final_snapshot = &x
}

if x, ok := state["hosted_zone_id"]; ok {
	x := x.(string)
	r.Hosted_zone_id = &x
}

if x, ok := state["replication_source_identifier"]; ok {
	x := x.(string)
	r.Replication_source_identifier = &x
}

if x, ok := state["cluster_resource_id"]; ok {
	x := x.(string)
	r.Cluster_resource_id = &x
}

if x, ok := state["iam_database_authentication_enabled"]; ok {
	x := x.(bool)
	r.Iam_database_authentication_enabled = &x
}

if x, ok := state["kms_key_arn"]; ok {
	x := x.(string)
	r.Kms_key_arn = &x
}

if x, ok := state["neptune_subnet_group_name"]; ok {
	x := x.(string)
	r.Neptune_subnet_group_name = &x
}

if x, ok := state["preferred_maintenance_window"]; ok {
	x := x.(string)
	r.Preferred_maintenance_window = &x
}

if x, ok := state["cluster_identifier"]; ok {
	x := x.(string)
	r.Cluster_identifier = &x
}

if x, ok := state["neptune_cluster_parameter_group_name"]; ok {
	x := x.(string)
	r.Neptune_cluster_parameter_group_name = &x
}

if x, ok := state["storage_encrypted"]; ok {
	x := x.(bool)
	r.Storage_encrypted = &x
}

if x, ok := state["cluster_identifier_prefix"]; ok {
	x := x.(string)
	r.Cluster_identifier_prefix = &x
}

if x, ok := state["endpoint"]; ok {
	x := x.(string)
	r.Endpoint = &x
}

if x, ok := state["apply_immediately"]; ok {
	x := x.(bool)
	r.Apply_immediately = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["engine"]; ok {
	x := x.(string)
	r.Engine = &x
}

if x, ok := state["engine_version"]; ok {
	x := x.(string)
	r.Engine_version = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_neptune_clusterHandler ...
type Aws_neptune_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_neptune_clusterHandler) Create(desired *Aws_neptune_cluster) (*Aws_neptune_cluster, string, error) {
	rState := Aws_neptune_clusterMapper(desired)
	id, err := bridge.Create(h.provider, "aws_neptune_cluster", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_neptune_clusterHandler) Read(externalID string) (*Aws_neptune_cluster, error) {
	actual, err := bridge.Read(h.provider, "aws_neptune_cluster", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_neptune_clusterUnmapper(actual), nil
}

// Delete ...
func (h *Aws_neptune_clusterHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_neptune_cluster", externalID)
}

type Aws_securityhub_standards_subscription struct {
     Aws_securityhub_standards_subscription_id *string
     Standards_arn string
}


func Aws_securityhub_standards_subscriptionMapper(r *Aws_securityhub_standards_subscription) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["standards_arn"] = r.Standards_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_securityhub_standards_subscriptionUnmapper(state map[string]interface{}) *Aws_securityhub_standards_subscription {
	r := &Aws_securityhub_standards_subscription{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_securityhub_standards_subscription_id = &x
}

if x, ok := state["standards_arn"]; ok {
	r.Standards_arn = x.(string)
}
	return r
}


// Aws_securityhub_standards_subscriptionHandler ...
type Aws_securityhub_standards_subscriptionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_securityhub_standards_subscriptionHandler) Create(desired *Aws_securityhub_standards_subscription) (*Aws_securityhub_standards_subscription, string, error) {
	rState := Aws_securityhub_standards_subscriptionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_securityhub_standards_subscription", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_securityhub_standards_subscriptionHandler) Read(externalID string) (*Aws_securityhub_standards_subscription, error) {
	actual, err := bridge.Read(h.provider, "aws_securityhub_standards_subscription", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_securityhub_standards_subscriptionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_securityhub_standards_subscriptionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_securityhub_standards_subscription", externalID)
}

type Aws_iam_group struct {
     Aws_iam_group_id *string
     Arn *string
     Unique_id *string
     Name string
     Path *string
}


func Aws_iam_groupMapper(r *Aws_iam_group) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Unique_id != nil {
    config["unique_id"] = *r.Unique_id
}
    config["name"] = r.Name
if r.Path != nil {
    config["path"] = *r.Path
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_groupUnmapper(state map[string]interface{}) *Aws_iam_group {
	r := &Aws_iam_group{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_group_id = &x
}

if x, ok := state["path"]; ok {
	x := x.(string)
	r.Path = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["unique_id"]; ok {
	x := x.(string)
	r.Unique_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_iam_groupHandler ...
type Aws_iam_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_groupHandler) Create(desired *Aws_iam_group) (*Aws_iam_group, string, error) {
	rState := Aws_iam_groupMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_group", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_groupHandler) Read(externalID string) (*Aws_iam_group, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_group", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_groupUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_groupHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_group", externalID)
}

type Aws_default_network_acl struct {
     Aws_default_network_acl_id *string
     Tags *map[string]string
     Owner_id *string
     Vpc_id *string
     Default_network_acl_id string
}


func Aws_default_network_aclMapper(r *Aws_default_network_acl) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["default_network_acl_id"] = r.Default_network_acl_id
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Owner_id != nil {
    config["owner_id"] = *r.Owner_id
}
if r.Vpc_id != nil {
    config["vpc_id"] = *r.Vpc_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_default_network_aclUnmapper(state map[string]interface{}) *Aws_default_network_acl {
	r := &Aws_default_network_acl{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_default_network_acl_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["owner_id"]; ok {
	x := x.(string)
	r.Owner_id = &x
}

if x, ok := state["vpc_id"]; ok {
	x := x.(string)
	r.Vpc_id = &x
}

if x, ok := state["default_network_acl_id"]; ok {
	r.Default_network_acl_id = x.(string)
}
	return r
}


// Aws_default_network_aclHandler ...
type Aws_default_network_aclHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_default_network_aclHandler) Create(desired *Aws_default_network_acl) (*Aws_default_network_acl, string, error) {
	rState := Aws_default_network_aclMapper(desired)
	id, err := bridge.Create(h.provider, "aws_default_network_acl", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_default_network_aclHandler) Read(externalID string) (*Aws_default_network_acl, error) {
	actual, err := bridge.Read(h.provider, "aws_default_network_acl", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_default_network_aclUnmapper(actual), nil
}

// Delete ...
func (h *Aws_default_network_aclHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_default_network_acl", externalID)
}

type Aws_route struct {
     Aws_route_id *string
     Destination_cidr_block *string
     Gateway_id *string
     Egress_only_gateway_id *string
     Nat_gateway_id *string
     Instance_owner_id *string
     Transit_gateway_id *string
     Destination_ipv6_cidr_block *string
     Instance_id *string
     Origin *string
     Destination_prefix_list_id *string
     Network_interface_id *string
     State *string
     Route_table_id string
     Vpc_peering_connection_id *string
}


func Aws_routeMapper(r *Aws_route) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Destination_ipv6_cidr_block != nil {
    config["destination_ipv6_cidr_block"] = *r.Destination_ipv6_cidr_block
}
if r.Instance_id != nil {
    config["instance_id"] = *r.Instance_id
}
if r.Origin != nil {
    config["origin"] = *r.Origin
}
if r.Destination_prefix_list_id != nil {
    config["destination_prefix_list_id"] = *r.Destination_prefix_list_id
}
if r.Network_interface_id != nil {
    config["network_interface_id"] = *r.Network_interface_id
}
if r.State != nil {
    config["state"] = *r.State
}
    config["route_table_id"] = r.Route_table_id
if r.Vpc_peering_connection_id != nil {
    config["vpc_peering_connection_id"] = *r.Vpc_peering_connection_id
}
if r.Destination_cidr_block != nil {
    config["destination_cidr_block"] = *r.Destination_cidr_block
}
if r.Gateway_id != nil {
    config["gateway_id"] = *r.Gateway_id
}
if r.Egress_only_gateway_id != nil {
    config["egress_only_gateway_id"] = *r.Egress_only_gateway_id
}
if r.Nat_gateway_id != nil {
    config["nat_gateway_id"] = *r.Nat_gateway_id
}
if r.Instance_owner_id != nil {
    config["instance_owner_id"] = *r.Instance_owner_id
}
if r.Transit_gateway_id != nil {
    config["transit_gateway_id"] = *r.Transit_gateway_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_routeUnmapper(state map[string]interface{}) *Aws_route {
	r := &Aws_route{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_route_id = &x
}

if x, ok := state["destination_prefix_list_id"]; ok {
	x := x.(string)
	r.Destination_prefix_list_id = &x
}

if x, ok := state["network_interface_id"]; ok {
	x := x.(string)
	r.Network_interface_id = &x
}

if x, ok := state["state"]; ok {
	x := x.(string)
	r.State = &x
}

if x, ok := state["route_table_id"]; ok {
	r.Route_table_id = x.(string)
}

if x, ok := state["vpc_peering_connection_id"]; ok {
	x := x.(string)
	r.Vpc_peering_connection_id = &x
}

if x, ok := state["transit_gateway_id"]; ok {
	x := x.(string)
	r.Transit_gateway_id = &x
}

if x, ok := state["destination_cidr_block"]; ok {
	x := x.(string)
	r.Destination_cidr_block = &x
}

if x, ok := state["gateway_id"]; ok {
	x := x.(string)
	r.Gateway_id = &x
}

if x, ok := state["egress_only_gateway_id"]; ok {
	x := x.(string)
	r.Egress_only_gateway_id = &x
}

if x, ok := state["nat_gateway_id"]; ok {
	x := x.(string)
	r.Nat_gateway_id = &x
}

if x, ok := state["instance_owner_id"]; ok {
	x := x.(string)
	r.Instance_owner_id = &x
}

if x, ok := state["destination_ipv6_cidr_block"]; ok {
	x := x.(string)
	r.Destination_ipv6_cidr_block = &x
}

if x, ok := state["instance_id"]; ok {
	x := x.(string)
	r.Instance_id = &x
}

if x, ok := state["origin"]; ok {
	x := x.(string)
	r.Origin = &x
}
	return r
}


// Aws_routeHandler ...
type Aws_routeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_routeHandler) Create(desired *Aws_route) (*Aws_route, string, error) {
	rState := Aws_routeMapper(desired)
	id, err := bridge.Create(h.provider, "aws_route", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_routeHandler) Read(externalID string) (*Aws_route, error) {
	actual, err := bridge.Read(h.provider, "aws_route", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_routeUnmapper(actual), nil
}

// Delete ...
func (h *Aws_routeHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_route", externalID)
}

type Aws_ssm_association struct {
     Aws_ssm_association_id *string
     Instance_id *string
     Document_version *string
     Parameters *map[string]string
     Association_name *string
     Association_id *string
     Name string
     Schedule_expression *string
}


func Aws_ssm_associationMapper(r *Aws_ssm_association) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Association_name != nil {
    config["association_name"] = *r.Association_name
}
if r.Association_id != nil {
    config["association_id"] = *r.Association_id
}
    config["name"] = r.Name
if r.Schedule_expression != nil {
    config["schedule_expression"] = *r.Schedule_expression
}
if r.Instance_id != nil {
    config["instance_id"] = *r.Instance_id
}
if r.Document_version != nil {
    config["document_version"] = *r.Document_version
}
if r.Parameters != nil {
    config["parameters"] = *r.Parameters
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ssm_associationUnmapper(state map[string]interface{}) *Aws_ssm_association {
	r := &Aws_ssm_association{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ssm_association_id = &x
}

if x, ok := state["schedule_expression"]; ok {
	x := x.(string)
	r.Schedule_expression = &x
}

if x, ok := state["association_name"]; ok {
	x := x.(string)
	r.Association_name = &x
}

if x, ok := state["association_id"]; ok {
	x := x.(string)
	r.Association_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["instance_id"]; ok {
	x := x.(string)
	r.Instance_id = &x
}

if x, ok := state["document_version"]; ok {
	x := x.(string)
	r.Document_version = &x
}

if x, ok := state["parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Parameters = &x
}
	return r
}


// Aws_ssm_associationHandler ...
type Aws_ssm_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ssm_associationHandler) Create(desired *Aws_ssm_association) (*Aws_ssm_association, string, error) {
	rState := Aws_ssm_associationMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ssm_association", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ssm_associationHandler) Read(externalID string) (*Aws_ssm_association, error) {
	actual, err := bridge.Read(h.provider, "aws_ssm_association", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ssm_associationUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ssm_associationHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ssm_association", externalID)
}

type Aws_api_gateway_stage struct {
     Aws_api_gateway_stage_id *string
     Client_certificate_id *string
     Deployment_id string
     Stage_name string
     Cache_cluster_size *string
     Description *string
     Documentation_version *string
     Invoke_url *string
     Rest_api_id string
     Variables *map[string]string
     Xray_tracing_enabled *bool
     Execution_arn *string
     Cache_cluster_enabled *bool
     Tags *map[string]string
}


func Aws_api_gateway_stageMapper(r *Aws_api_gateway_stage) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Cache_cluster_enabled != nil {
    config["cache_cluster_enabled"] = *r.Cache_cluster_enabled
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Client_certificate_id != nil {
    config["client_certificate_id"] = *r.Client_certificate_id
}
    config["deployment_id"] = r.Deployment_id
    config["stage_name"] = r.Stage_name
    config["rest_api_id"] = r.Rest_api_id
if r.Variables != nil {
    config["variables"] = *r.Variables
}
if r.Xray_tracing_enabled != nil {
    config["xray_tracing_enabled"] = *r.Xray_tracing_enabled
}
if r.Cache_cluster_size != nil {
    config["cache_cluster_size"] = *r.Cache_cluster_size
}
if r.Description != nil {
    config["description"] = *r.Description
}
if r.Documentation_version != nil {
    config["documentation_version"] = *r.Documentation_version
}
if r.Invoke_url != nil {
    config["invoke_url"] = *r.Invoke_url
}
if r.Execution_arn != nil {
    config["execution_arn"] = *r.Execution_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_api_gateway_stageUnmapper(state map[string]interface{}) *Aws_api_gateway_stage {
	r := &Aws_api_gateway_stage{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_api_gateway_stage_id = &x
}

if x, ok := state["cache_cluster_enabled"]; ok {
	x := x.(bool)
	r.Cache_cluster_enabled = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["client_certificate_id"]; ok {
	x := x.(string)
	r.Client_certificate_id = &x
}

if x, ok := state["deployment_id"]; ok {
	r.Deployment_id = x.(string)
}

if x, ok := state["stage_name"]; ok {
	r.Stage_name = x.(string)
}

if x, ok := state["xray_tracing_enabled"]; ok {
	x := x.(bool)
	r.Xray_tracing_enabled = &x
}

if x, ok := state["cache_cluster_size"]; ok {
	x := x.(string)
	r.Cache_cluster_size = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["documentation_version"]; ok {
	x := x.(string)
	r.Documentation_version = &x
}

if x, ok := state["invoke_url"]; ok {
	x := x.(string)
	r.Invoke_url = &x
}

if x, ok := state["rest_api_id"]; ok {
	r.Rest_api_id = x.(string)
}

if x, ok := state["variables"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Variables = &x
}

if x, ok := state["execution_arn"]; ok {
	x := x.(string)
	r.Execution_arn = &x
}
	return r
}


// Aws_api_gateway_stageHandler ...
type Aws_api_gateway_stageHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_api_gateway_stageHandler) Create(desired *Aws_api_gateway_stage) (*Aws_api_gateway_stage, string, error) {
	rState := Aws_api_gateway_stageMapper(desired)
	id, err := bridge.Create(h.provider, "aws_api_gateway_stage", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_api_gateway_stageHandler) Read(externalID string) (*Aws_api_gateway_stage, error) {
	actual, err := bridge.Read(h.provider, "aws_api_gateway_stage", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_api_gateway_stageUnmapper(actual), nil
}

// Delete ...
func (h *Aws_api_gateway_stageHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_api_gateway_stage", externalID)
}

type Aws_cloudwatch_event_target struct {
     Aws_cloudwatch_event_target_id *string
     Target_id *string
     Input_path *string
     Role_arn *string
     Rule string
     Arn string
     Input *string
}


func Aws_cloudwatch_event_targetMapper(r *Aws_cloudwatch_event_target) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["rule"] = r.Rule
    config["arn"] = r.Arn
if r.Input != nil {
    config["input"] = *r.Input
}
if r.Target_id != nil {
    config["target_id"] = *r.Target_id
}
if r.Input_path != nil {
    config["input_path"] = *r.Input_path
}
if r.Role_arn != nil {
    config["role_arn"] = *r.Role_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_event_targetUnmapper(state map[string]interface{}) *Aws_cloudwatch_event_target {
	r := &Aws_cloudwatch_event_target{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_event_target_id = &x
}

if x, ok := state["rule"]; ok {
	r.Rule = x.(string)
}

if x, ok := state["arn"]; ok {
	r.Arn = x.(string)
}

if x, ok := state["input"]; ok {
	x := x.(string)
	r.Input = &x
}

if x, ok := state["target_id"]; ok {
	x := x.(string)
	r.Target_id = &x
}

if x, ok := state["input_path"]; ok {
	x := x.(string)
	r.Input_path = &x
}

if x, ok := state["role_arn"]; ok {
	x := x.(string)
	r.Role_arn = &x
}
	return r
}


// Aws_cloudwatch_event_targetHandler ...
type Aws_cloudwatch_event_targetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_event_targetHandler) Create(desired *Aws_cloudwatch_event_target) (*Aws_cloudwatch_event_target, string, error) {
	rState := Aws_cloudwatch_event_targetMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_event_target", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_event_targetHandler) Read(externalID string) (*Aws_cloudwatch_event_target, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_event_target", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_event_targetUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_event_targetHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_event_target", externalID)
}

type Aws_opsworks_memcached_layer struct {
     Aws_opsworks_memcached_layer_id *string
     Auto_assign_elastic_ips *bool
     Drain_elb_on_shutdown *bool
     Stack_id string
     Custom_instance_profile_arn *string
     Custom_json *string
     Auto_healing *bool
     Install_updates_on_boot *bool
     Use_ebs_optimized_instances *bool
     Name *string
     Auto_assign_public_ips *bool
     Elastic_load_balancer *string
}


func Aws_opsworks_memcached_layerMapper(r *Aws_opsworks_memcached_layer) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Auto_assign_public_ips != nil {
    config["auto_assign_public_ips"] = *r.Auto_assign_public_ips
}
if r.Elastic_load_balancer != nil {
    config["elastic_load_balancer"] = *r.Elastic_load_balancer
}
if r.Auto_assign_elastic_ips != nil {
    config["auto_assign_elastic_ips"] = *r.Auto_assign_elastic_ips
}
if r.Drain_elb_on_shutdown != nil {
    config["drain_elb_on_shutdown"] = *r.Drain_elb_on_shutdown
}
    config["stack_id"] = r.Stack_id
if r.Custom_instance_profile_arn != nil {
    config["custom_instance_profile_arn"] = *r.Custom_instance_profile_arn
}
if r.Custom_json != nil {
    config["custom_json"] = *r.Custom_json
}
if r.Auto_healing != nil {
    config["auto_healing"] = *r.Auto_healing
}
if r.Install_updates_on_boot != nil {
    config["install_updates_on_boot"] = *r.Install_updates_on_boot
}
if r.Use_ebs_optimized_instances != nil {
    config["use_ebs_optimized_instances"] = *r.Use_ebs_optimized_instances
}
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_opsworks_memcached_layerUnmapper(state map[string]interface{}) *Aws_opsworks_memcached_layer {
	r := &Aws_opsworks_memcached_layer{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_opsworks_memcached_layer_id = &x
}

if x, ok := state["auto_assign_public_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_public_ips = &x
}

if x, ok := state["elastic_load_balancer"]; ok {
	x := x.(string)
	r.Elastic_load_balancer = &x
}

if x, ok := state["auto_assign_elastic_ips"]; ok {
	x := x.(bool)
	r.Auto_assign_elastic_ips = &x
}

if x, ok := state["drain_elb_on_shutdown"]; ok {
	x := x.(bool)
	r.Drain_elb_on_shutdown = &x
}

if x, ok := state["stack_id"]; ok {
	r.Stack_id = x.(string)
}

if x, ok := state["custom_instance_profile_arn"]; ok {
	x := x.(string)
	r.Custom_instance_profile_arn = &x
}

if x, ok := state["custom_json"]; ok {
	x := x.(string)
	r.Custom_json = &x
}

if x, ok := state["auto_healing"]; ok {
	x := x.(bool)
	r.Auto_healing = &x
}

if x, ok := state["install_updates_on_boot"]; ok {
	x := x.(bool)
	r.Install_updates_on_boot = &x
}

if x, ok := state["use_ebs_optimized_instances"]; ok {
	x := x.(bool)
	r.Use_ebs_optimized_instances = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}
	return r
}


// Aws_opsworks_memcached_layerHandler ...
type Aws_opsworks_memcached_layerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_opsworks_memcached_layerHandler) Create(desired *Aws_opsworks_memcached_layer) (*Aws_opsworks_memcached_layer, string, error) {
	rState := Aws_opsworks_memcached_layerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_opsworks_memcached_layer", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_opsworks_memcached_layerHandler) Read(externalID string) (*Aws_opsworks_memcached_layer, error) {
	actual, err := bridge.Read(h.provider, "aws_opsworks_memcached_layer", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_opsworks_memcached_layerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_opsworks_memcached_layerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_opsworks_memcached_layer", externalID)
}

type Aws_kms_grant struct {
     Aws_kms_grant_id *string
     Retire_on_delete *bool
     Grant_id *string
     Key_id string
     Grantee_principal string
     Retiring_principal *string
     Name *string
     Grant_token *string
}


func Aws_kms_grantMapper(r *Aws_kms_grant) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["grantee_principal"] = r.Grantee_principal
if r.Retiring_principal != nil {
    config["retiring_principal"] = *r.Retiring_principal
}
if r.Retire_on_delete != nil {
    config["retire_on_delete"] = *r.Retire_on_delete
}
if r.Grant_id != nil {
    config["grant_id"] = *r.Grant_id
}
    config["key_id"] = r.Key_id
if r.Grant_token != nil {
    config["grant_token"] = *r.Grant_token
}
if r.Name != nil {
    config["name"] = *r.Name
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_kms_grantUnmapper(state map[string]interface{}) *Aws_kms_grant {
	r := &Aws_kms_grant{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_kms_grant_id = &x
}

if x, ok := state["grantee_principal"]; ok {
	r.Grantee_principal = x.(string)
}

if x, ok := state["retiring_principal"]; ok {
	x := x.(string)
	r.Retiring_principal = &x
}

if x, ok := state["retire_on_delete"]; ok {
	x := x.(bool)
	r.Retire_on_delete = &x
}

if x, ok := state["grant_id"]; ok {
	x := x.(string)
	r.Grant_id = &x
}

if x, ok := state["key_id"]; ok {
	r.Key_id = x.(string)
}

if x, ok := state["grant_token"]; ok {
	x := x.(string)
	r.Grant_token = &x
}

if x, ok := state["name"]; ok {
	x := x.(string)
	r.Name = &x
}
	return r
}


// Aws_kms_grantHandler ...
type Aws_kms_grantHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_kms_grantHandler) Create(desired *Aws_kms_grant) (*Aws_kms_grant, string, error) {
	rState := Aws_kms_grantMapper(desired)
	id, err := bridge.Create(h.provider, "aws_kms_grant", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_kms_grantHandler) Read(externalID string) (*Aws_kms_grant, error) {
	actual, err := bridge.Read(h.provider, "aws_kms_grant", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_kms_grantUnmapper(actual), nil
}

// Delete ...
func (h *Aws_kms_grantHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_kms_grant", externalID)
}

type Aws_codecommit_trigger struct {
     Aws_codecommit_trigger_id *string
     Configuration_id *string
     Repository_name string
}


func Aws_codecommit_triggerMapper(r *Aws_codecommit_trigger) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["repository_name"] = r.Repository_name
if r.Configuration_id != nil {
    config["configuration_id"] = *r.Configuration_id
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_codecommit_triggerUnmapper(state map[string]interface{}) *Aws_codecommit_trigger {
	r := &Aws_codecommit_trigger{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_codecommit_trigger_id = &x
}

if x, ok := state["configuration_id"]; ok {
	x := x.(string)
	r.Configuration_id = &x
}

if x, ok := state["repository_name"]; ok {
	r.Repository_name = x.(string)
}
	return r
}


// Aws_codecommit_triggerHandler ...
type Aws_codecommit_triggerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_codecommit_triggerHandler) Create(desired *Aws_codecommit_trigger) (*Aws_codecommit_trigger, string, error) {
	rState := Aws_codecommit_triggerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_codecommit_trigger", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_codecommit_triggerHandler) Read(externalID string) (*Aws_codecommit_trigger, error) {
	actual, err := bridge.Read(h.provider, "aws_codecommit_trigger", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_codecommit_triggerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_codecommit_triggerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_codecommit_trigger", externalID)
}

type Aws_dlm_lifecycle_policy struct {
     Aws_dlm_lifecycle_policy_id *string
     State *string
     Description string
     Execution_role_arn string
}


func Aws_dlm_lifecycle_policyMapper(r *Aws_dlm_lifecycle_policy) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["description"] = r.Description
    config["execution_role_arn"] = r.Execution_role_arn
if r.State != nil {
    config["state"] = *r.State
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_dlm_lifecycle_policyUnmapper(state map[string]interface{}) *Aws_dlm_lifecycle_policy {
	r := &Aws_dlm_lifecycle_policy{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_dlm_lifecycle_policy_id = &x
}

if x, ok := state["description"]; ok {
	r.Description = x.(string)
}

if x, ok := state["execution_role_arn"]; ok {
	r.Execution_role_arn = x.(string)
}

if x, ok := state["state"]; ok {
	x := x.(string)
	r.State = &x
}
	return r
}


// Aws_dlm_lifecycle_policyHandler ...
type Aws_dlm_lifecycle_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_dlm_lifecycle_policyHandler) Create(desired *Aws_dlm_lifecycle_policy) (*Aws_dlm_lifecycle_policy, string, error) {
	rState := Aws_dlm_lifecycle_policyMapper(desired)
	id, err := bridge.Create(h.provider, "aws_dlm_lifecycle_policy", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_dlm_lifecycle_policyHandler) Read(externalID string) (*Aws_dlm_lifecycle_policy, error) {
	actual, err := bridge.Read(h.provider, "aws_dlm_lifecycle_policy", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_dlm_lifecycle_policyUnmapper(actual), nil
}

// Delete ...
func (h *Aws_dlm_lifecycle_policyHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_dlm_lifecycle_policy", externalID)
}

type Aws_cloudwatch_event_permission struct {
     Aws_cloudwatch_event_permission_id *string
     Action *string
     Principal string
     Statement_id string
}


func Aws_cloudwatch_event_permissionMapper(r *Aws_cloudwatch_event_permission) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Action != nil {
    config["action"] = *r.Action
}
    config["principal"] = r.Principal
    config["statement_id"] = r.Statement_id
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudwatch_event_permissionUnmapper(state map[string]interface{}) *Aws_cloudwatch_event_permission {
	r := &Aws_cloudwatch_event_permission{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudwatch_event_permission_id = &x
}

if x, ok := state["action"]; ok {
	x := x.(string)
	r.Action = &x
}

if x, ok := state["principal"]; ok {
	r.Principal = x.(string)
}

if x, ok := state["statement_id"]; ok {
	r.Statement_id = x.(string)
}
	return r
}


// Aws_cloudwatch_event_permissionHandler ...
type Aws_cloudwatch_event_permissionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudwatch_event_permissionHandler) Create(desired *Aws_cloudwatch_event_permission) (*Aws_cloudwatch_event_permission, string, error) {
	rState := Aws_cloudwatch_event_permissionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudwatch_event_permission", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudwatch_event_permissionHandler) Read(externalID string) (*Aws_cloudwatch_event_permission, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudwatch_event_permission", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudwatch_event_permissionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudwatch_event_permissionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudwatch_event_permission", externalID)
}

type Aws_glue_crawler struct {
     Aws_glue_crawler_id *string
     Table_prefix *string
     Description *string
     Schedule *string
     Role string
     Configuration *string
     Security_configuration *string
     Name string
     Database_name string
}


func Aws_glue_crawlerMapper(r *Aws_glue_crawler) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["database_name"] = r.Database_name
    config["role"] = r.Role
if r.Configuration != nil {
    config["configuration"] = *r.Configuration
}
if r.Security_configuration != nil {
    config["security_configuration"] = *r.Security_configuration
}
    config["name"] = r.Name
if r.Schedule != nil {
    config["schedule"] = *r.Schedule
}
if r.Table_prefix != nil {
    config["table_prefix"] = *r.Table_prefix
}
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_glue_crawlerUnmapper(state map[string]interface{}) *Aws_glue_crawler {
	r := &Aws_glue_crawler{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_glue_crawler_id = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["schedule"]; ok {
	x := x.(string)
	r.Schedule = &x
}

if x, ok := state["table_prefix"]; ok {
	x := x.(string)
	r.Table_prefix = &x
}

if x, ok := state["security_configuration"]; ok {
	x := x.(string)
	r.Security_configuration = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["database_name"]; ok {
	r.Database_name = x.(string)
}

if x, ok := state["role"]; ok {
	r.Role = x.(string)
}

if x, ok := state["configuration"]; ok {
	x := x.(string)
	r.Configuration = &x
}
	return r
}


// Aws_glue_crawlerHandler ...
type Aws_glue_crawlerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_glue_crawlerHandler) Create(desired *Aws_glue_crawler) (*Aws_glue_crawler, string, error) {
	rState := Aws_glue_crawlerMapper(desired)
	id, err := bridge.Create(h.provider, "aws_glue_crawler", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_glue_crawlerHandler) Read(externalID string) (*Aws_glue_crawler, error) {
	actual, err := bridge.Read(h.provider, "aws_glue_crawler", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_glue_crawlerUnmapper(actual), nil
}

// Delete ...
func (h *Aws_glue_crawlerHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_glue_crawler", externalID)
}

type Aws_batch_compute_environment struct {
     Aws_batch_compute_environment_id *string
     Status_reason *string
     State *string
     Status *string
     Service_role string
     Resource_type string
     Arn *string
     Ecc_cluster_arn *string
     Ecs_cluster_arn *string
     Compute_environment_name string
}


func Aws_batch_compute_environmentMapper(r *Aws_batch_compute_environment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Ecc_cluster_arn != nil {
    config["ecc_cluster_arn"] = *r.Ecc_cluster_arn
}
if r.Ecs_cluster_arn != nil {
    config["ecs_cluster_arn"] = *r.Ecs_cluster_arn
}
    config["compute_environment_name"] = r.Compute_environment_name
    config["service_role"] = r.Service_role
    config["resource_type"] = r.Resource_type
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.State != nil {
    config["state"] = *r.State
}
if r.Status != nil {
    config["status"] = *r.Status
}
if r.Status_reason != nil {
    config["status_reason"] = *r.Status_reason
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_batch_compute_environmentUnmapper(state map[string]interface{}) *Aws_batch_compute_environment {
	r := &Aws_batch_compute_environment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_batch_compute_environment_id = &x
}

if x, ok := state["resource_type"]; ok {
	r.Resource_type = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["ecc_cluster_arn"]; ok {
	x := x.(string)
	r.Ecc_cluster_arn = &x
}

if x, ok := state["ecs_cluster_arn"]; ok {
	x := x.(string)
	r.Ecs_cluster_arn = &x
}

if x, ok := state["compute_environment_name"]; ok {
	r.Compute_environment_name = x.(string)
}

if x, ok := state["service_role"]; ok {
	r.Service_role = x.(string)
}

if x, ok := state["state"]; ok {
	x := x.(string)
	r.State = &x
}

if x, ok := state["status"]; ok {
	x := x.(string)
	r.Status = &x
}

if x, ok := state["status_reason"]; ok {
	x := x.(string)
	r.Status_reason = &x
}
	return r
}


// Aws_batch_compute_environmentHandler ...
type Aws_batch_compute_environmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_batch_compute_environmentHandler) Create(desired *Aws_batch_compute_environment) (*Aws_batch_compute_environment, string, error) {
	rState := Aws_batch_compute_environmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_batch_compute_environment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_batch_compute_environmentHandler) Read(externalID string) (*Aws_batch_compute_environment, error) {
	actual, err := bridge.Read(h.provider, "aws_batch_compute_environment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_batch_compute_environmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_batch_compute_environmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_batch_compute_environment", externalID)
}

type Aws_acm_certificate struct {
     Aws_acm_certificate_id *string
     Tags *map[string]string
     Certificate_body *string
     Certificate_chain *string
     Private_key *string
     Arn *string
     Domain_name *string
     Validation_method *string
}


func Aws_acm_certificateMapper(r *Aws_acm_certificate) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Certificate_body != nil {
    config["certificate_body"] = *r.Certificate_body
}
if r.Certificate_chain != nil {
    config["certificate_chain"] = *r.Certificate_chain
}
if r.Private_key != nil {
    config["private_key"] = *r.Private_key
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Domain_name != nil {
    config["domain_name"] = *r.Domain_name
}
if r.Validation_method != nil {
    config["validation_method"] = *r.Validation_method
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_acm_certificateUnmapper(state map[string]interface{}) *Aws_acm_certificate {
	r := &Aws_acm_certificate{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_acm_certificate_id = &x
}

if x, ok := state["domain_name"]; ok {
	x := x.(string)
	r.Domain_name = &x
}

if x, ok := state["validation_method"]; ok {
	x := x.(string)
	r.Validation_method = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["certificate_body"]; ok {
	x := x.(string)
	r.Certificate_body = &x
}

if x, ok := state["certificate_chain"]; ok {
	x := x.(string)
	r.Certificate_chain = &x
}

if x, ok := state["private_key"]; ok {
	x := x.(string)
	r.Private_key = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_acm_certificateHandler ...
type Aws_acm_certificateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_acm_certificateHandler) Create(desired *Aws_acm_certificate) (*Aws_acm_certificate, string, error) {
	rState := Aws_acm_certificateMapper(desired)
	id, err := bridge.Create(h.provider, "aws_acm_certificate", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_acm_certificateHandler) Read(externalID string) (*Aws_acm_certificate, error) {
	actual, err := bridge.Read(h.provider, "aws_acm_certificate", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_acm_certificateUnmapper(actual), nil
}

// Delete ...
func (h *Aws_acm_certificateHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_acm_certificate", externalID)
}

type Aws_ecs_task_definition struct {
     Aws_ecs_task_definition_id *string
     Family string
     Container_definitions string
     Cpu *string
     Execution_role_arn *string
     Tags *map[string]string
     Task_role_arn *string
     Memory *string
     Arn *string
     Network_mode *string
     Ipc_mode *string
     Pid_mode *string
}


func Aws_ecs_task_definitionMapper(r *Aws_ecs_task_definition) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["family"] = r.Family
    config["container_definitions"] = r.Container_definitions
if r.Cpu != nil {
    config["cpu"] = *r.Cpu
}
if r.Execution_role_arn != nil {
    config["execution_role_arn"] = *r.Execution_role_arn
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
if r.Task_role_arn != nil {
    config["task_role_arn"] = *r.Task_role_arn
}
if r.Memory != nil {
    config["memory"] = *r.Memory
}
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Network_mode != nil {
    config["network_mode"] = *r.Network_mode
}
if r.Ipc_mode != nil {
    config["ipc_mode"] = *r.Ipc_mode
}
if r.Pid_mode != nil {
    config["pid_mode"] = *r.Pid_mode
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_ecs_task_definitionUnmapper(state map[string]interface{}) *Aws_ecs_task_definition {
	r := &Aws_ecs_task_definition{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_ecs_task_definition_id = &x
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["network_mode"]; ok {
	x := x.(string)
	r.Network_mode = &x
}

if x, ok := state["ipc_mode"]; ok {
	x := x.(string)
	r.Ipc_mode = &x
}

if x, ok := state["pid_mode"]; ok {
	x := x.(string)
	r.Pid_mode = &x
}

if x, ok := state["family"]; ok {
	r.Family = x.(string)
}

if x, ok := state["container_definitions"]; ok {
	r.Container_definitions = x.(string)
}

if x, ok := state["cpu"]; ok {
	x := x.(string)
	r.Cpu = &x
}

if x, ok := state["execution_role_arn"]; ok {
	x := x.(string)
	r.Execution_role_arn = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["task_role_arn"]; ok {
	x := x.(string)
	r.Task_role_arn = &x
}

if x, ok := state["memory"]; ok {
	x := x.(string)
	r.Memory = &x
}
	return r
}


// Aws_ecs_task_definitionHandler ...
type Aws_ecs_task_definitionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_ecs_task_definitionHandler) Create(desired *Aws_ecs_task_definition) (*Aws_ecs_task_definition, string, error) {
	rState := Aws_ecs_task_definitionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_ecs_task_definition", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_ecs_task_definitionHandler) Read(externalID string) (*Aws_ecs_task_definition, error) {
	actual, err := bridge.Read(h.provider, "aws_ecs_task_definition", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_ecs_task_definitionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_ecs_task_definitionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_ecs_task_definition", externalID)
}

type Aws_wafregional_regex_match_set struct {
     Aws_wafregional_regex_match_set_id *string
     Name string
}


func Aws_wafregional_regex_match_setMapper(r *Aws_wafregional_regex_match_set) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_wafregional_regex_match_setUnmapper(state map[string]interface{}) *Aws_wafregional_regex_match_set {
	r := &Aws_wafregional_regex_match_set{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_wafregional_regex_match_set_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}
	return r
}


// Aws_wafregional_regex_match_setHandler ...
type Aws_wafregional_regex_match_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_wafregional_regex_match_setHandler) Create(desired *Aws_wafregional_regex_match_set) (*Aws_wafregional_regex_match_set, string, error) {
	rState := Aws_wafregional_regex_match_setMapper(desired)
	id, err := bridge.Create(h.provider, "aws_wafregional_regex_match_set", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_wafregional_regex_match_setHandler) Read(externalID string) (*Aws_wafregional_regex_match_set, error) {
	actual, err := bridge.Read(h.provider, "aws_wafregional_regex_match_set", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_wafregional_regex_match_setUnmapper(actual), nil
}

// Delete ...
func (h *Aws_wafregional_regex_match_setHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_wafregional_regex_match_set", externalID)
}

type Aws_cloudformation_stack struct {
     Aws_cloudformation_stack_id *string
     Parameters *map[string]string
     Policy_body *string
     Template_url *string
     On_failure *string
     Tags *map[string]string
     Name string
     Outputs *map[string]string
     Policy_url *string
     Iam_role_arn *string
     Template_body *string
     Disable_rollback *bool
}


func Aws_cloudformation_stackMapper(r *Aws_cloudformation_stack) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
if r.Iam_role_arn != nil {
    config["iam_role_arn"] = *r.Iam_role_arn
}
if r.Template_body != nil {
    config["template_body"] = *r.Template_body
}
if r.Disable_rollback != nil {
    config["disable_rollback"] = *r.Disable_rollback
}
if r.Outputs != nil {
    config["outputs"] = *r.Outputs
}
if r.Policy_url != nil {
    config["policy_url"] = *r.Policy_url
}
if r.Parameters != nil {
    config["parameters"] = *r.Parameters
}
if r.Policy_body != nil {
    config["policy_body"] = *r.Policy_body
}
if r.Template_url != nil {
    config["template_url"] = *r.Template_url
}
if r.On_failure != nil {
    config["on_failure"] = *r.On_failure
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_cloudformation_stackUnmapper(state map[string]interface{}) *Aws_cloudformation_stack {
	r := &Aws_cloudformation_stack{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_cloudformation_stack_id = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["outputs"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Outputs = &x
}

if x, ok := state["policy_url"]; ok {
	x := x.(string)
	r.Policy_url = &x
}

if x, ok := state["iam_role_arn"]; ok {
	x := x.(string)
	r.Iam_role_arn = &x
}

if x, ok := state["template_body"]; ok {
	x := x.(string)
	r.Template_body = &x
}

if x, ok := state["disable_rollback"]; ok {
	x := x.(bool)
	r.Disable_rollback = &x
}

if x, ok := state["parameters"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Parameters = &x
}

if x, ok := state["policy_body"]; ok {
	x := x.(string)
	r.Policy_body = &x
}

if x, ok := state["template_url"]; ok {
	x := x.(string)
	r.Template_url = &x
}

if x, ok := state["on_failure"]; ok {
	x := x.(string)
	r.On_failure = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}
	return r
}


// Aws_cloudformation_stackHandler ...
type Aws_cloudformation_stackHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_cloudformation_stackHandler) Create(desired *Aws_cloudformation_stack) (*Aws_cloudformation_stack, string, error) {
	rState := Aws_cloudformation_stackMapper(desired)
	id, err := bridge.Create(h.provider, "aws_cloudformation_stack", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_cloudformation_stackHandler) Read(externalID string) (*Aws_cloudformation_stack, error) {
	actual, err := bridge.Read(h.provider, "aws_cloudformation_stack", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_cloudformation_stackUnmapper(actual), nil
}

// Delete ...
func (h *Aws_cloudformation_stackHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_cloudformation_stack", externalID)
}

type Aws_lambda_function struct {
     Aws_lambda_function_id *string
     Version *string
     Last_modified *string
     Kms_key_arn *string
     Filename *string
     Publish *bool
     Role string
     Arn *string
     Tags *map[string]string
     Handler string
     Qualified_arn *string
     Invoke_arn *string
     Description *string
     Runtime string
     S3_bucket *string
     S3_object_version *string
     Source_code_hash *string
     S3_key *string
     Function_name string
}


func Aws_lambda_functionMapper(r *Aws_lambda_function) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	if r.Filename != nil {
    config["filename"] = *r.Filename
}
if r.Publish != nil {
    config["publish"] = *r.Publish
}
    config["role"] = r.Role
if r.Arn != nil {
    config["arn"] = *r.Arn
}
if r.Tags != nil {
    config["tags"] = unconvertMap(*r.Tags)
}
    config["handler"] = r.Handler
if r.Qualified_arn != nil {
    config["qualified_arn"] = *r.Qualified_arn
}
if r.Invoke_arn != nil {
    config["invoke_arn"] = *r.Invoke_arn
}
if r.Description != nil {
    config["description"] = *r.Description
}
    config["runtime"] = r.Runtime
if r.S3_bucket != nil {
    config["s3_bucket"] = *r.S3_bucket
}
if r.S3_object_version != nil {
    config["s3_object_version"] = *r.S3_object_version
}
if r.Source_code_hash != nil {
    config["source_code_hash"] = *r.Source_code_hash
}
if r.S3_key != nil {
    config["s3_key"] = *r.S3_key
}
    config["function_name"] = r.Function_name
if r.Version != nil {
    config["version"] = *r.Version
}
if r.Last_modified != nil {
    config["last_modified"] = *r.Last_modified
}
if r.Kms_key_arn != nil {
    config["kms_key_arn"] = *r.Kms_key_arn
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_lambda_functionUnmapper(state map[string]interface{}) *Aws_lambda_function {
	r := &Aws_lambda_function{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_lambda_function_id = &x
}

if x, ok := state["tags"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.Tags = &x
}

if x, ok := state["role"]; ok {
	r.Role = x.(string)
}

if x, ok := state["arn"]; ok {
	x := x.(string)
	r.Arn = &x
}

if x, ok := state["handler"]; ok {
	r.Handler = x.(string)
}

if x, ok := state["qualified_arn"]; ok {
	x := x.(string)
	r.Qualified_arn = &x
}

if x, ok := state["invoke_arn"]; ok {
	x := x.(string)
	r.Invoke_arn = &x
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["runtime"]; ok {
	r.Runtime = x.(string)
}

if x, ok := state["source_code_hash"]; ok {
	x := x.(string)
	r.Source_code_hash = &x
}

if x, ok := state["s3_bucket"]; ok {
	x := x.(string)
	r.S3_bucket = &x
}

if x, ok := state["s3_object_version"]; ok {
	x := x.(string)
	r.S3_object_version = &x
}

if x, ok := state["s3_key"]; ok {
	x := x.(string)
	r.S3_key = &x
}

if x, ok := state["function_name"]; ok {
	r.Function_name = x.(string)
}

if x, ok := state["kms_key_arn"]; ok {
	x := x.(string)
	r.Kms_key_arn = &x
}

if x, ok := state["version"]; ok {
	x := x.(string)
	r.Version = &x
}

if x, ok := state["last_modified"]; ok {
	x := x.(string)
	r.Last_modified = &x
}

if x, ok := state["publish"]; ok {
	x := x.(bool)
	r.Publish = &x
}

if x, ok := state["filename"]; ok {
	x := x.(string)
	r.Filename = &x
}
	return r
}


// Aws_lambda_functionHandler ...
type Aws_lambda_functionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_lambda_functionHandler) Create(desired *Aws_lambda_function) (*Aws_lambda_function, string, error) {
	rState := Aws_lambda_functionMapper(desired)
	id, err := bridge.Create(h.provider, "aws_lambda_function", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_lambda_functionHandler) Read(externalID string) (*Aws_lambda_function, error) {
	actual, err := bridge.Read(h.provider, "aws_lambda_function", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_lambda_functionUnmapper(actual), nil
}

// Delete ...
func (h *Aws_lambda_functionHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_lambda_function", externalID)
}

type Aws_pinpoint_sms_channel struct {
     Aws_pinpoint_sms_channel_id *string
     Application_id string
     Enabled *bool
     Sender_id *string
     Short_code *string
}


func Aws_pinpoint_sms_channelMapper(r *Aws_pinpoint_sms_channel) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["application_id"] = r.Application_id
if r.Enabled != nil {
    config["enabled"] = *r.Enabled
}
if r.Sender_id != nil {
    config["sender_id"] = *r.Sender_id
}
if r.Short_code != nil {
    config["short_code"] = *r.Short_code
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_pinpoint_sms_channelUnmapper(state map[string]interface{}) *Aws_pinpoint_sms_channel {
	r := &Aws_pinpoint_sms_channel{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_pinpoint_sms_channel_id = &x
}

if x, ok := state["application_id"]; ok {
	r.Application_id = x.(string)
}

if x, ok := state["enabled"]; ok {
	x := x.(bool)
	r.Enabled = &x
}

if x, ok := state["sender_id"]; ok {
	x := x.(string)
	r.Sender_id = &x
}

if x, ok := state["short_code"]; ok {
	x := x.(string)
	r.Short_code = &x
}
	return r
}


// Aws_pinpoint_sms_channelHandler ...
type Aws_pinpoint_sms_channelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_pinpoint_sms_channelHandler) Create(desired *Aws_pinpoint_sms_channel) (*Aws_pinpoint_sms_channel, string, error) {
	rState := Aws_pinpoint_sms_channelMapper(desired)
	id, err := bridge.Create(h.provider, "aws_pinpoint_sms_channel", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_pinpoint_sms_channelHandler) Read(externalID string) (*Aws_pinpoint_sms_channel, error) {
	actual, err := bridge.Read(h.provider, "aws_pinpoint_sms_channel", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_pinpoint_sms_channelUnmapper(actual), nil
}

// Delete ...
func (h *Aws_pinpoint_sms_channelHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_pinpoint_sms_channel", externalID)
}

type Aws_athena_named_query struct {
     Aws_athena_named_query_id *string
     Name string
     Query string
     Database string
     Description *string
}


func Aws_athena_named_queryMapper(r *Aws_athena_named_query) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["name"] = r.Name
    config["query"] = r.Query
    config["database"] = r.Database
if r.Description != nil {
    config["description"] = *r.Description
}
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_athena_named_queryUnmapper(state map[string]interface{}) *Aws_athena_named_query {
	r := &Aws_athena_named_query{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_athena_named_query_id = &x
}

if x, ok := state["database"]; ok {
	r.Database = x.(string)
}

if x, ok := state["description"]; ok {
	x := x.(string)
	r.Description = &x
}

if x, ok := state["name"]; ok {
	r.Name = x.(string)
}

if x, ok := state["query"]; ok {
	r.Query = x.(string)
}
	return r
}


// Aws_athena_named_queryHandler ...
type Aws_athena_named_queryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_athena_named_queryHandler) Create(desired *Aws_athena_named_query) (*Aws_athena_named_query, string, error) {
	rState := Aws_athena_named_queryMapper(desired)
	id, err := bridge.Create(h.provider, "aws_athena_named_query", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_athena_named_queryHandler) Read(externalID string) (*Aws_athena_named_query, error) {
	actual, err := bridge.Read(h.provider, "aws_athena_named_query", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_athena_named_queryUnmapper(actual), nil
}

// Delete ...
func (h *Aws_athena_named_queryHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_athena_named_query", externalID)
}

type Aws_iam_group_policy_attachment struct {
     Aws_iam_group_policy_attachment_id *string
     Group string
     Policy_arn string
}


func Aws_iam_group_policy_attachmentMapper(r *Aws_iam_group_policy_attachment) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	    config["group"] = r.Group
    config["policy_arn"] = r.Policy_arn
return &terraform.ResourceConfig{
		Config: config,
	}
}

func Aws_iam_group_policy_attachmentUnmapper(state map[string]interface{}) *Aws_iam_group_policy_attachment {
	r := &Aws_iam_group_policy_attachment{}

if x, ok := state["external_id"]; ok {
	x := x.(string)
	r.Aws_iam_group_policy_attachment_id = &x
}

if x, ok := state["group"]; ok {
	r.Group = x.(string)
}

if x, ok := state["policy_arn"]; ok {
	r.Policy_arn = x.(string)
}
	return r
}


// Aws_iam_group_policy_attachmentHandler ...
type Aws_iam_group_policy_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Aws_iam_group_policy_attachmentHandler) Create(desired *Aws_iam_group_policy_attachment) (*Aws_iam_group_policy_attachment, string, error) {
	rState := Aws_iam_group_policy_attachmentMapper(desired)
	id, err := bridge.Create(h.provider, "aws_iam_group_policy_attachment", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Aws_iam_group_policy_attachmentHandler) Read(externalID string) (*Aws_iam_group_policy_attachment, error) {
	actual, err := bridge.Read(h.provider, "aws_iam_group_policy_attachment", externalID)
	if err != nil {
		return nil, err
	}
	return Aws_iam_group_policy_attachmentUnmapper(actual), nil
}

// Delete ...
func (h *Aws_iam_group_policy_attachmentHandler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "aws_iam_group_policy_attachment", externalID)
}

