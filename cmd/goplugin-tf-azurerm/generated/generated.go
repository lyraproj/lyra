// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package generated

import (
	"sync"

	"github.com/davecgh/go-spew/spew"
	"github.com/hashicorp/go-hclog"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/terraform"
	"github.com/lyraproj/lyra/pkg/bridge"
	"github.com/lyraproj/puppet-evaluator/eval"
	"github.com/lyraproj/servicesdk/service"
)

var once sync.Once
var Config *terraform.ResourceConfig

func configureProvider(p *schema.Provider) {
	once.Do(func() {
		if Config == nil {
			Config = &terraform.ResourceConfig{
				Config: map[string]interface{}{},
			}
		}
		err := p.Configure(Config)
		if err != nil {
			panic(err)
		}
	})
}

func Initialize(sb *service.ServerBuilder, p *schema.Provider) {
	var evs []eval.Type

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_api_management{}, Azurerm_api_management_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_api_managementHandler", &Azurerm_api_managementHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service{}, Azurerm_app_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_serviceHandler", &Azurerm_app_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service_active_slot{}, Azurerm_app_service_active_slot_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_service_active_slotHandler", &Azurerm_app_service_active_slotHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service_custom_hostname_binding{}, Azurerm_app_service_custom_hostname_binding_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_service_custom_hostname_bindingHandler", &Azurerm_app_service_custom_hostname_bindingHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service_plan{}, Azurerm_app_service_plan_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_service_planHandler", &Azurerm_app_service_planHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service_slot{}, Azurerm_app_service_slot_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_service_slotHandler", &Azurerm_app_service_slotHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_application_gateway{}, Azurerm_application_gateway_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_application_gatewayHandler", &Azurerm_application_gatewayHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_application_insights{}, Azurerm_application_insights_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_application_insightsHandler", &Azurerm_application_insightsHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_application_insights_api_key{}, Azurerm_application_insights_api_key_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_application_insights_api_keyHandler", &Azurerm_application_insights_api_keyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_application_security_group{}, Azurerm_application_security_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_application_security_groupHandler", &Azurerm_application_security_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_account{}, Azurerm_automation_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_accountHandler", &Azurerm_automation_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_credential{}, Azurerm_automation_credential_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_credentialHandler", &Azurerm_automation_credentialHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_dsc_configuration{}, Azurerm_automation_dsc_configuration_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_dsc_configurationHandler", &Azurerm_automation_dsc_configurationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_dsc_nodeconfiguration{}, Azurerm_automation_dsc_nodeconfiguration_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_dsc_nodeconfigurationHandler", &Azurerm_automation_dsc_nodeconfigurationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_module{}, Azurerm_automation_module_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_moduleHandler", &Azurerm_automation_moduleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_runbook{}, Azurerm_automation_runbook_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_runbookHandler", &Azurerm_automation_runbookHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_schedule{}, Azurerm_automation_schedule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_scheduleHandler", &Azurerm_automation_scheduleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_autoscale_setting{}, Azurerm_autoscale_setting_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_autoscale_settingHandler", &Azurerm_autoscale_settingHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_availability_set{}, Azurerm_availability_set_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_availability_setHandler", &Azurerm_availability_setHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_azuread_application{}, Azurerm_azuread_application_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_azuread_applicationHandler", &Azurerm_azuread_applicationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_azuread_service_principal{}, Azurerm_azuread_service_principal_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_azuread_service_principalHandler", &Azurerm_azuread_service_principalHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_azuread_service_principal_password{}, Azurerm_azuread_service_principal_password_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_azuread_service_principal_passwordHandler", &Azurerm_azuread_service_principal_passwordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_batch_account{}, Azurerm_batch_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_batch_accountHandler", &Azurerm_batch_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_batch_pool{}, Azurerm_batch_pool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_batch_poolHandler", &Azurerm_batch_poolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_cdn_endpoint{}, Azurerm_cdn_endpoint_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_cdn_endpointHandler", &Azurerm_cdn_endpointHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_cdn_profile{}, Azurerm_cdn_profile_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_cdn_profileHandler", &Azurerm_cdn_profileHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_cognitive_account{}, Azurerm_cognitive_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_cognitive_accountHandler", &Azurerm_cognitive_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_container_group{}, Azurerm_container_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_container_groupHandler", &Azurerm_container_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_container_registry{}, Azurerm_container_registry_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_container_registryHandler", &Azurerm_container_registryHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_container_service{}, Azurerm_container_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_container_serviceHandler", &Azurerm_container_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_cosmosdb_account{}, Azurerm_cosmosdb_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_cosmosdb_accountHandler", &Azurerm_cosmosdb_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_analytics_account{}, Azurerm_data_lake_analytics_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_analytics_accountHandler", &Azurerm_data_lake_analytics_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_analytics_firewall_rule{}, Azurerm_data_lake_analytics_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_analytics_firewall_ruleHandler", &Azurerm_data_lake_analytics_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_store{}, Azurerm_data_lake_store_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_storeHandler", &Azurerm_data_lake_storeHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_store_file{}, Azurerm_data_lake_store_file_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_store_fileHandler", &Azurerm_data_lake_store_fileHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_store_firewall_rule{}, Azurerm_data_lake_store_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_store_firewall_ruleHandler", &Azurerm_data_lake_store_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_databricks_workspace{}, Azurerm_databricks_workspace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_databricks_workspaceHandler", &Azurerm_databricks_workspaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_lab{}, Azurerm_dev_test_lab_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_labHandler", &Azurerm_dev_test_labHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_linux_virtual_machine{}, Azurerm_dev_test_linux_virtual_machine_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_linux_virtual_machineHandler", &Azurerm_dev_test_linux_virtual_machineHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_policy{}, Azurerm_dev_test_policy_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_policyHandler", &Azurerm_dev_test_policyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_virtual_network{}, Azurerm_dev_test_virtual_network_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_virtual_networkHandler", &Azurerm_dev_test_virtual_networkHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_windows_virtual_machine{}, Azurerm_dev_test_windows_virtual_machine_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_windows_virtual_machineHandler", &Azurerm_dev_test_windows_virtual_machineHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_devspace_controller{}, Azurerm_devspace_controller_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_devspace_controllerHandler", &Azurerm_devspace_controllerHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_a_record{}, Azurerm_dns_a_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_a_recordHandler", &Azurerm_dns_a_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_aaaa_record{}, Azurerm_dns_aaaa_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_aaaa_recordHandler", &Azurerm_dns_aaaa_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_caa_record{}, Azurerm_dns_caa_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_caa_recordHandler", &Azurerm_dns_caa_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_cname_record{}, Azurerm_dns_cname_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_cname_recordHandler", &Azurerm_dns_cname_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_mx_record{}, Azurerm_dns_mx_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_mx_recordHandler", &Azurerm_dns_mx_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_ns_record{}, Azurerm_dns_ns_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_ns_recordHandler", &Azurerm_dns_ns_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_ptr_record{}, Azurerm_dns_ptr_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_ptr_recordHandler", &Azurerm_dns_ptr_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_srv_record{}, Azurerm_dns_srv_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_srv_recordHandler", &Azurerm_dns_srv_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_txt_record{}, Azurerm_dns_txt_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_txt_recordHandler", &Azurerm_dns_txt_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_zone{}, Azurerm_dns_zone_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_zoneHandler", &Azurerm_dns_zoneHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventgrid_topic{}, Azurerm_eventgrid_topic_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventgrid_topicHandler", &Azurerm_eventgrid_topicHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub{}, Azurerm_eventhub_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhubHandler", &Azurerm_eventhubHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub_authorization_rule{}, Azurerm_eventhub_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhub_authorization_ruleHandler", &Azurerm_eventhub_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub_consumer_group{}, Azurerm_eventhub_consumer_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhub_consumer_groupHandler", &Azurerm_eventhub_consumer_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub_namespace{}, Azurerm_eventhub_namespace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhub_namespaceHandler", &Azurerm_eventhub_namespaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub_namespace_authorization_rule{}, Azurerm_eventhub_namespace_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhub_namespace_authorization_ruleHandler", &Azurerm_eventhub_namespace_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_express_route_circuit{}, Azurerm_express_route_circuit_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_express_route_circuitHandler", &Azurerm_express_route_circuitHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_express_route_circuit_authorization{}, Azurerm_express_route_circuit_authorization_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_express_route_circuit_authorizationHandler", &Azurerm_express_route_circuit_authorizationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_express_route_circuit_peering{}, Azurerm_express_route_circuit_peering_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_express_route_circuit_peeringHandler", &Azurerm_express_route_circuit_peeringHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_firewall{}, Azurerm_firewall_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_firewallHandler", &Azurerm_firewallHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_firewall_application_rule_collection{}, Azurerm_firewall_application_rule_collection_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_firewall_application_rule_collectionHandler", &Azurerm_firewall_application_rule_collectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_firewall_network_rule_collection{}, Azurerm_firewall_network_rule_collection_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_firewall_network_rule_collectionHandler", &Azurerm_firewall_network_rule_collectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_function_app{}, Azurerm_function_app_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_function_appHandler", &Azurerm_function_appHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_image{}, Azurerm_image_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_imageHandler", &Azurerm_imageHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_iothub{}, Azurerm_iothub_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_iothubHandler", &Azurerm_iothubHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_iothub_consumer_group{}, Azurerm_iothub_consumer_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_iothub_consumer_groupHandler", &Azurerm_iothub_consumer_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault{}, Azurerm_key_vault_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vaultHandler", &Azurerm_key_vaultHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault_access_policy{}, Azurerm_key_vault_access_policy_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vault_access_policyHandler", &Azurerm_key_vault_access_policyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault_certificate{}, Azurerm_key_vault_certificate_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vault_certificateHandler", &Azurerm_key_vault_certificateHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault_key{}, Azurerm_key_vault_key_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vault_keyHandler", &Azurerm_key_vault_keyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault_secret{}, Azurerm_key_vault_secret_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vault_secretHandler", &Azurerm_key_vault_secretHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_kubernetes_cluster{}, Azurerm_kubernetes_cluster_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_kubernetes_clusterHandler", &Azurerm_kubernetes_clusterHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb{}, Azurerm_lb_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lbHandler", &Azurerm_lbHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_backend_address_pool{}, Azurerm_lb_backend_address_pool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_backend_address_poolHandler", &Azurerm_lb_backend_address_poolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_nat_pool{}, Azurerm_lb_nat_pool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_nat_poolHandler", &Azurerm_lb_nat_poolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_nat_rule{}, Azurerm_lb_nat_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_nat_ruleHandler", &Azurerm_lb_nat_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_probe{}, Azurerm_lb_probe_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_probeHandler", &Azurerm_lb_probeHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_rule{}, Azurerm_lb_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_ruleHandler", &Azurerm_lb_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_local_network_gateway{}, Azurerm_local_network_gateway_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_local_network_gatewayHandler", &Azurerm_local_network_gatewayHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_log_analytics_solution{}, Azurerm_log_analytics_solution_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_log_analytics_solutionHandler", &Azurerm_log_analytics_solutionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_log_analytics_workspace{}, Azurerm_log_analytics_workspace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_log_analytics_workspaceHandler", &Azurerm_log_analytics_workspaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_log_analytics_workspace_linked_service{}, Azurerm_log_analytics_workspace_linked_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_log_analytics_workspace_linked_serviceHandler", &Azurerm_log_analytics_workspace_linked_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_action_custom{}, Azurerm_logic_app_action_custom_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_action_customHandler", &Azurerm_logic_app_action_customHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_action_http{}, Azurerm_logic_app_action_http_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_action_httpHandler", &Azurerm_logic_app_action_httpHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_trigger_custom{}, Azurerm_logic_app_trigger_custom_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_trigger_customHandler", &Azurerm_logic_app_trigger_customHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_trigger_http_request{}, Azurerm_logic_app_trigger_http_request_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_trigger_http_requestHandler", &Azurerm_logic_app_trigger_http_requestHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_trigger_recurrence{}, Azurerm_logic_app_trigger_recurrence_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_trigger_recurrenceHandler", &Azurerm_logic_app_trigger_recurrenceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_workflow{}, Azurerm_logic_app_workflow_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_workflowHandler", &Azurerm_logic_app_workflowHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_managed_disk{}, Azurerm_managed_disk_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_managed_diskHandler", &Azurerm_managed_diskHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_management_group{}, Azurerm_management_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_management_groupHandler", &Azurerm_management_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_management_lock{}, Azurerm_management_lock_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_management_lockHandler", &Azurerm_management_lockHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mariadb_database{}, Azurerm_mariadb_database_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mariadb_databaseHandler", &Azurerm_mariadb_databaseHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mariadb_server{}, Azurerm_mariadb_server_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mariadb_serverHandler", &Azurerm_mariadb_serverHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_metric_alertrule{}, Azurerm_metric_alertrule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_metric_alertruleHandler", &Azurerm_metric_alertruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_action_group{}, Azurerm_monitor_action_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_action_groupHandler", &Azurerm_monitor_action_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_activity_log_alert{}, Azurerm_monitor_activity_log_alert_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_activity_log_alertHandler", &Azurerm_monitor_activity_log_alertHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_diagnostic_setting{}, Azurerm_monitor_diagnostic_setting_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_diagnostic_settingHandler", &Azurerm_monitor_diagnostic_settingHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_log_profile{}, Azurerm_monitor_log_profile_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_log_profileHandler", &Azurerm_monitor_log_profileHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_metric_alert{}, Azurerm_monitor_metric_alert_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_metric_alertHandler", &Azurerm_monitor_metric_alertHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mssql_elasticpool{}, Azurerm_mssql_elasticpool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mssql_elasticpoolHandler", &Azurerm_mssql_elasticpoolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_configuration{}, Azurerm_mysql_configuration_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_configurationHandler", &Azurerm_mysql_configurationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_database{}, Azurerm_mysql_database_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_databaseHandler", &Azurerm_mysql_databaseHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_firewall_rule{}, Azurerm_mysql_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_firewall_ruleHandler", &Azurerm_mysql_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_server{}, Azurerm_mysql_server_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_serverHandler", &Azurerm_mysql_serverHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_virtual_network_rule{}, Azurerm_mysql_virtual_network_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_virtual_network_ruleHandler", &Azurerm_mysql_virtual_network_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_interface{}, Azurerm_network_interface_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_interfaceHandler", &Azurerm_network_interfaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_interface_application_gateway_backend_address_pool_association{}, Azurerm_network_interface_application_gateway_backend_address_pool_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler", &Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_interface_backend_address_pool_association{}, Azurerm_network_interface_backend_address_pool_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_interface_backend_address_pool_associationHandler", &Azurerm_network_interface_backend_address_pool_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_interface_nat_rule_association{}, Azurerm_network_interface_nat_rule_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_interface_nat_rule_associationHandler", &Azurerm_network_interface_nat_rule_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_security_group{}, Azurerm_network_security_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_security_groupHandler", &Azurerm_network_security_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_security_rule{}, Azurerm_network_security_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_security_ruleHandler", &Azurerm_network_security_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_watcher{}, Azurerm_network_watcher_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_watcherHandler", &Azurerm_network_watcherHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_notification_hub{}, Azurerm_notification_hub_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_notification_hubHandler", &Azurerm_notification_hubHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_notification_hub_authorization_rule{}, Azurerm_notification_hub_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_notification_hub_authorization_ruleHandler", &Azurerm_notification_hub_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_notification_hub_namespace{}, Azurerm_notification_hub_namespace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_notification_hub_namespaceHandler", &Azurerm_notification_hub_namespaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_packet_capture{}, Azurerm_packet_capture_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_packet_captureHandler", &Azurerm_packet_captureHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_policy_assignment{}, Azurerm_policy_assignment_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_policy_assignmentHandler", &Azurerm_policy_assignmentHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_policy_definition{}, Azurerm_policy_definition_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_policy_definitionHandler", &Azurerm_policy_definitionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_policy_set_definition{}, Azurerm_policy_set_definition_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_policy_set_definitionHandler", &Azurerm_policy_set_definitionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_configuration{}, Azurerm_postgresql_configuration_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_configurationHandler", &Azurerm_postgresql_configurationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_database{}, Azurerm_postgresql_database_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_databaseHandler", &Azurerm_postgresql_databaseHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_firewall_rule{}, Azurerm_postgresql_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_firewall_ruleHandler", &Azurerm_postgresql_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_server{}, Azurerm_postgresql_server_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_serverHandler", &Azurerm_postgresql_serverHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_virtual_network_rule{}, Azurerm_postgresql_virtual_network_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_virtual_network_ruleHandler", &Azurerm_postgresql_virtual_network_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_public_ip{}, Azurerm_public_ip_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_public_ipHandler", &Azurerm_public_ipHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_recovery_services_protected_vm{}, Azurerm_recovery_services_protected_vm_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_recovery_services_protected_vmHandler", &Azurerm_recovery_services_protected_vmHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_recovery_services_protection_policy_vm{}, Azurerm_recovery_services_protection_policy_vm_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_recovery_services_protection_policy_vmHandler", &Azurerm_recovery_services_protection_policy_vmHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_recovery_services_vault{}, Azurerm_recovery_services_vault_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_recovery_services_vaultHandler", &Azurerm_recovery_services_vaultHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_redis_cache{}, Azurerm_redis_cache_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_redis_cacheHandler", &Azurerm_redis_cacheHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_redis_firewall_rule{}, Azurerm_redis_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_redis_firewall_ruleHandler", &Azurerm_redis_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_relay_namespace{}, Azurerm_relay_namespace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_relay_namespaceHandler", &Azurerm_relay_namespaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_resource_group{}, Azurerm_resource_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_resource_groupHandler", &Azurerm_resource_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_role_assignment{}, Azurerm_role_assignment_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_role_assignmentHandler", &Azurerm_role_assignmentHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_role_definition{}, Azurerm_role_definition_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_role_definitionHandler", &Azurerm_role_definitionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_route{}, Azurerm_route_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_routeHandler", &Azurerm_routeHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_route_table{}, Azurerm_route_table_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_route_tableHandler", &Azurerm_route_tableHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_scheduler_job{}, Azurerm_scheduler_job_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_scheduler_jobHandler", &Azurerm_scheduler_jobHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_scheduler_job_collection{}, Azurerm_scheduler_job_collection_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_scheduler_job_collectionHandler", &Azurerm_scheduler_job_collectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_search_service{}, Azurerm_search_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_search_serviceHandler", &Azurerm_search_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_security_center_contact{}, Azurerm_security_center_contact_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_security_center_contactHandler", &Azurerm_security_center_contactHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_security_center_subscription_pricing{}, Azurerm_security_center_subscription_pricing_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_security_center_subscription_pricingHandler", &Azurerm_security_center_subscription_pricingHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_security_center_workspace{}, Azurerm_security_center_workspace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_security_center_workspaceHandler", &Azurerm_security_center_workspaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_service_fabric_cluster{}, Azurerm_service_fabric_cluster_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_service_fabric_clusterHandler", &Azurerm_service_fabric_clusterHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_namespace{}, Azurerm_servicebus_namespace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_namespaceHandler", &Azurerm_servicebus_namespaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_namespace_authorization_rule{}, Azurerm_servicebus_namespace_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_namespace_authorization_ruleHandler", &Azurerm_servicebus_namespace_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_queue{}, Azurerm_servicebus_queue_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_queueHandler", &Azurerm_servicebus_queueHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_queue_authorization_rule{}, Azurerm_servicebus_queue_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_queue_authorization_ruleHandler", &Azurerm_servicebus_queue_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_subscription{}, Azurerm_servicebus_subscription_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_subscriptionHandler", &Azurerm_servicebus_subscriptionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_subscription_rule{}, Azurerm_servicebus_subscription_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_subscription_ruleHandler", &Azurerm_servicebus_subscription_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_topic{}, Azurerm_servicebus_topic_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_topicHandler", &Azurerm_servicebus_topicHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_topic_authorization_rule{}, Azurerm_servicebus_topic_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_topic_authorization_ruleHandler", &Azurerm_servicebus_topic_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_shared_image{}, Azurerm_shared_image_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_shared_imageHandler", &Azurerm_shared_imageHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_shared_image_gallery{}, Azurerm_shared_image_gallery_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_shared_image_galleryHandler", &Azurerm_shared_image_galleryHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_shared_image_version{}, Azurerm_shared_image_version_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_shared_image_versionHandler", &Azurerm_shared_image_versionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_signalr_service{}, Azurerm_signalr_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_signalr_serviceHandler", &Azurerm_signalr_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_snapshot{}, Azurerm_snapshot_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_snapshotHandler", &Azurerm_snapshotHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_active_directory_administrator{}, Azurerm_sql_active_directory_administrator_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_active_directory_administratorHandler", &Azurerm_sql_active_directory_administratorHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_database{}, Azurerm_sql_database_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_databaseHandler", &Azurerm_sql_databaseHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_elasticpool{}, Azurerm_sql_elasticpool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_elasticpoolHandler", &Azurerm_sql_elasticpoolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_firewall_rule{}, Azurerm_sql_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_firewall_ruleHandler", &Azurerm_sql_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_server{}, Azurerm_sql_server_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_serverHandler", &Azurerm_sql_serverHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_virtual_network_rule{}, Azurerm_sql_virtual_network_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_virtual_network_ruleHandler", &Azurerm_sql_virtual_network_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_account{}, Azurerm_storage_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_accountHandler", &Azurerm_storage_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_blob{}, Azurerm_storage_blob_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_blobHandler", &Azurerm_storage_blobHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_container{}, Azurerm_storage_container_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_containerHandler", &Azurerm_storage_containerHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_queue{}, Azurerm_storage_queue_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_queueHandler", &Azurerm_storage_queueHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_share{}, Azurerm_storage_share_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_shareHandler", &Azurerm_storage_shareHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_table{}, Azurerm_storage_table_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_tableHandler", &Azurerm_storage_tableHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_subnet{}, Azurerm_subnet_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_subnetHandler", &Azurerm_subnetHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_subnet_network_security_group_association{}, Azurerm_subnet_network_security_group_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_subnet_network_security_group_associationHandler", &Azurerm_subnet_network_security_group_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_subnet_route_table_association{}, Azurerm_subnet_route_table_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_subnet_route_table_associationHandler", &Azurerm_subnet_route_table_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_template_deployment{}, Azurerm_template_deployment_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_template_deploymentHandler", &Azurerm_template_deploymentHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_traffic_manager_endpoint{}, Azurerm_traffic_manager_endpoint_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_traffic_manager_endpointHandler", &Azurerm_traffic_manager_endpointHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_traffic_manager_profile{}, Azurerm_traffic_manager_profile_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_traffic_manager_profileHandler", &Azurerm_traffic_manager_profileHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_user_assigned_identity{}, Azurerm_user_assigned_identity_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_user_assigned_identityHandler", &Azurerm_user_assigned_identityHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_machine{}, Azurerm_virtual_machine_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_machineHandler", &Azurerm_virtual_machineHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_machine_data_disk_attachment{}, Azurerm_virtual_machine_data_disk_attachment_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_machine_data_disk_attachmentHandler", &Azurerm_virtual_machine_data_disk_attachmentHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_machine_extension{}, Azurerm_virtual_machine_extension_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_machine_extensionHandler", &Azurerm_virtual_machine_extensionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_machine_scale_set{}, Azurerm_virtual_machine_scale_set_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_machine_scale_setHandler", &Azurerm_virtual_machine_scale_setHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_network{}, Azurerm_virtual_network_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_networkHandler", &Azurerm_virtual_networkHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_network_gateway{}, Azurerm_virtual_network_gateway_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_network_gatewayHandler", &Azurerm_virtual_network_gatewayHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_network_gateway_connection{}, Azurerm_virtual_network_gateway_connection_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_network_gateway_connectionHandler", &Azurerm_virtual_network_gateway_connectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_network_peering{}, Azurerm_virtual_network_peering_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_network_peeringHandler", &Azurerm_virtual_network_peeringHandler{provider: p}, evs[0])

}

type Azurerm_api_management_additional_location_1 struct {


    Gateway_regional_url *string

    Location string

    Public_ip_addresses *[]string

}

type Azurerm_api_management_certificate_2 struct {


    Certificate_password string

    Encoded_certificate string

    Store_name string

}

type Azurerm_api_management_hostname_configuration_3_management_4 struct {


    Certificate *string

    Certificate_password *string

    Host_name string

    Key_vault_id *string

    Negotiate_client_certificate *bool

}

type Azurerm_api_management_hostname_configuration_3_portal_5 struct {


    Certificate *string

    Certificate_password *string

    Host_name string

    Key_vault_id *string

    Negotiate_client_certificate *bool

}

type Azurerm_api_management_hostname_configuration_3_proxy_6 struct {


    Certificate *string

    Certificate_password *string

    Default_ssl_binding *bool

    Host_name string

    Key_vault_id *string

    Negotiate_client_certificate *bool

}

type Azurerm_api_management_hostname_configuration_3_scm_7 struct {


    Certificate *string

    Certificate_password *string

    Host_name string

    Key_vault_id *string

    Negotiate_client_certificate *bool

}

type Azurerm_api_management_hostname_configuration_3 struct {


    Management *[]Azurerm_api_management_hostname_configuration_3_management_4

    Portal *[]Azurerm_api_management_hostname_configuration_3_portal_5

    Proxy *[]Azurerm_api_management_hostname_configuration_3_proxy_6

    Scm *[]Azurerm_api_management_hostname_configuration_3_scm_7

}

type Azurerm_api_management_identity_8 struct {


    Principal_id *string

    Tenant_id *string

    Type string

}

type Azurerm_api_management_security_9 struct {


    Disable_backend_ssl30 *bool

    Disable_backend_tls10 *bool

    Disable_backend_tls11 *bool

    Disable_frontend_ssl30 *bool

    Disable_frontend_tls10 *bool

    Disable_frontend_tls11 *bool

    Disable_triple_des_chipers *bool

}

type Azurerm_api_management_sku_10 struct {


    Capacity int

    Name string

}

type Azurerm_api_management struct {

	Azurerm_api_management_id *string `lyra:"ignore"`

    Additional_location *[]Azurerm_api_management_additional_location_1

    Certificate *[]Azurerm_api_management_certificate_2

    Gateway_regional_url *string

    Gateway_url *string

    Hostname_configuration *[]Azurerm_api_management_hostname_configuration_3

    Identity *[]Azurerm_api_management_identity_8

    Location string

    Management_api_url *string

    Name string

    Notification_sender_email *string

    Portal_url *string

    Public_ip_addresses *[]string

    Publisher_email string

    Publisher_name string

    Resource_group_name string

    Scm_url *string

    Security *[]Azurerm_api_management_security_9

    Sku []Azurerm_api_management_sku_10

    Tags *map[string]string

}

var Azurerm_api_management_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_api_management_id",

		"additional_location",

		"certificate",

		"gateway_regional_url",

		"gateway_url",

		"hostname_configuration",

		"identity",

		"management_api_url",

		"notification_sender_email",

		"portal_url",

		"public_ip_addresses",

		"scm_url",

		"security",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_api_managementHandler ...
type Azurerm_api_managementHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_api_managementHandler) Create(desired *Azurerm_api_management) (*Azurerm_api_management, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_api_management", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_api_management", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_api_managementHandler) Update(externalID string, desired *Azurerm_api_management) (*Azurerm_api_management, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_api_management", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_api_management", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_api_management{ Azurerm_api_management_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_api_management", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_api_managementHandler) Read(externalID string) (*Azurerm_api_management, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_api_management", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_api_management", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_api_management{ Azurerm_api_management_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_api_management", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_api_managementHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_api_management", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_api_management", externalID)
}

type Azurerm_app_service_connection_string_11 struct {


    Name string

    Type string

    Value string

}

type Azurerm_app_service_identity_12 struct {


    Principal_id *string

    Tenant_id *string

    Type string

}

type Azurerm_app_service_site_config_13_ip_restriction_14 struct {


    Ip_address string

    Subnet_mask *string

}

type Azurerm_app_service_site_config_13 struct {


    Always_on *bool

    App_command_line *string

    Default_documents *[]string

    Dotnet_framework_version *string

    Ftps_state *string

    Http2_enabled *bool

    Ip_restriction *[]Azurerm_app_service_site_config_13_ip_restriction_14

    Java_container *string

    Java_container_version *string

    Java_version *string

    Linux_fx_version *string

    Local_mysql_enabled *bool

    Managed_pipeline_mode *string

    Min_tls_version *string

    Php_version *string

    Python_version *string

    Remote_debugging_enabled *bool

    Remote_debugging_version *string

    Scm_type *string

    Use_32_bit_worker_process *bool

    Virtual_network_name *string

    Websockets_enabled *bool

}

type Azurerm_app_service_site_credential_15 struct {


    Password *string

    Username *string

}

type Azurerm_app_service_source_control_16 struct {


    Branch *string

    Repo_url *string

}

type Azurerm_app_service struct {

	Azurerm_app_service_id *string `lyra:"ignore"`

    App_service_plan_id string

    App_settings *map[string]string

    Client_affinity_enabled *bool

    Connection_string *[]Azurerm_app_service_connection_string_11

    Default_site_hostname *string

    Enabled *bool

    Https_only *bool

    Identity *[]Azurerm_app_service_identity_12

    Location string

    Name string

    Outbound_ip_addresses *string

    Possible_outbound_ip_addresses *string

    Resource_group_name string

    Site_config *[]Azurerm_app_service_site_config_13

    Site_credential *[]Azurerm_app_service_site_credential_15

    Source_control *[]Azurerm_app_service_source_control_16

    Tags *map[string]string

}

var Azurerm_app_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_id",

		"app_settings",

		"client_affinity_enabled",

		"connection_string",

		"default_site_hostname",

		"enabled",

		"https_only",

		"identity",

		"outbound_ip_addresses",

		"possible_outbound_ip_addresses",

		"site_config",

		"site_credential",

		"source_control",

		"tags",

	)
	rtb.ImmutableAttributes(

		"app_service_plan_id",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_app_serviceHandler ...
type Azurerm_app_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_serviceHandler) Create(desired *Azurerm_app_service) (*Azurerm_app_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_serviceHandler) Update(externalID string, desired *Azurerm_app_service) (*Azurerm_app_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service{ Azurerm_app_service_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_serviceHandler) Read(externalID string) (*Azurerm_app_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service{ Azurerm_app_service_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service", externalID)
}

type Azurerm_app_service_active_slot struct {

	Azurerm_app_service_active_slot_id *string `lyra:"ignore"`

    App_service_name string

    App_service_slot_name string

    Resource_group_name string

}

var Azurerm_app_service_active_slot_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_active_slot_id",

	)
	rtb.ImmutableAttributes(

		"app_service_name",

		"resource_group_name",

	)
}

// Azurerm_app_service_active_slotHandler ...
type Azurerm_app_service_active_slotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_service_active_slotHandler) Create(desired *Azurerm_app_service_active_slot) (*Azurerm_app_service_active_slot, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service_active_slot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service_active_slot", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_service_active_slotHandler) Update(externalID string, desired *Azurerm_app_service_active_slot) (*Azurerm_app_service_active_slot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service_active_slot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service_active_slot", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_active_slot{ Azurerm_app_service_active_slot_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service_active_slot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_service_active_slotHandler) Read(externalID string) (*Azurerm_app_service_active_slot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service_active_slot", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service_active_slot", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_active_slot{ Azurerm_app_service_active_slot_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service_active_slot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_service_active_slotHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service_active_slot", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service_active_slot", externalID)
}

type Azurerm_app_service_custom_hostname_binding struct {

	Azurerm_app_service_custom_hostname_binding_id *string `lyra:"ignore"`

    App_service_name string

    Hostname string

    Resource_group_name string

}

var Azurerm_app_service_custom_hostname_binding_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_custom_hostname_binding_id",

	)
	rtb.ImmutableAttributes(

		"app_service_name",

		"hostname",

		"resource_group_name",

	)
}

// Azurerm_app_service_custom_hostname_bindingHandler ...
type Azurerm_app_service_custom_hostname_bindingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_service_custom_hostname_bindingHandler) Create(desired *Azurerm_app_service_custom_hostname_binding) (*Azurerm_app_service_custom_hostname_binding, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service_custom_hostname_binding", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service_custom_hostname_binding", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_service_custom_hostname_bindingHandler) Update(externalID string, desired *Azurerm_app_service_custom_hostname_binding) (*Azurerm_app_service_custom_hostname_binding, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service_custom_hostname_binding", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service_custom_hostname_binding", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_custom_hostname_binding{ Azurerm_app_service_custom_hostname_binding_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service_custom_hostname_binding", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_service_custom_hostname_bindingHandler) Read(externalID string) (*Azurerm_app_service_custom_hostname_binding, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service_custom_hostname_binding", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service_custom_hostname_binding", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_custom_hostname_binding{ Azurerm_app_service_custom_hostname_binding_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service_custom_hostname_binding", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_service_custom_hostname_bindingHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service_custom_hostname_binding", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service_custom_hostname_binding", externalID)
}

type Azurerm_app_service_plan_properties_17 struct {


    App_service_environment_id *string

    Per_site_scaling *bool

    Reserved *bool

}

type Azurerm_app_service_plan_sku_18 struct {


    Capacity *int

    Size string

    Tier string

}

type Azurerm_app_service_plan struct {

	Azurerm_app_service_plan_id *string `lyra:"ignore"`

    App_service_environment_id *string

    Kind *string

    Location string

    Maximum_number_of_workers *int

    Name string

    Per_site_scaling *bool

    Properties *[]Azurerm_app_service_plan_properties_17

    Reserved *bool

    Resource_group_name string

    Sku []Azurerm_app_service_plan_sku_18

    Tags *map[string]string

}

var Azurerm_app_service_plan_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_plan_id",

		"app_service_environment_id",

		"kind",

		"maximum_number_of_workers",

		"per_site_scaling",

		"properties",

		"reserved",

		"tags",

	)
	rtb.ImmutableAttributes(

		"app_service_environment_id",

		"kind",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_app_service_planHandler ...
type Azurerm_app_service_planHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_service_planHandler) Create(desired *Azurerm_app_service_plan) (*Azurerm_app_service_plan, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service_plan", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service_plan", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_service_planHandler) Update(externalID string, desired *Azurerm_app_service_plan) (*Azurerm_app_service_plan, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service_plan", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service_plan", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_plan{ Azurerm_app_service_plan_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service_plan", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_service_planHandler) Read(externalID string) (*Azurerm_app_service_plan, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service_plan", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service_plan", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_plan{ Azurerm_app_service_plan_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service_plan", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_service_planHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service_plan", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service_plan", externalID)
}

type Azurerm_app_service_slot_connection_string_19 struct {


    Name string

    Type string

    Value string

}

type Azurerm_app_service_slot_identity_20 struct {


    Principal_id *string

    Tenant_id *string

    Type string

}

type Azurerm_app_service_slot_site_config_21_ip_restriction_22 struct {


    Ip_address string

    Subnet_mask *string

}

type Azurerm_app_service_slot_site_config_21 struct {


    Always_on *bool

    App_command_line *string

    Default_documents *[]string

    Dotnet_framework_version *string

    Ftps_state *string

    Http2_enabled *bool

    Ip_restriction *[]Azurerm_app_service_slot_site_config_21_ip_restriction_22

    Java_container *string

    Java_container_version *string

    Java_version *string

    Linux_fx_version *string

    Local_mysql_enabled *bool

    Managed_pipeline_mode *string

    Min_tls_version *string

    Php_version *string

    Python_version *string

    Remote_debugging_enabled *bool

    Remote_debugging_version *string

    Scm_type *string

    Use_32_bit_worker_process *bool

    Virtual_network_name *string

    Websockets_enabled *bool

}

type Azurerm_app_service_slot struct {

	Azurerm_app_service_slot_id *string `lyra:"ignore"`

    App_service_name string

    App_service_plan_id string

    App_settings *map[string]string

    Client_affinity_enabled *bool

    Connection_string *[]Azurerm_app_service_slot_connection_string_19

    Default_site_hostname *string

    Enabled *bool

    Https_only *bool

    Identity *[]Azurerm_app_service_slot_identity_20

    Location string

    Name string

    Resource_group_name string

    Site_config *[]Azurerm_app_service_slot_site_config_21

    Tags *map[string]string

}

var Azurerm_app_service_slot_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_slot_id",

		"app_settings",

		"client_affinity_enabled",

		"connection_string",

		"default_site_hostname",

		"enabled",

		"https_only",

		"identity",

		"site_config",

		"tags",

	)
	rtb.ImmutableAttributes(

		"app_service_name",

		"app_service_plan_id",

		"identity",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_app_service_slotHandler ...
type Azurerm_app_service_slotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_service_slotHandler) Create(desired *Azurerm_app_service_slot) (*Azurerm_app_service_slot, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service_slot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service_slot", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_service_slotHandler) Update(externalID string, desired *Azurerm_app_service_slot) (*Azurerm_app_service_slot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service_slot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service_slot", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_slot{ Azurerm_app_service_slot_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service_slot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_service_slotHandler) Read(externalID string) (*Azurerm_app_service_slot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service_slot", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service_slot", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_slot{ Azurerm_app_service_slot_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service_slot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_service_slotHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service_slot", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service_slot", externalID)
}

type Azurerm_application_gateway_authentication_certificate_23 struct {


    Data string

    Id *string

    Name string

}

type Azurerm_application_gateway_backend_address_pool_24 struct {


    Fqdn_list *[]string

    Id *string

    Ip_address_list *[]string

    Name string

}

type Azurerm_application_gateway_backend_http_settings_25_authentication_certificate_26 struct {


    Id *string

    Name string

}

type Azurerm_application_gateway_backend_http_settings_25 struct {


    Authentication_certificate *[]Azurerm_application_gateway_backend_http_settings_25_authentication_certificate_26

    Cookie_based_affinity string

    Id *string

    Name string

    Port int

    Probe_id *string

    Probe_name *string

    Protocol string

    Request_timeout *int

}

type Azurerm_application_gateway_frontend_ip_configuration_27 struct {


    Id *string

    Name string

    Private_ip_address *string

    Private_ip_address_allocation *string

    Public_ip_address_id *string

    Subnet_id *string

}

type Azurerm_application_gateway_frontend_port_28 struct {


    Id *string

    Name string

    Port int

}

type Azurerm_application_gateway_gateway_ip_configuration_29 struct {


    Id *string

    Name string

    Subnet_id string

}

type Azurerm_application_gateway_http_listener_30 struct {


    Frontend_ip_configuration_id *string

    Frontend_ip_configuration_name string

    Frontend_port_id *string

    Frontend_port_name string

    Host_name *string

    Id *string

    Name string

    Protocol string

    Require_sni *bool

    Ssl_certificate_id *string

    Ssl_certificate_name *string

}

type Azurerm_application_gateway_probe_31_match_32 struct {


    Body *string

    Status_code *[]string

}

type Azurerm_application_gateway_probe_31 struct {


    Host string

    Id *string

    Interval int

    Match *[]Azurerm_application_gateway_probe_31_match_32

    Minimum_servers *int

    Name string

    Path string

    Protocol string

    Timeout int

    Unhealthy_threshold int

}

type Azurerm_application_gateway_request_routing_rule_33 struct {


    Backend_address_pool_id *string

    Backend_address_pool_name *string

    Backend_http_settings_id *string

    Backend_http_settings_name *string

    Http_listener_id *string

    Http_listener_name string

    Id *string

    Name string

    Rule_type string

    Url_path_map_id *string

    Url_path_map_name *string

}

type Azurerm_application_gateway_sku_34 struct {


    Capacity int

    Name string

    Tier string

}

type Azurerm_application_gateway_ssl_certificate_35 struct {


    Data string

    Id *string

    Name string

    Password string

    Public_cert_data *string

}

type Azurerm_application_gateway_url_path_map_36_path_rule_37 struct {


    Backend_address_pool_id *string

    Backend_address_pool_name string

    Backend_http_settings_id *string

    Backend_http_settings_name string

    Id *string

    Name string

    Paths []string

}

type Azurerm_application_gateway_url_path_map_36 struct {


    Default_backend_address_pool_id *string

    Default_backend_address_pool_name string

    Default_backend_http_settings_id *string

    Default_backend_http_settings_name string

    Id *string

    Name string

    Path_rule []Azurerm_application_gateway_url_path_map_36_path_rule_37

}

type Azurerm_application_gateway_waf_configuration_38 struct {


    Enabled bool

    Firewall_mode string

    Rule_set_type *string

    Rule_set_version string

}

type Azurerm_application_gateway struct {

	Azurerm_application_gateway_id *string `lyra:"ignore"`

    Authentication_certificate *[]Azurerm_application_gateway_authentication_certificate_23

    Backend_address_pool []Azurerm_application_gateway_backend_address_pool_24

    Backend_http_settings []Azurerm_application_gateway_backend_http_settings_25

    Disabled_ssl_protocols *[]string

    Frontend_ip_configuration []Azurerm_application_gateway_frontend_ip_configuration_27

    Frontend_port []Azurerm_application_gateway_frontend_port_28

    Gateway_ip_configuration []Azurerm_application_gateway_gateway_ip_configuration_29

    Http_listener []Azurerm_application_gateway_http_listener_30

    Location string

    Name string

    Probe *[]Azurerm_application_gateway_probe_31

    Request_routing_rule []Azurerm_application_gateway_request_routing_rule_33

    Resource_group_name string

    Sku []Azurerm_application_gateway_sku_34

    Ssl_certificate *[]Azurerm_application_gateway_ssl_certificate_35

    Tags *map[string]string

    Url_path_map *[]Azurerm_application_gateway_url_path_map_36

    Waf_configuration *[]Azurerm_application_gateway_waf_configuration_38

}

var Azurerm_application_gateway_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_application_gateway_id",

		"authentication_certificate",

		"disabled_ssl_protocols",

		"probe",

		"ssl_certificate",

		"tags",

		"url_path_map",

		"waf_configuration",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_application_gatewayHandler ...
type Azurerm_application_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_application_gatewayHandler) Create(desired *Azurerm_application_gateway) (*Azurerm_application_gateway, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_application_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_application_gateway", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_application_gatewayHandler) Update(externalID string, desired *Azurerm_application_gateway) (*Azurerm_application_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_application_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_application_gateway", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_gateway{ Azurerm_application_gateway_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_application_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_application_gatewayHandler) Read(externalID string) (*Azurerm_application_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_application_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_application_gateway", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_gateway{ Azurerm_application_gateway_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_application_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_application_gatewayHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_application_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_application_gateway", externalID)
}

type Azurerm_application_insights struct {

	Azurerm_application_insights_id *string `lyra:"ignore"`

    App_id *string

    Application_type string

    Instrumentation_key *string

    Location string

    Name string

    Resource_group_name string

    Tags *map[string]string

}

var Azurerm_application_insights_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_application_insights_id",

		"app_id",

		"instrumentation_key",

		"tags",

	)
	rtb.ImmutableAttributes(

		"application_type",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_application_insightsHandler ...
type Azurerm_application_insightsHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_application_insightsHandler) Create(desired *Azurerm_application_insights) (*Azurerm_application_insights, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_application_insights", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_application_insights", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_application_insightsHandler) Update(externalID string, desired *Azurerm_application_insights) (*Azurerm_application_insights, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_application_insights", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_application_insights", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_insights{ Azurerm_application_insights_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_application_insights", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_application_insightsHandler) Read(externalID string) (*Azurerm_application_insights, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_application_insights", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_application_insights", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_insights{ Azurerm_application_insights_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_application_insights", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_application_insightsHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_application_insights", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_application_insights", externalID)
}

type Azurerm_application_insights_api_key struct {

	Azurerm_application_insights_api_key_id *string `lyra:"ignore"`

    Api_key *string

    Application_insights_id string

    Name string

    Read_permissions *[]string

    Write_permissions *[]string

}

var Azurerm_application_insights_api_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_application_insights_api_key_id",

		"api_key",

		"read_permissions",

		"write_permissions",

	)
	rtb.ImmutableAttributes(

		"application_insights_id",

		"name",

		"read_permissions",

		"write_permissions",

	)
}

// Azurerm_application_insights_api_keyHandler ...
type Azurerm_application_insights_api_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_application_insights_api_keyHandler) Create(desired *Azurerm_application_insights_api_key) (*Azurerm_application_insights_api_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_application_insights_api_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_application_insights_api_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_application_insights_api_keyHandler) Update(externalID string, desired *Azurerm_application_insights_api_key) (*Azurerm_application_insights_api_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_application_insights_api_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_application_insights_api_key", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_insights_api_key{ Azurerm_application_insights_api_key_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_application_insights_api_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_application_insights_api_keyHandler) Read(externalID string) (*Azurerm_application_insights_api_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_application_insights_api_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_application_insights_api_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_insights_api_key{ Azurerm_application_insights_api_key_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_application_insights_api_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_application_insights_api_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_application_insights_api_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_application_insights_api_key", externalID)
}

type Azurerm_application_security_group struct {

	Azurerm_application_security_group_id *string `lyra:"ignore"`

    Location string

    Name string

    Resource_group_name string

    Tags *map[string]string

}

var Azurerm_application_security_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_application_security_group_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_application_security_groupHandler ...
type Azurerm_application_security_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_application_security_groupHandler) Create(desired *Azurerm_application_security_group) (*Azurerm_application_security_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_application_security_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_application_security_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_application_security_groupHandler) Update(externalID string, desired *Azurerm_application_security_group) (*Azurerm_application_security_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_application_security_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_application_security_group", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_security_group{ Azurerm_application_security_group_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_application_security_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_application_security_groupHandler) Read(externalID string) (*Azurerm_application_security_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_application_security_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_application_security_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_security_group{ Azurerm_application_security_group_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_application_security_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_application_security_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_application_security_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_application_security_group", externalID)
}

type Azurerm_automation_account_sku_39 struct {


    Name *string

}

type Azurerm_automation_account struct {

	Azurerm_automation_account_id *string `lyra:"ignore"`

    Dsc_primary_access_key *string

    Dsc_secondary_access_key *string

    Dsc_server_endpoint *string

    Location string

    Name string

    Resource_group_name string

    Sku []Azurerm_automation_account_sku_39

    Tags *map[string]string

}

var Azurerm_automation_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_account_id",

		"dsc_primary_access_key",

		"dsc_secondary_access_key",

		"dsc_server_endpoint",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_automation_accountHandler ...
type Azurerm_automation_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_accountHandler) Create(desired *Azurerm_automation_account) (*Azurerm_automation_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_accountHandler) Update(externalID string, desired *Azurerm_automation_account) (*Azurerm_automation_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_account", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_account{ Azurerm_automation_account_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_accountHandler) Read(externalID string) (*Azurerm_automation_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_account{ Azurerm_automation_account_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_account", externalID)
}

type Azurerm_automation_credential struct {

	Azurerm_automation_credential_id *string `lyra:"ignore"`

    Account_name string

    Description *string

    Name string

    Password string

    Resource_group_name string

    Username string

}

var Azurerm_automation_credential_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_credential_id",

		"description",

	)
	rtb.ImmutableAttributes(

		"account_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_automation_credentialHandler ...
type Azurerm_automation_credentialHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_credentialHandler) Create(desired *Azurerm_automation_credential) (*Azurerm_automation_credential, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_credential", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_credential", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_credentialHandler) Update(externalID string, desired *Azurerm_automation_credential) (*Azurerm_automation_credential, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_credential", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_credential", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_credential{ Azurerm_automation_credential_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_credential", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_credentialHandler) Read(externalID string) (*Azurerm_automation_credential, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_credential", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_credential", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_credential{ Azurerm_automation_credential_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_credential", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_credentialHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_credential", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_credential", externalID)
}

type Azurerm_automation_dsc_configuration struct {

	Azurerm_automation_dsc_configuration_id *string `lyra:"ignore"`

    Automation_account_name string

    Content_embedded string

    Description *string

    Location string

    Log_verbose *bool

    Name string

    Resource_group_name string

    State *string

}

var Azurerm_automation_dsc_configuration_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_dsc_configuration_id",

		"description",

		"log_verbose",

		"state",

	)
	rtb.ImmutableAttributes(

		"automation_account_name",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_automation_dsc_configurationHandler ...
type Azurerm_automation_dsc_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_dsc_configurationHandler) Create(desired *Azurerm_automation_dsc_configuration) (*Azurerm_automation_dsc_configuration, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_dsc_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_dsc_configuration", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_dsc_configurationHandler) Update(externalID string, desired *Azurerm_automation_dsc_configuration) (*Azurerm_automation_dsc_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_dsc_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_dsc_configuration", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_dsc_configuration{ Azurerm_automation_dsc_configuration_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_dsc_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_dsc_configurationHandler) Read(externalID string) (*Azurerm_automation_dsc_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_dsc_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_dsc_configuration", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_dsc_configuration{ Azurerm_automation_dsc_configuration_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_dsc_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_dsc_configurationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_dsc_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_dsc_configuration", externalID)
}

type Azurerm_automation_dsc_nodeconfiguration struct {

	Azurerm_automation_dsc_nodeconfiguration_id *string `lyra:"ignore"`

    Automation_account_name string

    Configuration_name *string

    Content_embedded string

    Name string

    Resource_group_name string

}

var Azurerm_automation_dsc_nodeconfiguration_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_dsc_nodeconfiguration_id",

		"configuration_name",

	)
	rtb.ImmutableAttributes(

		"automation_account_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_automation_dsc_nodeconfigurationHandler ...
type Azurerm_automation_dsc_nodeconfigurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_dsc_nodeconfigurationHandler) Create(desired *Azurerm_automation_dsc_nodeconfiguration) (*Azurerm_automation_dsc_nodeconfiguration, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_dsc_nodeconfiguration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_dsc_nodeconfiguration", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_dsc_nodeconfigurationHandler) Update(externalID string, desired *Azurerm_automation_dsc_nodeconfiguration) (*Azurerm_automation_dsc_nodeconfiguration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_dsc_nodeconfiguration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_dsc_nodeconfiguration", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_dsc_nodeconfiguration{ Azurerm_automation_dsc_nodeconfiguration_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_dsc_nodeconfiguration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_dsc_nodeconfigurationHandler) Read(externalID string) (*Azurerm_automation_dsc_nodeconfiguration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_dsc_nodeconfiguration", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_dsc_nodeconfiguration", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_dsc_nodeconfiguration{ Azurerm_automation_dsc_nodeconfiguration_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_dsc_nodeconfiguration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_dsc_nodeconfigurationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_dsc_nodeconfiguration", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_dsc_nodeconfiguration", externalID)
}

type Azurerm_automation_module_module_link_40_hash_41 struct {


    Algorithm string

    Value string

}

type Azurerm_automation_module_module_link_40 struct {


    Hash *[]Azurerm_automation_module_module_link_40_hash_41

    Uri string

}

type Azurerm_automation_module struct {

	Azurerm_automation_module_id *string `lyra:"ignore"`

    Automation_account_name string

    Module_link []Azurerm_automation_module_module_link_40

    Name string

    Resource_group_name string

}

var Azurerm_automation_module_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_module_id",

	)
	rtb.ImmutableAttributes(

		"automation_account_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_automation_moduleHandler ...
type Azurerm_automation_moduleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_moduleHandler) Create(desired *Azurerm_automation_module) (*Azurerm_automation_module, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_module", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_module", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_moduleHandler) Update(externalID string, desired *Azurerm_automation_module) (*Azurerm_automation_module, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_module", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_module", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_module{ Azurerm_automation_module_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_module", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_moduleHandler) Read(externalID string) (*Azurerm_automation_module, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_module", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_module", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_module{ Azurerm_automation_module_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_module", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_moduleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_module", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_module", externalID)
}

type Azurerm_automation_runbook_publish_content_link_42_hash_43 struct {


    Algorithm string

    Value string

}

type Azurerm_automation_runbook_publish_content_link_42 struct {


    Hash *[]Azurerm_automation_runbook_publish_content_link_42_hash_43

    Uri string

    Version *string

}

type Azurerm_automation_runbook struct {

	Azurerm_automation_runbook_id *string `lyra:"ignore"`

    Account_name string

    Content *string

    Description *string

    Location string

    Log_progress bool

    Log_verbose bool

    Name string

    Publish_content_link []Azurerm_automation_runbook_publish_content_link_42

    Resource_group_name string

    Runbook_type string

    Tags *map[string]string

}

var Azurerm_automation_runbook_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_runbook_id",

		"content",

		"description",

		"tags",

	)
	rtb.ImmutableAttributes(

		"account_name",

		"location",

		"name",

		"resource_group_name",

		"runbook_type",

	)
}

// Azurerm_automation_runbookHandler ...
type Azurerm_automation_runbookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_runbookHandler) Create(desired *Azurerm_automation_runbook) (*Azurerm_automation_runbook, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_runbook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_runbook", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_runbookHandler) Update(externalID string, desired *Azurerm_automation_runbook) (*Azurerm_automation_runbook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_runbook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_runbook", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_runbook{ Azurerm_automation_runbook_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_runbook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_runbookHandler) Read(externalID string) (*Azurerm_automation_runbook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_runbook", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_runbook", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_runbook{ Azurerm_automation_runbook_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_runbook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_runbookHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_runbook", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_runbook", externalID)
}

type Azurerm_automation_schedule_monthly_occurrence_44 struct {


    Day string

    Occurrence int

}

type Azurerm_automation_schedule struct {

	Azurerm_automation_schedule_id *string `lyra:"ignore"`

    Account_name *string

    Automation_account_name *string

    Description *string

    Expiry_time *string

    Frequency string

    Interval *int

    Month_days *[]int

    Monthly_occurrence *[]Azurerm_automation_schedule_monthly_occurrence_44

    Name string

    Resource_group_name string

    Start_time *string

    Timezone *string

    Week_days *[]string

}

var Azurerm_automation_schedule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_schedule_id",

		"account_name",

		"automation_account_name",

		"description",

		"expiry_time",

		"interval",

		"month_days",

		"monthly_occurrence",

		"start_time",

		"timezone",

		"week_days",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_automation_scheduleHandler ...
type Azurerm_automation_scheduleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_scheduleHandler) Create(desired *Azurerm_automation_schedule) (*Azurerm_automation_schedule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_schedule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_schedule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_scheduleHandler) Update(externalID string, desired *Azurerm_automation_schedule) (*Azurerm_automation_schedule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_schedule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_schedule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_schedule{ Azurerm_automation_schedule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_schedule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_scheduleHandler) Read(externalID string) (*Azurerm_automation_schedule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_schedule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_schedule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_schedule{ Azurerm_automation_schedule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_schedule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_scheduleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_schedule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_schedule", externalID)
}

type Azurerm_autoscale_setting_notification_45_email_46 struct {


    Custom_emails *[]string

    Send_to_subscription_administrator *bool

    Send_to_subscription_co_administrator *bool

}

type Azurerm_autoscale_setting_notification_45_webhook_47 struct {


    Properties *map[string]string

    Service_uri string

}

type Azurerm_autoscale_setting_notification_45 struct {


    Email *[]Azurerm_autoscale_setting_notification_45_email_46

    Webhook *[]Azurerm_autoscale_setting_notification_45_webhook_47

}

type Azurerm_autoscale_setting_profile_48_capacity_49 struct {


    Default int

    Maximum int

    Minimum int

}

type Azurerm_autoscale_setting_profile_48_fixed_date_50 struct {


    End string

    Start string

    Timezone *string

}

type Azurerm_autoscale_setting_profile_48_recurrence_51 struct {


    Days []string

    Hours []int

    Minutes []int

    Timezone *string

}

type Azurerm_autoscale_setting_profile_48_rule_52_metric_trigger_53 struct {


    Metric_name string

    Metric_resource_id string

    Operator string

    Statistic string

    Threshold float64

    Time_aggregation string

    Time_grain string

    Time_window string

}

type Azurerm_autoscale_setting_profile_48_rule_52_scale_action_54 struct {


    Cooldown string

    Direction string

    Type string

    Value int

}

type Azurerm_autoscale_setting_profile_48_rule_52 struct {


    Metric_trigger []Azurerm_autoscale_setting_profile_48_rule_52_metric_trigger_53

    Scale_action []Azurerm_autoscale_setting_profile_48_rule_52_scale_action_54

}

type Azurerm_autoscale_setting_profile_48 struct {


    Capacity []Azurerm_autoscale_setting_profile_48_capacity_49

    Fixed_date *[]Azurerm_autoscale_setting_profile_48_fixed_date_50

    Name string

    Recurrence *[]Azurerm_autoscale_setting_profile_48_recurrence_51

    Rule *[]Azurerm_autoscale_setting_profile_48_rule_52

}

type Azurerm_autoscale_setting struct {

	Azurerm_autoscale_setting_id *string `lyra:"ignore"`

    Enabled *bool

    Location string

    Name string

    Notification *[]Azurerm_autoscale_setting_notification_45

    Profile []Azurerm_autoscale_setting_profile_48

    Resource_group_name string

    Tags *map[string]string

    Target_resource_id string

}

var Azurerm_autoscale_setting_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_autoscale_setting_id",

		"enabled",

		"notification",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"target_resource_id",

	)
}

// Azurerm_autoscale_settingHandler ...
type Azurerm_autoscale_settingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_autoscale_settingHandler) Create(desired *Azurerm_autoscale_setting) (*Azurerm_autoscale_setting, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_autoscale_setting", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_autoscale_setting", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_autoscale_settingHandler) Update(externalID string, desired *Azurerm_autoscale_setting) (*Azurerm_autoscale_setting, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_autoscale_setting", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_autoscale_setting", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_autoscale_setting{ Azurerm_autoscale_setting_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_autoscale_setting", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_autoscale_settingHandler) Read(externalID string) (*Azurerm_autoscale_setting, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_autoscale_setting", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_autoscale_setting", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_autoscale_setting{ Azurerm_autoscale_setting_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_autoscale_setting", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_autoscale_settingHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_autoscale_setting", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_autoscale_setting", externalID)
}

type Azurerm_availability_set struct {

	Azurerm_availability_set_id *string `lyra:"ignore"`

    Location string

    Managed *bool

    Name string

    Platform_fault_domain_count *int

    Platform_update_domain_count *int

    Resource_group_name string

    Tags *map[string]string

}

var Azurerm_availability_set_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_availability_set_id",

		"managed",

		"platform_fault_domain_count",

		"platform_update_domain_count",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"managed",

		"name",

		"platform_fault_domain_count",

		"platform_update_domain_count",

		"resource_group_name",

	)
}

// Azurerm_availability_setHandler ...
type Azurerm_availability_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_availability_setHandler) Create(desired *Azurerm_availability_set) (*Azurerm_availability_set, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_availability_set", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_availability_set", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_availability_setHandler) Update(externalID string, desired *Azurerm_availability_set) (*Azurerm_availability_set, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_availability_set", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_availability_set", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_availability_set{ Azurerm_availability_set_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_availability_set", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_availability_setHandler) Read(externalID string) (*Azurerm_availability_set, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_availability_set", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_availability_set", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_availability_set{ Azurerm_availability_set_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_availability_set", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_availability_setHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_availability_set", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_availability_set", externalID)
}

type Azurerm_azuread_application struct {

	Azurerm_azuread_application_id *string `lyra:"ignore"`

    Application_id *string

    Available_to_other_tenants *bool

    Homepage *string

    Identifier_uris *[]string

    Name string

    Oauth2_allow_implicit_flow *bool

    Reply_urls *[]string

}

var Azurerm_azuread_application_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_azuread_application_id",

		"application_id",

		"available_to_other_tenants",

		"homepage",

		"identifier_uris",

		"oauth2_allow_implicit_flow",

		"reply_urls",

	)
	rtb.ImmutableAttributes(

	)
}

// Azurerm_azuread_applicationHandler ...
type Azurerm_azuread_applicationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_azuread_applicationHandler) Create(desired *Azurerm_azuread_application) (*Azurerm_azuread_application, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_azuread_application", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_azuread_application", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_azuread_applicationHandler) Update(externalID string, desired *Azurerm_azuread_application) (*Azurerm_azuread_application, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_azuread_application", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_azuread_application", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_application{ Azurerm_azuread_application_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_azuread_application", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_azuread_applicationHandler) Read(externalID string) (*Azurerm_azuread_application, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_azuread_application", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_azuread_application", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_application{ Azurerm_azuread_application_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_azuread_application", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_azuread_applicationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_azuread_application", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_azuread_application", externalID)
}

type Azurerm_azuread_service_principal struct {

	Azurerm_azuread_service_principal_id *string `lyra:"ignore"`

    Application_id string

    Display_name *string

}

var Azurerm_azuread_service_principal_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_azuread_service_principal_id",

		"display_name",

	)
	rtb.ImmutableAttributes(

		"application_id",

	)
}

// Azurerm_azuread_service_principalHandler ...
type Azurerm_azuread_service_principalHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_azuread_service_principalHandler) Create(desired *Azurerm_azuread_service_principal) (*Azurerm_azuread_service_principal, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_azuread_service_principal", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_azuread_service_principal", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_azuread_service_principalHandler) Update(externalID string, desired *Azurerm_azuread_service_principal) (*Azurerm_azuread_service_principal, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_azuread_service_principal", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_azuread_service_principal", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_service_principal{ Azurerm_azuread_service_principal_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_azuread_service_principal", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_azuread_service_principalHandler) Read(externalID string) (*Azurerm_azuread_service_principal, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_azuread_service_principal", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_azuread_service_principal", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_service_principal{ Azurerm_azuread_service_principal_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_azuread_service_principal", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_azuread_service_principalHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_azuread_service_principal", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_azuread_service_principal", externalID)
}

type Azurerm_azuread_service_principal_password struct {

	Azurerm_azuread_service_principal_password_id *string `lyra:"ignore"`

    End_date string

    Key_id *string

    Service_principal_id string

    Start_date *string

    Value string

}

var Azurerm_azuread_service_principal_password_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_azuread_service_principal_password_id",

		"key_id",

		"start_date",

	)
	rtb.ImmutableAttributes(

		"end_date",

		"key_id",

		"service_principal_id",

		"start_date",

		"value",

	)
}

// Azurerm_azuread_service_principal_passwordHandler ...
type Azurerm_azuread_service_principal_passwordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_azuread_service_principal_passwordHandler) Create(desired *Azurerm_azuread_service_principal_password) (*Azurerm_azuread_service_principal_password, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_azuread_service_principal_password", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_azuread_service_principal_password", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_azuread_service_principal_passwordHandler) Update(externalID string, desired *Azurerm_azuread_service_principal_password) (*Azurerm_azuread_service_principal_password, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_azuread_service_principal_password", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_azuread_service_principal_password", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_service_principal_password{ Azurerm_azuread_service_principal_password_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_azuread_service_principal_password", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_azuread_service_principal_passwordHandler) Read(externalID string) (*Azurerm_azuread_service_principal_password, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_azuread_service_principal_password", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_azuread_service_principal_password", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_service_principal_password{ Azurerm_azuread_service_principal_password_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_azuread_service_principal_password", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_azuread_service_principal_passwordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_azuread_service_principal_password", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_azuread_service_principal_password", externalID)
}

type Azurerm_batch_account struct {

	Azurerm_batch_account_id *string `lyra:"ignore"`

    Location string

    Name string

    Pool_allocation_mode *string

    Resource_group_name string

    Storage_account_id *string

    Tags *map[string]string

}

var Azurerm_batch_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_batch_account_id",

		"pool_allocation_mode",

		"storage_account_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_batch_accountHandler ...
type Azurerm_batch_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_batch_accountHandler) Create(desired *Azurerm_batch_account) (*Azurerm_batch_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_batch_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_batch_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_batch_accountHandler) Update(externalID string, desired *Azurerm_batch_account) (*Azurerm_batch_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_batch_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_batch_account", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_batch_account{ Azurerm_batch_account_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_batch_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_batch_accountHandler) Read(externalID string) (*Azurerm_batch_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_batch_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_batch_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_batch_account{ Azurerm_batch_account_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_batch_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_batch_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_batch_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_batch_account", externalID)
}

type Azurerm_batch_pool_auto_scale_55 struct {


    Evaluation_interval *string

    Formula string

}

type Azurerm_batch_pool_fixed_scale_56 struct {


    Resize_timeout *string

    Target_dedicated_nodes *int

    Target_low_priority_nodes *int

}

type Azurerm_batch_pool_start_task_57_user_identity_58_auto_user_59 struct {


    Elevation_level *string

    Scope *string

}

type Azurerm_batch_pool_start_task_57_user_identity_58 struct {


    Auto_user *[]Azurerm_batch_pool_start_task_57_user_identity_58_auto_user_59

    User_name *string

}

type Azurerm_batch_pool_start_task_57 struct {


    Command_line string

    Environment *map[string]string

    Max_task_retry_count *int

    User_identity []Azurerm_batch_pool_start_task_57_user_identity_58

    Wait_for_success *bool

}

type Azurerm_batch_pool_storage_image_reference_60 struct {


    Id *string

    Offer string

    Publisher string

    Sku string

    Version string

}

type Azurerm_batch_pool struct {

	Azurerm_batch_pool_id *string `lyra:"ignore"`

    Account_name string

    Auto_scale *[]Azurerm_batch_pool_auto_scale_55

    Display_name *string

    Fixed_scale *[]Azurerm_batch_pool_fixed_scale_56

    Name string

    Node_agent_sku_id string

    Resource_group_name string

    Start_task *[]Azurerm_batch_pool_start_task_57

    Stop_pending_resize_operation *bool

    Storage_image_reference []Azurerm_batch_pool_storage_image_reference_60

    Vm_size string

}

var Azurerm_batch_pool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_batch_pool_id",

		"auto_scale",

		"display_name",

		"fixed_scale",

		"start_task",

		"stop_pending_resize_operation",

	)
	rtb.ImmutableAttributes(

		"account_name",

		"display_name",

		"name",

		"node_agent_sku_id",

		"resource_group_name",

		"storage_image_reference",

		"vm_size",

	)
}

// Azurerm_batch_poolHandler ...
type Azurerm_batch_poolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_batch_poolHandler) Create(desired *Azurerm_batch_pool) (*Azurerm_batch_pool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_batch_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_batch_pool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_batch_poolHandler) Update(externalID string, desired *Azurerm_batch_pool) (*Azurerm_batch_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_batch_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_batch_pool", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_batch_pool{ Azurerm_batch_pool_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_batch_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_batch_poolHandler) Read(externalID string) (*Azurerm_batch_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_batch_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_batch_pool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_batch_pool{ Azurerm_batch_pool_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_batch_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_batch_poolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_batch_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_batch_pool", externalID)
}

type Azurerm_cdn_endpoint_geo_filter_61 struct {


    Action string

    Country_codes []string

    Relative_path string

}

type Azurerm_cdn_endpoint_origin_62 struct {


    Host_name string

    Http_port *int

    Https_port *int

    Name string

}

type Azurerm_cdn_endpoint struct {

	Azurerm_cdn_endpoint_id *string `lyra:"ignore"`

    Content_types_to_compress *[]string

    Geo_filter *[]Azurerm_cdn_endpoint_geo_filter_61

    Host_name *string

    Is_compression_enabled *bool

    Is_http_allowed *bool

    Is_https_allowed *bool

    Location string

    Name string

    Optimization_type *string

    Origin []Azurerm_cdn_endpoint_origin_62

    Origin_host_header *string

    Origin_path *string

    Probe_path *string

    Profile_name string

    Querystring_caching_behaviour *string

    Resource_group_name string

    Tags *map[string]string

}

var Azurerm_cdn_endpoint_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_cdn_endpoint_id",

		"content_types_to_compress",

		"geo_filter",

		"host_name",

		"is_compression_enabled",

		"is_http_allowed",

		"is_https_allowed",

		"optimization_type",

		"origin_host_header",

		"origin_path",

		"probe_path",

		"querystring_caching_behaviour",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"origin",

		"profile_name",

		"resource_group_name",

	)
}

// Azurerm_cdn_endpointHandler ...
type Azurerm_cdn_endpointHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_cdn_endpointHandler) Create(desired *Azurerm_cdn_endpoint) (*Azurerm_cdn_endpoint, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_cdn_endpoint", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_cdn_endpoint", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_cdn_endpointHandler) Update(externalID string, desired *Azurerm_cdn_endpoint) (*Azurerm_cdn_endpoint, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_cdn_endpoint", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_cdn_endpoint", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cdn_endpoint{ Azurerm_cdn_endpoint_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_cdn_endpoint", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_cdn_endpointHandler) Read(externalID string) (*Azurerm_cdn_endpoint, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_cdn_endpoint", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_cdn_endpoint", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cdn_endpoint{ Azurerm_cdn_endpoint_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_cdn_endpoint", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_cdn_endpointHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_cdn_endpoint", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_cdn_endpoint", externalID)
}

type Azurerm_cdn_profile struct {

	Azurerm_cdn_profile_id *string `lyra:"ignore"`

    Location string

    Name string

    Resource_group_name string

    Sku string

    Tags *map[string]string

}

var Azurerm_cdn_profile_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_cdn_profile_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"sku",

	)
}

// Azurerm_cdn_profileHandler ...
type Azurerm_cdn_profileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_cdn_profileHandler) Create(desired *Azurerm_cdn_profile) (*Azurerm_cdn_profile, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_cdn_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_cdn_profile", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_cdn_profileHandler) Update(externalID string, desired *Azurerm_cdn_profile) (*Azurerm_cdn_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_cdn_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_cdn_profile", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cdn_profile{ Azurerm_cdn_profile_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_cdn_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_cdn_profileHandler) Read(externalID string) (*Azurerm_cdn_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_cdn_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_cdn_profile", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cdn_profile{ Azurerm_cdn_profile_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_cdn_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_cdn_profileHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_cdn_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_cdn_profile", externalID)
}

type Azurerm_cognitive_account_sku_63 struct {


    Name string

    Tier string

}

type Azurerm_cognitive_account struct {

	Azurerm_cognitive_account_id *string `lyra:"ignore"`

    Endpoint *string

    Kind string

    Location string

    Name string

    Resource_group_name string

    Sku []Azurerm_cognitive_account_sku_63

    Tags *map[string]string

}

var Azurerm_cognitive_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_cognitive_account_id",

		"endpoint",

		"tags",

	)
	rtb.ImmutableAttributes(

		"kind",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_cognitive_accountHandler ...
type Azurerm_cognitive_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_cognitive_accountHandler) Create(desired *Azurerm_cognitive_account) (*Azurerm_cognitive_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_cognitive_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_cognitive_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_cognitive_accountHandler) Update(externalID string, desired *Azurerm_cognitive_account) (*Azurerm_cognitive_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_cognitive_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_cognitive_account", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cognitive_account{ Azurerm_cognitive_account_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_cognitive_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_cognitive_accountHandler) Read(externalID string) (*Azurerm_cognitive_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_cognitive_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_cognitive_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cognitive_account{ Azurerm_cognitive_account_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_cognitive_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_cognitive_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_cognitive_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_cognitive_account", externalID)
}

type Azurerm_container_group_container_64_ports_65 struct {


    Port *int

    Protocol *string

}

type Azurerm_container_group_container_64_volume_66 struct {


    Mount_path string

    Name string

    Read_only *bool

    Share_name string

    Storage_account_key string

    Storage_account_name string

}

type Azurerm_container_group_container_64 struct {


    Command *string

    Commands *[]string

    Cpu float64

    Environment_variables *map[string]string

    Image string

    Memory float64

    Name string

    Port *int

    Ports *[]Azurerm_container_group_container_64_ports_65

    Protocol *string

    Secure_environment_variables *map[string]string

    Volume *[]Azurerm_container_group_container_64_volume_66

}

type Azurerm_container_group_image_registry_credential_67 struct {


    Password string

    Server string

    Username string

}

type Azurerm_container_group struct {

	Azurerm_container_group_id *string `lyra:"ignore"`

    Container []Azurerm_container_group_container_64

    Dns_name_label *string

    Fqdn *string

    Image_registry_credential *[]Azurerm_container_group_image_registry_credential_67

    Ip_address *string

    Ip_address_type *string

    Location string

    Name string

    Os_type string

    Resource_group_name string

    Restart_policy *string

    Tags *map[string]string

}

var Azurerm_container_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_container_group_id",

		"dns_name_label",

		"fqdn",

		"image_registry_credential",

		"ip_address",

		"ip_address_type",

		"restart_policy",

		"tags",

	)
	rtb.ImmutableAttributes(

		"container",

		"dns_name_label",

		"image_registry_credential",

		"ip_address_type",

		"location",

		"name",

		"os_type",

		"resource_group_name",

		"restart_policy",

		"tags",

	)
}

// Azurerm_container_groupHandler ...
type Azurerm_container_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_container_groupHandler) Create(desired *Azurerm_container_group) (*Azurerm_container_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_container_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_container_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_container_groupHandler) Update(externalID string, desired *Azurerm_container_group) (*Azurerm_container_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_container_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_container_group", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_group{ Azurerm_container_group_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_container_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_container_groupHandler) Read(externalID string) (*Azurerm_container_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_container_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_container_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_group{ Azurerm_container_group_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_container_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_container_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_container_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_container_group", externalID)
}

type Azurerm_container_registry_storage_account_68 struct {


    Access_key string

    Name string

}

type Azurerm_container_registry struct {

	Azurerm_container_registry_id *string `lyra:"ignore"`

    Admin_enabled *bool

    Admin_password *string

    Admin_username *string

    Georeplication_locations *[]string

    Location string

    Login_server *string

    Name string

    Resource_group_name string

    Sku *string

    Storage_account *[]Azurerm_container_registry_storage_account_68

    Storage_account_id *string

    Tags *map[string]string

}

var Azurerm_container_registry_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_container_registry_id",

		"admin_enabled",

		"admin_password",

		"admin_username",

		"georeplication_locations",

		"login_server",

		"sku",

		"storage_account",

		"storage_account_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_container_registryHandler ...
type Azurerm_container_registryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_container_registryHandler) Create(desired *Azurerm_container_registry) (*Azurerm_container_registry, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_container_registry", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_container_registry", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_container_registryHandler) Update(externalID string, desired *Azurerm_container_registry) (*Azurerm_container_registry, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_container_registry", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_container_registry", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_registry{ Azurerm_container_registry_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_container_registry", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_container_registryHandler) Read(externalID string) (*Azurerm_container_registry, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_container_registry", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_container_registry", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_registry{ Azurerm_container_registry_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_container_registry", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_container_registryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_container_registry", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_container_registry", externalID)
}

type Azurerm_container_service_agent_pool_profile_69 struct {


    Count *int

    Dns_prefix string

    Fqdn *string

    Name string

    Vm_size string

}

type Azurerm_container_service_diagnostics_profile_70 struct {


    Enabled bool

    Storage_uri *string

}

type Azurerm_container_service_linux_profile_71_ssh_key_72 struct {


    Key_data string

}

type Azurerm_container_service_linux_profile_71 struct {


    Admin_username string

    Ssh_key []Azurerm_container_service_linux_profile_71_ssh_key_72

}

type Azurerm_container_service_master_profile_73 struct {


    Count *int

    Dns_prefix string

    Fqdn *string

}

type Azurerm_container_service_service_principal_74 struct {


    Client_id string

    Client_secret string

}

type Azurerm_container_service struct {

	Azurerm_container_service_id *string `lyra:"ignore"`

    Agent_pool_profile []Azurerm_container_service_agent_pool_profile_69

    Diagnostics_profile []Azurerm_container_service_diagnostics_profile_70

    Linux_profile []Azurerm_container_service_linux_profile_71

    Location string

    Master_profile []Azurerm_container_service_master_profile_73

    Name string

    Orchestration_platform string

    Resource_group_name string

    Service_principal *[]Azurerm_container_service_service_principal_74

    Tags *map[string]string

}

var Azurerm_container_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_container_service_id",

		"service_principal",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"orchestration_platform",

		"resource_group_name",

	)
}

// Azurerm_container_serviceHandler ...
type Azurerm_container_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_container_serviceHandler) Create(desired *Azurerm_container_service) (*Azurerm_container_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_container_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_container_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_container_serviceHandler) Update(externalID string, desired *Azurerm_container_service) (*Azurerm_container_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_container_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_container_service", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_service{ Azurerm_container_service_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_container_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_container_serviceHandler) Read(externalID string) (*Azurerm_container_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_container_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_container_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_service{ Azurerm_container_service_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_container_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_container_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_container_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_container_service", externalID)
}

type Azurerm_cosmosdb_account_capabilities_75 struct {


    Name string

}

type Azurerm_cosmosdb_account_consistency_policy_76 struct {


    Consistency_level string

    Max_interval_in_seconds *int

    Max_staleness_prefix *int

}

type Azurerm_cosmosdb_account_failover_policy_77 struct {


    Id *string

    Location string

    Priority int

}

type Azurerm_cosmosdb_account_geo_location_78 struct {


    Failover_priority int

    Id *string

    Location string

    Prefix *string

}

type Azurerm_cosmosdb_account_virtual_network_rule_79 struct {


    Id string

}

type Azurerm_cosmosdb_account struct {

	Azurerm_cosmosdb_account_id *string `lyra:"ignore"`

    Capabilities *[]Azurerm_cosmosdb_account_capabilities_75

    Connection_strings *[]string

    Consistency_policy []Azurerm_cosmosdb_account_consistency_policy_76

    Enable_automatic_failover *bool

    Enable_multiple_write_locations *bool

    Endpoint *string

    Failover_policy *[]Azurerm_cosmosdb_account_failover_policy_77

    Geo_location *[]Azurerm_cosmosdb_account_geo_location_78

    Ip_range_filter *string

    Is_virtual_network_filter_enabled *bool

    Kind *string

    Location string

    Name string

    Offer_type string

    Primary_master_key *string

    Primary_readonly_master_key *string

    Read_endpoints *[]string

    Resource_group_name string

    Secondary_master_key *string

    Secondary_readonly_master_key *string

    Tags *map[string]string

    Virtual_network_rule *[]Azurerm_cosmosdb_account_virtual_network_rule_79

    Write_endpoints *[]string

}

var Azurerm_cosmosdb_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_cosmosdb_account_id",

		"capabilities",

		"connection_strings",

		"enable_automatic_failover",

		"enable_multiple_write_locations",

		"endpoint",

		"failover_policy",

		"geo_location",

		"ip_range_filter",

		"is_virtual_network_filter_enabled",

		"kind",

		"primary_master_key",

		"primary_readonly_master_key",

		"read_endpoints",

		"secondary_master_key",

		"secondary_readonly_master_key",

		"tags",

		"virtual_network_rule",

		"write_endpoints",

	)
	rtb.ImmutableAttributes(

		"kind",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_cosmosdb_accountHandler ...
type Azurerm_cosmosdb_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_cosmosdb_accountHandler) Create(desired *Azurerm_cosmosdb_account) (*Azurerm_cosmosdb_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_cosmosdb_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_cosmosdb_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_cosmosdb_accountHandler) Update(externalID string, desired *Azurerm_cosmosdb_account) (*Azurerm_cosmosdb_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_cosmosdb_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_cosmosdb_account", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cosmosdb_account{ Azurerm_cosmosdb_account_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_cosmosdb_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_cosmosdb_accountHandler) Read(externalID string) (*Azurerm_cosmosdb_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_cosmosdb_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_cosmosdb_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cosmosdb_account{ Azurerm_cosmosdb_account_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_cosmosdb_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_cosmosdb_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_cosmosdb_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_cosmosdb_account", externalID)
}

type Azurerm_data_lake_analytics_account struct {

	Azurerm_data_lake_analytics_account_id *string `lyra:"ignore"`

    Default_store_account_name string

    Location string

    Name string

    Resource_group_name string

    Tags *map[string]string

    Tier *string

}

var Azurerm_data_lake_analytics_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_analytics_account_id",

		"tags",

		"tier",

	)
	rtb.ImmutableAttributes(

		"default_store_account_name",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_data_lake_analytics_accountHandler ...
type Azurerm_data_lake_analytics_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_analytics_accountHandler) Create(desired *Azurerm_data_lake_analytics_account) (*Azurerm_data_lake_analytics_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_analytics_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_analytics_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_analytics_accountHandler) Update(externalID string, desired *Azurerm_data_lake_analytics_account) (*Azurerm_data_lake_analytics_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_analytics_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_analytics_account", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_analytics_account{ Azurerm_data_lake_analytics_account_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_analytics_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_analytics_accountHandler) Read(externalID string) (*Azurerm_data_lake_analytics_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_analytics_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_analytics_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_analytics_account{ Azurerm_data_lake_analytics_account_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_analytics_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_analytics_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_analytics_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_analytics_account", externalID)
}

type Azurerm_data_lake_analytics_firewall_rule struct {

	Azurerm_data_lake_analytics_firewall_rule_id *string `lyra:"ignore"`

    Account_name string

    End_ip_address string

    Name string

    Resource_group_name string

    Start_ip_address string

}

var Azurerm_data_lake_analytics_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_analytics_firewall_rule_id",

	)
	rtb.ImmutableAttributes(

		"account_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_data_lake_analytics_firewall_ruleHandler ...
type Azurerm_data_lake_analytics_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_analytics_firewall_ruleHandler) Create(desired *Azurerm_data_lake_analytics_firewall_rule) (*Azurerm_data_lake_analytics_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_analytics_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_analytics_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_analytics_firewall_ruleHandler) Update(externalID string, desired *Azurerm_data_lake_analytics_firewall_rule) (*Azurerm_data_lake_analytics_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_analytics_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_analytics_firewall_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_analytics_firewall_rule{ Azurerm_data_lake_analytics_firewall_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_analytics_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_analytics_firewall_ruleHandler) Read(externalID string) (*Azurerm_data_lake_analytics_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_analytics_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_analytics_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_analytics_firewall_rule{ Azurerm_data_lake_analytics_firewall_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_analytics_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_analytics_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_analytics_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_analytics_firewall_rule", externalID)
}

type Azurerm_data_lake_store struct {

	Azurerm_data_lake_store_id *string `lyra:"ignore"`

    Encryption_state *string

    Encryption_type *string

    Endpoint *string

    Firewall_allow_azure_ips *string

    Firewall_state *string

    Location string

    Name string

    Resource_group_name string

    Tags *map[string]string

    Tier *string

}

var Azurerm_data_lake_store_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_store_id",

		"encryption_state",

		"encryption_type",

		"endpoint",

		"firewall_allow_azure_ips",

		"firewall_state",

		"tags",

		"tier",

	)
	rtb.ImmutableAttributes(

		"encryption_state",

		"encryption_type",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_data_lake_storeHandler ...
type Azurerm_data_lake_storeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_storeHandler) Create(desired *Azurerm_data_lake_store) (*Azurerm_data_lake_store, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_store", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_store", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_storeHandler) Update(externalID string, desired *Azurerm_data_lake_store) (*Azurerm_data_lake_store, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_store", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_store", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store{ Azurerm_data_lake_store_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_store", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_storeHandler) Read(externalID string) (*Azurerm_data_lake_store, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_store", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_store", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store{ Azurerm_data_lake_store_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_store", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_storeHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_store", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_store", externalID)
}

type Azurerm_data_lake_store_file struct {

	Azurerm_data_lake_store_file_id *string `lyra:"ignore"`

    Account_name string

    Local_file_path string

    Remote_file_path string

}

var Azurerm_data_lake_store_file_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_store_file_id",

	)
	rtb.ImmutableAttributes(

		"account_name",

		"local_file_path",

		"remote_file_path",

	)
}

// Azurerm_data_lake_store_fileHandler ...
type Azurerm_data_lake_store_fileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_store_fileHandler) Create(desired *Azurerm_data_lake_store_file) (*Azurerm_data_lake_store_file, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_store_file", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_store_file", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_store_fileHandler) Update(externalID string, desired *Azurerm_data_lake_store_file) (*Azurerm_data_lake_store_file, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_store_file", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_store_file", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store_file{ Azurerm_data_lake_store_file_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_store_file", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_store_fileHandler) Read(externalID string) (*Azurerm_data_lake_store_file, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_store_file", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_store_file", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store_file{ Azurerm_data_lake_store_file_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_store_file", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_store_fileHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_store_file", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_store_file", externalID)
}

type Azurerm_data_lake_store_firewall_rule struct {

	Azurerm_data_lake_store_firewall_rule_id *string `lyra:"ignore"`

    Account_name string

    End_ip_address string

    Name string

    Resource_group_name string

    Start_ip_address string

}

var Azurerm_data_lake_store_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_store_firewall_rule_id",

	)
	rtb.ImmutableAttributes(

		"account_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_data_lake_store_firewall_ruleHandler ...
type Azurerm_data_lake_store_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_store_firewall_ruleHandler) Create(desired *Azurerm_data_lake_store_firewall_rule) (*Azurerm_data_lake_store_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_store_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_store_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_store_firewall_ruleHandler) Update(externalID string, desired *Azurerm_data_lake_store_firewall_rule) (*Azurerm_data_lake_store_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_store_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_store_firewall_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store_firewall_rule{ Azurerm_data_lake_store_firewall_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_store_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_store_firewall_ruleHandler) Read(externalID string) (*Azurerm_data_lake_store_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_store_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_store_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store_firewall_rule{ Azurerm_data_lake_store_firewall_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_store_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_store_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_store_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_store_firewall_rule", externalID)
}

type Azurerm_databricks_workspace struct {

	Azurerm_databricks_workspace_id *string `lyra:"ignore"`

    Location string

    Managed_resource_group_id *string

    Managed_resource_group_name *string

    Name string

    Resource_group_name string

    Sku string

    Tags *map[string]string

}

var Azurerm_databricks_workspace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_databricks_workspace_id",

		"managed_resource_group_id",

		"managed_resource_group_name",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"managed_resource_group_name",

		"name",

		"resource_group_name",

		"sku",

	)
}

// Azurerm_databricks_workspaceHandler ...
type Azurerm_databricks_workspaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_databricks_workspaceHandler) Create(desired *Azurerm_databricks_workspace) (*Azurerm_databricks_workspace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_databricks_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_databricks_workspace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_databricks_workspaceHandler) Update(externalID string, desired *Azurerm_databricks_workspace) (*Azurerm_databricks_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_databricks_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_databricks_workspace", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_databricks_workspace{ Azurerm_databricks_workspace_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_databricks_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_databricks_workspaceHandler) Read(externalID string) (*Azurerm_databricks_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_databricks_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_databricks_workspace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_databricks_workspace{ Azurerm_databricks_workspace_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_databricks_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_databricks_workspaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_databricks_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_databricks_workspace", externalID)
}

type Azurerm_dev_test_lab struct {

	Azurerm_dev_test_lab_id *string `lyra:"ignore"`

    Artifacts_storage_account_id *string

    Default_premium_storage_account_id *string

    Default_storage_account_id *string

    Key_vault_id *string

    Location string

    Name string

    Premium_data_disk_storage_account_id *string

    Resource_group_name string

    Storage_type *string

    Tags *map[string]string

    Unique_identifier *string

}

var Azurerm_dev_test_lab_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_lab_id",

		"artifacts_storage_account_id",

		"default_premium_storage_account_id",

		"default_storage_account_id",

		"key_vault_id",

		"premium_data_disk_storage_account_id",

		"storage_type",

		"tags",

		"unique_identifier",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_dev_test_labHandler ...
type Azurerm_dev_test_labHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_labHandler) Create(desired *Azurerm_dev_test_lab) (*Azurerm_dev_test_lab, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_lab", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_lab", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_labHandler) Update(externalID string, desired *Azurerm_dev_test_lab) (*Azurerm_dev_test_lab, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_lab", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_lab", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_lab{ Azurerm_dev_test_lab_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_lab", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_labHandler) Read(externalID string) (*Azurerm_dev_test_lab, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_lab", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_lab", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_lab{ Azurerm_dev_test_lab_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_lab", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_labHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_lab", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_lab", externalID)
}

type Azurerm_dev_test_linux_virtual_machine_gallery_image_reference_80 struct {


    Offer string

    Publisher string

    Sku string

    Version string

}

type Azurerm_dev_test_linux_virtual_machine_inbound_nat_rule_81 struct {


    Backend_port int

    Frontend_port *int

    Protocol string

}

type Azurerm_dev_test_linux_virtual_machine struct {

	Azurerm_dev_test_linux_virtual_machine_id *string `lyra:"ignore"`

    Allow_claim *bool

    Disallow_public_ip_address *bool

    Fqdn *string

    Gallery_image_reference []Azurerm_dev_test_linux_virtual_machine_gallery_image_reference_80

    Inbound_nat_rule *[]Azurerm_dev_test_linux_virtual_machine_inbound_nat_rule_81

    Lab_name string

    Lab_subnet_name string

    Lab_virtual_network_id string

    Location string

    Name string

    Notes *string

    Password *string

    Resource_group_name string

    Size string

    Ssh_key *string

    Storage_type string

    Tags *map[string]string

    Unique_identifier *string

    Username string

}

var Azurerm_dev_test_linux_virtual_machine_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_linux_virtual_machine_id",

		"allow_claim",

		"disallow_public_ip_address",

		"fqdn",

		"inbound_nat_rule",

		"notes",

		"password",

		"ssh_key",

		"tags",

		"unique_identifier",

	)
	rtb.ImmutableAttributes(

		"disallow_public_ip_address",

		"inbound_nat_rule",

		"lab_name",

		"lab_subnet_name",

		"lab_virtual_network_id",

		"location",

		"name",

		"password",

		"resource_group_name",

		"size",

		"ssh_key",

		"username",

	)
}

// Azurerm_dev_test_linux_virtual_machineHandler ...
type Azurerm_dev_test_linux_virtual_machineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_linux_virtual_machineHandler) Create(desired *Azurerm_dev_test_linux_virtual_machine) (*Azurerm_dev_test_linux_virtual_machine, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_linux_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_linux_virtual_machine", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_linux_virtual_machineHandler) Update(externalID string, desired *Azurerm_dev_test_linux_virtual_machine) (*Azurerm_dev_test_linux_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_linux_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_linux_virtual_machine", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_linux_virtual_machine{ Azurerm_dev_test_linux_virtual_machine_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_linux_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_linux_virtual_machineHandler) Read(externalID string) (*Azurerm_dev_test_linux_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_linux_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_linux_virtual_machine", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_linux_virtual_machine{ Azurerm_dev_test_linux_virtual_machine_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_linux_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_linux_virtual_machineHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_linux_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_linux_virtual_machine", externalID)
}

type Azurerm_dev_test_policy struct {

	Azurerm_dev_test_policy_id *string `lyra:"ignore"`

    Description *string

    Evaluator_type string

    Fact_data *string

    Lab_name string

    Name string

    Policy_set_name string

    Resource_group_name string

    Tags *map[string]string

    Threshold string

}

var Azurerm_dev_test_policy_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_policy_id",

		"description",

		"fact_data",

		"tags",

	)
	rtb.ImmutableAttributes(

		"evaluator_type",

		"lab_name",

		"name",

		"policy_set_name",

		"resource_group_name",

	)
}

// Azurerm_dev_test_policyHandler ...
type Azurerm_dev_test_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_policyHandler) Create(desired *Azurerm_dev_test_policy) (*Azurerm_dev_test_policy, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_policy", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_policy", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_policyHandler) Update(externalID string, desired *Azurerm_dev_test_policy) (*Azurerm_dev_test_policy, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_policy", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_policy", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_policy{ Azurerm_dev_test_policy_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_policy", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_policyHandler) Read(externalID string) (*Azurerm_dev_test_policy, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_policy", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_policy", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_policy{ Azurerm_dev_test_policy_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_policy", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_policyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_policy", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_policy", externalID)
}

type Azurerm_dev_test_virtual_network_subnet_82 struct {


    Name *string

    Use_in_virtual_machine_creation *string

    Use_public_ip_address *string

}

type Azurerm_dev_test_virtual_network struct {

	Azurerm_dev_test_virtual_network_id *string `lyra:"ignore"`

    Description *string

    Lab_name string

    Name string

    Resource_group_name string

    Subnet *[]Azurerm_dev_test_virtual_network_subnet_82

    Tags *map[string]string

    Unique_identifier *string

}

var Azurerm_dev_test_virtual_network_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_virtual_network_id",

		"description",

		"subnet",

		"tags",

		"unique_identifier",

	)
	rtb.ImmutableAttributes(

		"lab_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_dev_test_virtual_networkHandler ...
type Azurerm_dev_test_virtual_networkHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_virtual_networkHandler) Create(desired *Azurerm_dev_test_virtual_network) (*Azurerm_dev_test_virtual_network, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_virtual_network", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_virtual_network", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_virtual_networkHandler) Update(externalID string, desired *Azurerm_dev_test_virtual_network) (*Azurerm_dev_test_virtual_network, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_virtual_network", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_virtual_network", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_virtual_network{ Azurerm_dev_test_virtual_network_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_virtual_network", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_virtual_networkHandler) Read(externalID string) (*Azurerm_dev_test_virtual_network, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_virtual_network", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_virtual_network", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_virtual_network{ Azurerm_dev_test_virtual_network_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_virtual_network", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_virtual_networkHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_virtual_network", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_virtual_network", externalID)
}

type Azurerm_dev_test_windows_virtual_machine_gallery_image_reference_83 struct {


    Offer string

    Publisher string

    Sku string

    Version string

}

type Azurerm_dev_test_windows_virtual_machine_inbound_nat_rule_84 struct {


    Backend_port int

    Frontend_port *int

    Protocol string

}

type Azurerm_dev_test_windows_virtual_machine struct {

	Azurerm_dev_test_windows_virtual_machine_id *string `lyra:"ignore"`

    Allow_claim *bool

    Disallow_public_ip_address *bool

    Fqdn *string

    Gallery_image_reference []Azurerm_dev_test_windows_virtual_machine_gallery_image_reference_83

    Inbound_nat_rule *[]Azurerm_dev_test_windows_virtual_machine_inbound_nat_rule_84

    Lab_name string

    Lab_subnet_name string

    Lab_virtual_network_id string

    Location string

    Name string

    Notes *string

    Password string

    Resource_group_name string

    Size string

    Storage_type string

    Tags *map[string]string

    Unique_identifier *string

    Username string

}

var Azurerm_dev_test_windows_virtual_machine_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_windows_virtual_machine_id",

		"allow_claim",

		"disallow_public_ip_address",

		"fqdn",

		"inbound_nat_rule",

		"notes",

		"tags",

		"unique_identifier",

	)
	rtb.ImmutableAttributes(

		"disallow_public_ip_address",

		"inbound_nat_rule",

		"lab_name",

		"lab_subnet_name",

		"lab_virtual_network_id",

		"location",

		"name",

		"password",

		"resource_group_name",

		"size",

		"username",

	)
}

// Azurerm_dev_test_windows_virtual_machineHandler ...
type Azurerm_dev_test_windows_virtual_machineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_windows_virtual_machineHandler) Create(desired *Azurerm_dev_test_windows_virtual_machine) (*Azurerm_dev_test_windows_virtual_machine, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_windows_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_windows_virtual_machine", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_windows_virtual_machineHandler) Update(externalID string, desired *Azurerm_dev_test_windows_virtual_machine) (*Azurerm_dev_test_windows_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_windows_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_windows_virtual_machine", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_windows_virtual_machine{ Azurerm_dev_test_windows_virtual_machine_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_windows_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_windows_virtual_machineHandler) Read(externalID string) (*Azurerm_dev_test_windows_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_windows_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_windows_virtual_machine", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_windows_virtual_machine{ Azurerm_dev_test_windows_virtual_machine_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_windows_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_windows_virtual_machineHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_windows_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_windows_virtual_machine", externalID)
}

type Azurerm_devspace_controller_sku_85 struct {


    Name string

    Tier string

}

type Azurerm_devspace_controller struct {

	Azurerm_devspace_controller_id *string `lyra:"ignore"`

    Data_plane_fqdn *string

    Host_suffix string

    Location string

    Name string

    Resource_group_name string

    Sku []Azurerm_devspace_controller_sku_85

    Tags *map[string]string

    Target_container_host_credentials_base64 string

    Target_container_host_resource_id string

}

var Azurerm_devspace_controller_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_devspace_controller_id",

		"data_plane_fqdn",

		"tags",

	)
	rtb.ImmutableAttributes(

		"host_suffix",

		"location",

		"name",

		"resource_group_name",

		"sku",

		"target_container_host_credentials_base64",

		"target_container_host_resource_id",

	)
}

// Azurerm_devspace_controllerHandler ...
type Azurerm_devspace_controllerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_devspace_controllerHandler) Create(desired *Azurerm_devspace_controller) (*Azurerm_devspace_controller, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_devspace_controller", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_devspace_controller", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_devspace_controllerHandler) Update(externalID string, desired *Azurerm_devspace_controller) (*Azurerm_devspace_controller, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_devspace_controller", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_devspace_controller", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_devspace_controller{ Azurerm_devspace_controller_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_devspace_controller", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_devspace_controllerHandler) Read(externalID string) (*Azurerm_devspace_controller, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_devspace_controller", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_devspace_controller", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_devspace_controller{ Azurerm_devspace_controller_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_devspace_controller", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_devspace_controllerHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_devspace_controller", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_devspace_controller", externalID)
}

type Azurerm_dns_a_record struct {

	Azurerm_dns_a_record_id *string `lyra:"ignore"`

    Name string

    Records []string

    Resource_group_name string

    Tags *map[string]string

    Ttl int

    Zone_name string

}

var Azurerm_dns_a_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_a_record_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_a_recordHandler ...
type Azurerm_dns_a_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_a_recordHandler) Create(desired *Azurerm_dns_a_record) (*Azurerm_dns_a_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_a_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_a_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_a_recordHandler) Update(externalID string, desired *Azurerm_dns_a_record) (*Azurerm_dns_a_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_a_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_a_record", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_a_record{ Azurerm_dns_a_record_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_a_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_a_recordHandler) Read(externalID string) (*Azurerm_dns_a_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_a_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_a_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_a_record{ Azurerm_dns_a_record_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_a_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_a_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_a_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_a_record", externalID)
}

type Azurerm_dns_aaaa_record struct {

	Azurerm_dns_aaaa_record_id *string `lyra:"ignore"`

    Name string

    Records []string

    Resource_group_name string

    Tags *map[string]string

    Ttl int

    Zone_name string

}

var Azurerm_dns_aaaa_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_aaaa_record_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_aaaa_recordHandler ...
type Azurerm_dns_aaaa_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_aaaa_recordHandler) Create(desired *Azurerm_dns_aaaa_record) (*Azurerm_dns_aaaa_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_aaaa_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_aaaa_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_aaaa_recordHandler) Update(externalID string, desired *Azurerm_dns_aaaa_record) (*Azurerm_dns_aaaa_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_aaaa_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_aaaa_record", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_aaaa_record{ Azurerm_dns_aaaa_record_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_aaaa_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_aaaa_recordHandler) Read(externalID string) (*Azurerm_dns_aaaa_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_aaaa_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_aaaa_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_aaaa_record{ Azurerm_dns_aaaa_record_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_aaaa_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_aaaa_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_aaaa_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_aaaa_record", externalID)
}

type Azurerm_dns_caa_record_record_86 struct {


    Flags int

    Tag string

    Value string

}

type Azurerm_dns_caa_record struct {

	Azurerm_dns_caa_record_id *string `lyra:"ignore"`

    Name string

    Record []Azurerm_dns_caa_record_record_86

    Resource_group_name string

    Tags *map[string]string

    Ttl int

    Zone_name string

}

var Azurerm_dns_caa_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_caa_record_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_caa_recordHandler ...
type Azurerm_dns_caa_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_caa_recordHandler) Create(desired *Azurerm_dns_caa_record) (*Azurerm_dns_caa_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_caa_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_caa_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_caa_recordHandler) Update(externalID string, desired *Azurerm_dns_caa_record) (*Azurerm_dns_caa_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_caa_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_caa_record", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_caa_record{ Azurerm_dns_caa_record_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_caa_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_caa_recordHandler) Read(externalID string) (*Azurerm_dns_caa_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_caa_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_caa_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_caa_record{ Azurerm_dns_caa_record_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_caa_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_caa_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_caa_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_caa_record", externalID)
}

type Azurerm_dns_cname_record struct {

	Azurerm_dns_cname_record_id *string `lyra:"ignore"`

    Name string

    Record string

    Records *string

    Resource_group_name string

    Tags *map[string]string

    Ttl int

    Zone_name string

}

var Azurerm_dns_cname_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_cname_record_id",

		"records",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_cname_recordHandler ...
type Azurerm_dns_cname_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_cname_recordHandler) Create(desired *Azurerm_dns_cname_record) (*Azurerm_dns_cname_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_cname_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_cname_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_cname_recordHandler) Update(externalID string, desired *Azurerm_dns_cname_record) (*Azurerm_dns_cname_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_cname_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_cname_record", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_cname_record{ Azurerm_dns_cname_record_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_cname_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_cname_recordHandler) Read(externalID string) (*Azurerm_dns_cname_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_cname_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_cname_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_cname_record{ Azurerm_dns_cname_record_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_cname_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_cname_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_cname_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_cname_record", externalID)
}

type Azurerm_dns_mx_record_record_87 struct {


    Exchange string

    Preference string

}

type Azurerm_dns_mx_record struct {

	Azurerm_dns_mx_record_id *string `lyra:"ignore"`

    Name string

    Record []Azurerm_dns_mx_record_record_87

    Resource_group_name string

    Tags *map[string]string

    Ttl int

    Zone_name string

}

var Azurerm_dns_mx_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_mx_record_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_mx_recordHandler ...
type Azurerm_dns_mx_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_mx_recordHandler) Create(desired *Azurerm_dns_mx_record) (*Azurerm_dns_mx_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_mx_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_mx_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_mx_recordHandler) Update(externalID string, desired *Azurerm_dns_mx_record) (*Azurerm_dns_mx_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_mx_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_mx_record", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_mx_record{ Azurerm_dns_mx_record_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_mx_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_mx_recordHandler) Read(externalID string) (*Azurerm_dns_mx_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_mx_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_mx_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_mx_record{ Azurerm_dns_mx_record_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_mx_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_mx_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_mx_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_mx_record", externalID)
}

type Azurerm_dns_ns_record_record_88 struct {


    Nsdname string

}

type Azurerm_dns_ns_record struct {

	Azurerm_dns_ns_record_id *string `lyra:"ignore"`

    Name string

    Record *[]Azurerm_dns_ns_record_record_88

    Records *[]string

    Resource_group_name string

    Tags *map[string]string

    Ttl int

    Zone_name string

}

var Azurerm_dns_ns_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_ns_record_id",

		"record",

		"records",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_ns_recordHandler ...
type Azurerm_dns_ns_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_ns_recordHandler) Create(desired *Azurerm_dns_ns_record) (*Azurerm_dns_ns_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_ns_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_ns_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_ns_recordHandler) Update(externalID string, desired *Azurerm_dns_ns_record) (*Azurerm_dns_ns_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_ns_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_ns_record", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_ns_record{ Azurerm_dns_ns_record_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_ns_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_ns_recordHandler) Read(externalID string) (*Azurerm_dns_ns_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_ns_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_ns_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_ns_record{ Azurerm_dns_ns_record_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_ns_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_ns_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_ns_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_ns_record", externalID)
}

type Azurerm_dns_ptr_record struct {

	Azurerm_dns_ptr_record_id *string `lyra:"ignore"`

    Name string

    Records []string

    Resource_group_name string

    Tags *map[string]string

    Ttl int

    Zone_name string

}

var Azurerm_dns_ptr_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_ptr_record_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_ptr_recordHandler ...
type Azurerm_dns_ptr_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_ptr_recordHandler) Create(desired *Azurerm_dns_ptr_record) (*Azurerm_dns_ptr_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_ptr_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_ptr_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_ptr_recordHandler) Update(externalID string, desired *Azurerm_dns_ptr_record) (*Azurerm_dns_ptr_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_ptr_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_ptr_record", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_ptr_record{ Azurerm_dns_ptr_record_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_ptr_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_ptr_recordHandler) Read(externalID string) (*Azurerm_dns_ptr_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_ptr_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_ptr_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_ptr_record{ Azurerm_dns_ptr_record_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_ptr_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_ptr_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_ptr_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_ptr_record", externalID)
}

type Azurerm_dns_srv_record_record_89 struct {


    Port int

    Priority int

    Target string

    Weight int

}

type Azurerm_dns_srv_record struct {

	Azurerm_dns_srv_record_id *string `lyra:"ignore"`

    Name string

    Record []Azurerm_dns_srv_record_record_89

    Resource_group_name string

    Tags *map[string]string

    Ttl int

    Zone_name string

}

var Azurerm_dns_srv_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_srv_record_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_srv_recordHandler ...
type Azurerm_dns_srv_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_srv_recordHandler) Create(desired *Azurerm_dns_srv_record) (*Azurerm_dns_srv_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_srv_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_srv_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_srv_recordHandler) Update(externalID string, desired *Azurerm_dns_srv_record) (*Azurerm_dns_srv_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_srv_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_srv_record", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_srv_record{ Azurerm_dns_srv_record_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_srv_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_srv_recordHandler) Read(externalID string) (*Azurerm_dns_srv_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_srv_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_srv_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_srv_record{ Azurerm_dns_srv_record_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_srv_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_srv_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_srv_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_srv_record", externalID)
}

type Azurerm_dns_txt_record_record_90 struct {


    Value string

}

type Azurerm_dns_txt_record struct {

	Azurerm_dns_txt_record_id *string `lyra:"ignore"`

    Name string

    Record []Azurerm_dns_txt_record_record_90

    Resource_group_name string

    Tags *map[string]string

    Ttl int

    Zone_name string

}

var Azurerm_dns_txt_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_txt_record_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_txt_recordHandler ...
type Azurerm_dns_txt_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_txt_recordHandler) Create(desired *Azurerm_dns_txt_record) (*Azurerm_dns_txt_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_txt_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_txt_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_txt_recordHandler) Update(externalID string, desired *Azurerm_dns_txt_record) (*Azurerm_dns_txt_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_txt_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_txt_record", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_txt_record{ Azurerm_dns_txt_record_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_txt_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_txt_recordHandler) Read(externalID string) (*Azurerm_dns_txt_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_txt_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_txt_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_txt_record{ Azurerm_dns_txt_record_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_txt_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_txt_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_txt_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_txt_record", externalID)
}

type Azurerm_dns_zone struct {

	Azurerm_dns_zone_id *string `lyra:"ignore"`

    Max_number_of_record_sets *int

    Name string

    Name_servers *[]string

    Number_of_record_sets *int

    Registration_virtual_network_ids *[]string

    Resolution_virtual_network_ids *[]string

    Resource_group_name string

    Tags *map[string]string

    Zone_type *string

}

var Azurerm_dns_zone_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_zone_id",

		"max_number_of_record_sets",

		"name_servers",

		"number_of_record_sets",

		"registration_virtual_network_ids",

		"resolution_virtual_network_ids",

		"tags",

		"zone_type",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_dns_zoneHandler ...
type Azurerm_dns_zoneHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_zoneHandler) Create(desired *Azurerm_dns_zone) (*Azurerm_dns_zone, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_zone", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_zone", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_zoneHandler) Update(externalID string, desired *Azurerm_dns_zone) (*Azurerm_dns_zone, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_zone", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_zone", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_zone{ Azurerm_dns_zone_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_zone", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_zoneHandler) Read(externalID string) (*Azurerm_dns_zone, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_zone", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_zone", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_zone{ Azurerm_dns_zone_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_zone", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_zoneHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_zone", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_zone", externalID)
}

type Azurerm_eventgrid_topic struct {

	Azurerm_eventgrid_topic_id *string `lyra:"ignore"`

    Endpoint *string

    Location string

    Name string

    Primary_access_key *string

    Resource_group_name string

    Secondary_access_key *string

    Tags *map[string]string

}

var Azurerm_eventgrid_topic_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventgrid_topic_id",

		"endpoint",

		"primary_access_key",

		"secondary_access_key",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_eventgrid_topicHandler ...
type Azurerm_eventgrid_topicHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventgrid_topicHandler) Create(desired *Azurerm_eventgrid_topic) (*Azurerm_eventgrid_topic, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventgrid_topic", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventgrid_topic", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventgrid_topicHandler) Update(externalID string, desired *Azurerm_eventgrid_topic) (*Azurerm_eventgrid_topic, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventgrid_topic", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventgrid_topic", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventgrid_topic{ Azurerm_eventgrid_topic_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventgrid_topic", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventgrid_topicHandler) Read(externalID string) (*Azurerm_eventgrid_topic, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventgrid_topic", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventgrid_topic", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventgrid_topic{ Azurerm_eventgrid_topic_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventgrid_topic", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventgrid_topicHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventgrid_topic", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventgrid_topic", externalID)
}

type Azurerm_eventhub_capture_description_91_destination_92 struct {


    Archive_name_format string

    Blob_container_name string

    Name string

    Storage_account_id string

}

type Azurerm_eventhub_capture_description_91 struct {


    Destination []Azurerm_eventhub_capture_description_91_destination_92

    Enabled bool

    Encoding string

    Interval_in_seconds *int

    Size_limit_in_bytes *int

}

type Azurerm_eventhub struct {

	Azurerm_eventhub_id *string `lyra:"ignore"`

    Capture_description *[]Azurerm_eventhub_capture_description_91

    Location *string

    Message_retention int

    Name string

    Namespace_name string

    Partition_count int

    Partition_ids *[]string

    Resource_group_name string

}

var Azurerm_eventhub_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_id",

		"capture_description",

		"location",

		"partition_ids",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"namespace_name",

		"partition_count",

		"resource_group_name",

	)
}

// Azurerm_eventhubHandler ...
type Azurerm_eventhubHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhubHandler) Create(desired *Azurerm_eventhub) (*Azurerm_eventhub, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhubHandler) Update(externalID string, desired *Azurerm_eventhub) (*Azurerm_eventhub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub{ Azurerm_eventhub_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhubHandler) Read(externalID string) (*Azurerm_eventhub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub{ Azurerm_eventhub_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhubHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub", externalID)
}

type Azurerm_eventhub_authorization_rule struct {

	Azurerm_eventhub_authorization_rule_id *string `lyra:"ignore"`

    Eventhub_name string

    Listen *bool

    Location *string

    Manage *bool

    Name string

    Namespace_name string

    Primary_connection_string *string

    Primary_key *string

    Resource_group_name string

    Secondary_connection_string *string

    Secondary_key *string

    Send *bool

}

var Azurerm_eventhub_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_authorization_rule_id",

		"listen",

		"location",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",

	)
	rtb.ImmutableAttributes(

		"eventhub_name",

		"location",

		"name",

		"namespace_name",

		"resource_group_name",

	)
}

// Azurerm_eventhub_authorization_ruleHandler ...
type Azurerm_eventhub_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhub_authorization_ruleHandler) Create(desired *Azurerm_eventhub_authorization_rule) (*Azurerm_eventhub_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhub_authorization_ruleHandler) Update(externalID string, desired *Azurerm_eventhub_authorization_rule) (*Azurerm_eventhub_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub_authorization_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_authorization_rule{ Azurerm_eventhub_authorization_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhub_authorization_ruleHandler) Read(externalID string) (*Azurerm_eventhub_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_authorization_rule{ Azurerm_eventhub_authorization_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhub_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub_authorization_rule", externalID)
}

type Azurerm_eventhub_consumer_group struct {

	Azurerm_eventhub_consumer_group_id *string `lyra:"ignore"`

    Eventhub_name string

    Location *string

    Name string

    Namespace_name string

    Resource_group_name string

    User_metadata *string

}

var Azurerm_eventhub_consumer_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_consumer_group_id",

		"location",

		"user_metadata",

	)
	rtb.ImmutableAttributes(

		"eventhub_name",

		"location",

		"name",

		"namespace_name",

		"resource_group_name",

	)
}

// Azurerm_eventhub_consumer_groupHandler ...
type Azurerm_eventhub_consumer_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhub_consumer_groupHandler) Create(desired *Azurerm_eventhub_consumer_group) (*Azurerm_eventhub_consumer_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub_consumer_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub_consumer_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhub_consumer_groupHandler) Update(externalID string, desired *Azurerm_eventhub_consumer_group) (*Azurerm_eventhub_consumer_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub_consumer_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub_consumer_group", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_consumer_group{ Azurerm_eventhub_consumer_group_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub_consumer_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhub_consumer_groupHandler) Read(externalID string) (*Azurerm_eventhub_consumer_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub_consumer_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub_consumer_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_consumer_group{ Azurerm_eventhub_consumer_group_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub_consumer_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhub_consumer_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub_consumer_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub_consumer_group", externalID)
}

type Azurerm_eventhub_namespace struct {

	Azurerm_eventhub_namespace_id *string `lyra:"ignore"`

    Auto_inflate_enabled *bool

    Capacity *int

    Default_primary_connection_string *string

    Default_primary_key *string

    Default_secondary_connection_string *string

    Default_secondary_key *string

    Kafka_enabled *bool

    Location string

    Maximum_throughput_units *int

    Name string

    Resource_group_name string

    Sku string

    Tags *map[string]string

}

var Azurerm_eventhub_namespace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_namespace_id",

		"auto_inflate_enabled",

		"capacity",

		"default_primary_connection_string",

		"default_primary_key",

		"default_secondary_connection_string",

		"default_secondary_key",

		"kafka_enabled",

		"maximum_throughput_units",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_eventhub_namespaceHandler ...
type Azurerm_eventhub_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhub_namespaceHandler) Create(desired *Azurerm_eventhub_namespace) (*Azurerm_eventhub_namespace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub_namespace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhub_namespaceHandler) Update(externalID string, desired *Azurerm_eventhub_namespace) (*Azurerm_eventhub_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub_namespace", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_namespace{ Azurerm_eventhub_namespace_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhub_namespaceHandler) Read(externalID string) (*Azurerm_eventhub_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub_namespace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_namespace{ Azurerm_eventhub_namespace_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhub_namespaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub_namespace", externalID)
}

type Azurerm_eventhub_namespace_authorization_rule struct {

	Azurerm_eventhub_namespace_authorization_rule_id *string `lyra:"ignore"`

    Listen *bool

    Location *string

    Manage *bool

    Name string

    Namespace_name string

    Primary_connection_string *string

    Primary_key *string

    Resource_group_name string

    Secondary_connection_string *string

    Secondary_key *string

    Send *bool

}

var Azurerm_eventhub_namespace_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_namespace_authorization_rule_id",

		"listen",

		"location",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"namespace_name",

		"resource_group_name",

	)
}

// Azurerm_eventhub_namespace_authorization_ruleHandler ...
type Azurerm_eventhub_namespace_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhub_namespace_authorization_ruleHandler) Create(desired *Azurerm_eventhub_namespace_authorization_rule) (*Azurerm_eventhub_namespace_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub_namespace_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub_namespace_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhub_namespace_authorization_ruleHandler) Update(externalID string, desired *Azurerm_eventhub_namespace_authorization_rule) (*Azurerm_eventhub_namespace_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub_namespace_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub_namespace_authorization_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_namespace_authorization_rule{ Azurerm_eventhub_namespace_authorization_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub_namespace_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhub_namespace_authorization_ruleHandler) Read(externalID string) (*Azurerm_eventhub_namespace_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub_namespace_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub_namespace_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_namespace_authorization_rule{ Azurerm_eventhub_namespace_authorization_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub_namespace_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhub_namespace_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub_namespace_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub_namespace_authorization_rule", externalID)
}

type Azurerm_express_route_circuit_sku_93 struct {


    Family string

    Tier string

}

type Azurerm_express_route_circuit struct {

	Azurerm_express_route_circuit_id *string `lyra:"ignore"`

    Allow_classic_operations *bool

    Bandwidth_in_mbps int

    Location string

    Name string

    Peering_location string

    Resource_group_name string

    Service_key *string

    Service_provider_name string

    Service_provider_provisioning_state *string

    Sku []Azurerm_express_route_circuit_sku_93

    Tags *map[string]string

}

var Azurerm_express_route_circuit_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_express_route_circuit_id",

		"allow_classic_operations",

		"service_key",

		"service_provider_provisioning_state",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"peering_location",

		"resource_group_name",

		"service_provider_name",

	)
}

// Azurerm_express_route_circuitHandler ...
type Azurerm_express_route_circuitHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_express_route_circuitHandler) Create(desired *Azurerm_express_route_circuit) (*Azurerm_express_route_circuit, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_express_route_circuit", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_express_route_circuit", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_express_route_circuitHandler) Update(externalID string, desired *Azurerm_express_route_circuit) (*Azurerm_express_route_circuit, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_express_route_circuit", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_express_route_circuit", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit{ Azurerm_express_route_circuit_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_express_route_circuit", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_express_route_circuitHandler) Read(externalID string) (*Azurerm_express_route_circuit, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_express_route_circuit", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_express_route_circuit", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit{ Azurerm_express_route_circuit_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_express_route_circuit", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_express_route_circuitHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_express_route_circuit", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_express_route_circuit", externalID)
}

type Azurerm_express_route_circuit_authorization struct {

	Azurerm_express_route_circuit_authorization_id *string `lyra:"ignore"`

    Authorization_key *string

    Authorization_use_status *string

    Express_route_circuit_name string

    Name string

    Resource_group_name string

}

var Azurerm_express_route_circuit_authorization_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_express_route_circuit_authorization_id",

		"authorization_key",

		"authorization_use_status",

	)
	rtb.ImmutableAttributes(

		"express_route_circuit_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_express_route_circuit_authorizationHandler ...
type Azurerm_express_route_circuit_authorizationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_express_route_circuit_authorizationHandler) Create(desired *Azurerm_express_route_circuit_authorization) (*Azurerm_express_route_circuit_authorization, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_express_route_circuit_authorization", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_express_route_circuit_authorization", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_express_route_circuit_authorizationHandler) Update(externalID string, desired *Azurerm_express_route_circuit_authorization) (*Azurerm_express_route_circuit_authorization, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_express_route_circuit_authorization", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_express_route_circuit_authorization", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit_authorization{ Azurerm_express_route_circuit_authorization_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_express_route_circuit_authorization", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_express_route_circuit_authorizationHandler) Read(externalID string) (*Azurerm_express_route_circuit_authorization, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_express_route_circuit_authorization", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_express_route_circuit_authorization", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit_authorization{ Azurerm_express_route_circuit_authorization_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_express_route_circuit_authorization", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_express_route_circuit_authorizationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_express_route_circuit_authorization", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_express_route_circuit_authorization", externalID)
}

type Azurerm_express_route_circuit_peering_microsoft_peering_config_94 struct {


    Advertised_public_prefixes []string

}

type Azurerm_express_route_circuit_peering struct {

	Azurerm_express_route_circuit_peering_id *string `lyra:"ignore"`

    Azure_asn *int

    Express_route_circuit_name string

    Microsoft_peering_config *[]Azurerm_express_route_circuit_peering_microsoft_peering_config_94

    Peer_asn *int

    Peering_type string

    Primary_azure_port *string

    Primary_peer_address_prefix string

    Resource_group_name string

    Secondary_azure_port *string

    Secondary_peer_address_prefix string

    Shared_key *string

    Vlan_id int

}

var Azurerm_express_route_circuit_peering_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_express_route_circuit_peering_id",

		"azure_asn",

		"microsoft_peering_config",

		"peer_asn",

		"primary_azure_port",

		"secondary_azure_port",

		"shared_key",

	)
	rtb.ImmutableAttributes(

		"express_route_circuit_name",

		"resource_group_name",

	)
}

// Azurerm_express_route_circuit_peeringHandler ...
type Azurerm_express_route_circuit_peeringHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_express_route_circuit_peeringHandler) Create(desired *Azurerm_express_route_circuit_peering) (*Azurerm_express_route_circuit_peering, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_express_route_circuit_peering", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_express_route_circuit_peering", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_express_route_circuit_peeringHandler) Update(externalID string, desired *Azurerm_express_route_circuit_peering) (*Azurerm_express_route_circuit_peering, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_express_route_circuit_peering", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_express_route_circuit_peering", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit_peering{ Azurerm_express_route_circuit_peering_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_express_route_circuit_peering", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_express_route_circuit_peeringHandler) Read(externalID string) (*Azurerm_express_route_circuit_peering, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_express_route_circuit_peering", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_express_route_circuit_peering", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit_peering{ Azurerm_express_route_circuit_peering_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_express_route_circuit_peering", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_express_route_circuit_peeringHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_express_route_circuit_peering", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_express_route_circuit_peering", externalID)
}

type Azurerm_firewall_ip_configuration_95 struct {


    Internal_public_ip_address_id *string

    Name string

    Private_ip_address *string

    Public_ip_address_id *string

    Subnet_id string

}

type Azurerm_firewall struct {

	Azurerm_firewall_id *string `lyra:"ignore"`

    Ip_configuration []Azurerm_firewall_ip_configuration_95

    Location string

    Name string

    Resource_group_name string

    Tags *map[string]string

}

var Azurerm_firewall_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_firewall_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_firewallHandler ...
type Azurerm_firewallHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_firewallHandler) Create(desired *Azurerm_firewall) (*Azurerm_firewall, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_firewall", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_firewall", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_firewallHandler) Update(externalID string, desired *Azurerm_firewall) (*Azurerm_firewall, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_firewall", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_firewall", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall{ Azurerm_firewall_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_firewall", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_firewallHandler) Read(externalID string) (*Azurerm_firewall, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_firewall", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_firewall", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall{ Azurerm_firewall_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_firewall", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_firewallHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_firewall", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_firewall", externalID)
}

type Azurerm_firewall_application_rule_collection_rule_96_protocol_97 struct {


    Port *int

    Type string

}

type Azurerm_firewall_application_rule_collection_rule_96 struct {


    Description *string

    Fqdn_tags *[]string

    Name string

    Protocol *[]Azurerm_firewall_application_rule_collection_rule_96_protocol_97

    Source_addresses []string

    Target_fqdns *[]string

}

type Azurerm_firewall_application_rule_collection struct {

	Azurerm_firewall_application_rule_collection_id *string `lyra:"ignore"`

    Action string

    Azure_firewall_name string

    Name string

    Priority int

    Resource_group_name string

    Rule []Azurerm_firewall_application_rule_collection_rule_96

}

var Azurerm_firewall_application_rule_collection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_firewall_application_rule_collection_id",

	)
	rtb.ImmutableAttributes(

		"azure_firewall_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_firewall_application_rule_collectionHandler ...
type Azurerm_firewall_application_rule_collectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_firewall_application_rule_collectionHandler) Create(desired *Azurerm_firewall_application_rule_collection) (*Azurerm_firewall_application_rule_collection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_firewall_application_rule_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_firewall_application_rule_collection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_firewall_application_rule_collectionHandler) Update(externalID string, desired *Azurerm_firewall_application_rule_collection) (*Azurerm_firewall_application_rule_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_firewall_application_rule_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_firewall_application_rule_collection", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall_application_rule_collection{ Azurerm_firewall_application_rule_collection_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_firewall_application_rule_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_firewall_application_rule_collectionHandler) Read(externalID string) (*Azurerm_firewall_application_rule_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_firewall_application_rule_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_firewall_application_rule_collection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall_application_rule_collection{ Azurerm_firewall_application_rule_collection_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_firewall_application_rule_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_firewall_application_rule_collectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_firewall_application_rule_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_firewall_application_rule_collection", externalID)
}

type Azurerm_firewall_network_rule_collection_rule_98 struct {


    Description *string

    Destination_addresses []string

    Destination_ports []string

    Name string

    Protocols []string

    Source_addresses []string

}

type Azurerm_firewall_network_rule_collection struct {

	Azurerm_firewall_network_rule_collection_id *string `lyra:"ignore"`

    Action string

    Azure_firewall_name string

    Name string

    Priority int

    Resource_group_name string

    Rule []Azurerm_firewall_network_rule_collection_rule_98

}

var Azurerm_firewall_network_rule_collection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_firewall_network_rule_collection_id",

	)
	rtb.ImmutableAttributes(

		"azure_firewall_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_firewall_network_rule_collectionHandler ...
type Azurerm_firewall_network_rule_collectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_firewall_network_rule_collectionHandler) Create(desired *Azurerm_firewall_network_rule_collection) (*Azurerm_firewall_network_rule_collection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_firewall_network_rule_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_firewall_network_rule_collection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_firewall_network_rule_collectionHandler) Update(externalID string, desired *Azurerm_firewall_network_rule_collection) (*Azurerm_firewall_network_rule_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_firewall_network_rule_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_firewall_network_rule_collection", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall_network_rule_collection{ Azurerm_firewall_network_rule_collection_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_firewall_network_rule_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_firewall_network_rule_collectionHandler) Read(externalID string) (*Azurerm_firewall_network_rule_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_firewall_network_rule_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_firewall_network_rule_collection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall_network_rule_collection{ Azurerm_firewall_network_rule_collection_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_firewall_network_rule_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_firewall_network_rule_collectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_firewall_network_rule_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_firewall_network_rule_collection", externalID)
}

type Azurerm_function_app_connection_string_99 struct {


    Name string

    Type string

    Value string

}

type Azurerm_function_app_identity_100 struct {


    Principal_id *string

    Tenant_id *string

    Type string

}

type Azurerm_function_app_site_config_101 struct {


    Always_on *bool

    Use_32_bit_worker_process *bool

    Websockets_enabled *bool

}

type Azurerm_function_app_site_credential_102 struct {


    Password *string

    Username *string

}

type Azurerm_function_app struct {

	Azurerm_function_app_id *string `lyra:"ignore"`

    App_service_plan_id string

    App_settings *map[string]string

    Client_affinity_enabled *bool

    Connection_string *[]Azurerm_function_app_connection_string_99

    Default_hostname *string

    Enable_builtin_logging *bool

    Enabled *bool

    Https_only *bool

    Identity *[]Azurerm_function_app_identity_100

    Location string

    Name string

    Outbound_ip_addresses *string

    Resource_group_name string

    Site_config *[]Azurerm_function_app_site_config_101

    Site_credential *[]Azurerm_function_app_site_credential_102

    Storage_connection_string string

    Tags *map[string]string

    Version *string

}

var Azurerm_function_app_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_function_app_id",

		"app_settings",

		"client_affinity_enabled",

		"connection_string",

		"default_hostname",

		"enable_builtin_logging",

		"enabled",

		"https_only",

		"identity",

		"outbound_ip_addresses",

		"site_config",

		"site_credential",

		"tags",

		"version",

	)
	rtb.ImmutableAttributes(

		"app_service_plan_id",

		"location",

		"name",

		"resource_group_name",

		"storage_connection_string",

	)
}

// Azurerm_function_appHandler ...
type Azurerm_function_appHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_function_appHandler) Create(desired *Azurerm_function_app) (*Azurerm_function_app, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_function_app", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_function_app", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_function_appHandler) Update(externalID string, desired *Azurerm_function_app) (*Azurerm_function_app, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_function_app", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_function_app", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_function_app{ Azurerm_function_app_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_function_app", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_function_appHandler) Read(externalID string) (*Azurerm_function_app, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_function_app", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_function_app", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_function_app{ Azurerm_function_app_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_function_app", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_function_appHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_function_app", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_function_app", externalID)
}

type Azurerm_image_data_disk_103 struct {


    Blob_uri *string

    Caching *string

    Lun *int

    Managed_disk_id *string

    Size_gb *int

}

type Azurerm_image_os_disk_104 struct {


    Blob_uri *string

    Caching *string

    Managed_disk_id *string

    Os_state *string

    Os_type *string

    Size_gb *int

}

type Azurerm_image struct {

	Azurerm_image_id *string `lyra:"ignore"`

    Data_disk *[]Azurerm_image_data_disk_103

    Location string

    Name string

    Os_disk *[]Azurerm_image_os_disk_104

    Resource_group_name string

    Source_virtual_machine_id *string

    Tags *map[string]string

}

var Azurerm_image_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_image_id",

		"data_disk",

		"os_disk",

		"source_virtual_machine_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"os_disk",

		"resource_group_name",

	)
}

// Azurerm_imageHandler ...
type Azurerm_imageHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_imageHandler) Create(desired *Azurerm_image) (*Azurerm_image, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_image", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_image", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_imageHandler) Update(externalID string, desired *Azurerm_image) (*Azurerm_image, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_image", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_image", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_image{ Azurerm_image_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_image", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_imageHandler) Read(externalID string) (*Azurerm_image, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_image", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_image", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_image{ Azurerm_image_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_image", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_imageHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_image", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_image", externalID)
}

type Azurerm_iothub_endpoint_105 struct {


    Batch_frequency_in_seconds *int

    Connection_string string

    Container_name *string

    Encoding *string

    File_name_format *string

    Max_chunk_size_in_bytes *int

    Name string

    Type string

}

type Azurerm_iothub_route_106 struct {


    Condition *string

    Enabled bool

    Endpoint_names []string

    Name string

    Source string

}

type Azurerm_iothub_shared_access_policy_107 struct {


    Key_name *string

    Permissions *string

    Primary_key *string

    Secondary_key *string

}

type Azurerm_iothub_sku_108 struct {


    Capacity int

    Name string

    Tier string

}

type Azurerm_iothub struct {

	Azurerm_iothub_id *string `lyra:"ignore"`

    Endpoint *[]Azurerm_iothub_endpoint_105

    Event_hub_events_endpoint *string

    Event_hub_events_path *string

    Event_hub_operations_endpoint *string

    Event_hub_operations_path *string

    Hostname *string

    Location string

    Name string

    Resource_group_name string

    Route *[]Azurerm_iothub_route_106

    Shared_access_policy *[]Azurerm_iothub_shared_access_policy_107

    Sku []Azurerm_iothub_sku_108

    Tags *map[string]string

    Type *string

}

var Azurerm_iothub_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_iothub_id",

		"endpoint",

		"event_hub_events_endpoint",

		"event_hub_events_path",

		"event_hub_operations_endpoint",

		"event_hub_operations_path",

		"hostname",

		"route",

		"shared_access_policy",

		"tags",

		"type",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_iothubHandler ...
type Azurerm_iothubHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_iothubHandler) Create(desired *Azurerm_iothub) (*Azurerm_iothub, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_iothub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_iothub", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_iothubHandler) Update(externalID string, desired *Azurerm_iothub) (*Azurerm_iothub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_iothub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_iothub", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_iothub{ Azurerm_iothub_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_iothub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_iothubHandler) Read(externalID string) (*Azurerm_iothub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_iothub", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_iothub", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_iothub{ Azurerm_iothub_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_iothub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_iothubHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_iothub", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_iothub", externalID)
}

type Azurerm_iothub_consumer_group struct {

	Azurerm_iothub_consumer_group_id *string `lyra:"ignore"`

    Eventhub_endpoint_name string

    Iothub_name string

    Name string

    Resource_group_name string

}

var Azurerm_iothub_consumer_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_iothub_consumer_group_id",

	)
	rtb.ImmutableAttributes(

		"eventhub_endpoint_name",

		"iothub_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_iothub_consumer_groupHandler ...
type Azurerm_iothub_consumer_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_iothub_consumer_groupHandler) Create(desired *Azurerm_iothub_consumer_group) (*Azurerm_iothub_consumer_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_iothub_consumer_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_iothub_consumer_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_iothub_consumer_groupHandler) Update(externalID string, desired *Azurerm_iothub_consumer_group) (*Azurerm_iothub_consumer_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_iothub_consumer_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_iothub_consumer_group", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_iothub_consumer_group{ Azurerm_iothub_consumer_group_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_iothub_consumer_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_iothub_consumer_groupHandler) Read(externalID string) (*Azurerm_iothub_consumer_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_iothub_consumer_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_iothub_consumer_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_iothub_consumer_group{ Azurerm_iothub_consumer_group_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_iothub_consumer_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_iothub_consumer_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_iothub_consumer_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_iothub_consumer_group", externalID)
}

type Azurerm_key_vault_access_policy_109 struct {


    Application_id *string

    Certificate_permissions *[]string

    Key_permissions *[]string

    Object_id string

    Secret_permissions *[]string

    Tenant_id string

}

type Azurerm_key_vault_network_acls_110 struct {


    Bypass string

    Default_action string

    Ip_rules *[]string

    Virtual_network_subnet_ids *[]string

}

type Azurerm_key_vault_sku_111 struct {


    Name string

}

type Azurerm_key_vault struct {

	Azurerm_key_vault_id *string `lyra:"ignore"`

    Access_policy *[]Azurerm_key_vault_access_policy_109

    Enabled_for_deployment *bool

    Enabled_for_disk_encryption *bool

    Enabled_for_template_deployment *bool

    Location string

    Name string

    Network_acls *[]Azurerm_key_vault_network_acls_110

    Resource_group_name string

    Sku []Azurerm_key_vault_sku_111

    Tags *map[string]string

    Tenant_id string

    Vault_uri *string

}

var Azurerm_key_vault_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_id",

		"access_policy",

		"enabled_for_deployment",

		"enabled_for_disk_encryption",

		"enabled_for_template_deployment",

		"network_acls",

		"tags",

		"vault_uri",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_key_vaultHandler ...
type Azurerm_key_vaultHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vaultHandler) Create(desired *Azurerm_key_vault) (*Azurerm_key_vault, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vaultHandler) Update(externalID string, desired *Azurerm_key_vault) (*Azurerm_key_vault, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault{ Azurerm_key_vault_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vaultHandler) Read(externalID string) (*Azurerm_key_vault, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault{ Azurerm_key_vault_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vaultHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault", externalID)
}

type Azurerm_key_vault_access_policy struct {

	Azurerm_key_vault_access_policy_id *string `lyra:"ignore"`

    Application_id *string

    Certificate_permissions *[]string

    Key_permissions *[]string

    Object_id string

    Resource_group_name string

    Secret_permissions *[]string

    Tenant_id string

    Vault_name string

}

var Azurerm_key_vault_access_policy_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_access_policy_id",

		"application_id",

		"certificate_permissions",

		"key_permissions",

		"secret_permissions",

	)
	rtb.ImmutableAttributes(

		"application_id",

		"object_id",

		"resource_group_name",

		"tenant_id",

		"vault_name",

	)
}

// Azurerm_key_vault_access_policyHandler ...
type Azurerm_key_vault_access_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vault_access_policyHandler) Create(desired *Azurerm_key_vault_access_policy) (*Azurerm_key_vault_access_policy, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault_access_policy", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault_access_policy", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vault_access_policyHandler) Update(externalID string, desired *Azurerm_key_vault_access_policy) (*Azurerm_key_vault_access_policy, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault_access_policy", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault_access_policy", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_access_policy{ Azurerm_key_vault_access_policy_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault_access_policy", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vault_access_policyHandler) Read(externalID string) (*Azurerm_key_vault_access_policy, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault_access_policy", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault_access_policy", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_access_policy{ Azurerm_key_vault_access_policy_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault_access_policy", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vault_access_policyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault_access_policy", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault_access_policy", externalID)
}

type Azurerm_key_vault_certificate_certificate_112 struct {


    Contents string

    Password *string

}

type Azurerm_key_vault_certificate_certificate_policy_113_issuer_parameters_114 struct {


    Name string

}

type Azurerm_key_vault_certificate_certificate_policy_113_key_properties_115 struct {


    Exportable bool

    Key_size int

    Key_type string

    Reuse_key bool

}

type Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116_action_117 struct {


    Action_type string

}

type Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116_trigger_118 struct {


    Days_before_expiry *int

    Lifetime_percentage *int

}

type Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116 struct {


    Action []Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116_action_117

    Trigger []Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116_trigger_118

}

type Azurerm_key_vault_certificate_certificate_policy_113_secret_properties_119 struct {


    Content_type string

}

type Azurerm_key_vault_certificate_certificate_policy_113_x509_certificate_properties_120_subject_alternative_names_121 struct {


    Dns_names *[]string

    Emails *[]string

    Upns *[]string

}

type Azurerm_key_vault_certificate_certificate_policy_113_x509_certificate_properties_120 struct {


    Extended_key_usage *[]string

    Key_usage []string

    Subject string

    Subject_alternative_names *[]Azurerm_key_vault_certificate_certificate_policy_113_x509_certificate_properties_120_subject_alternative_names_121

    Validity_in_months int

}

type Azurerm_key_vault_certificate_certificate_policy_113 struct {


    Issuer_parameters []Azurerm_key_vault_certificate_certificate_policy_113_issuer_parameters_114

    Key_properties []Azurerm_key_vault_certificate_certificate_policy_113_key_properties_115

    Lifetime_action *[]Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116

    Secret_properties []Azurerm_key_vault_certificate_certificate_policy_113_secret_properties_119

    X509_certificate_properties *[]Azurerm_key_vault_certificate_certificate_policy_113_x509_certificate_properties_120

}

type Azurerm_key_vault_certificate struct {

	Azurerm_key_vault_certificate_id *string `lyra:"ignore"`

    Certificate *[]Azurerm_key_vault_certificate_certificate_112

    Certificate_data *string

    Certificate_policy []Azurerm_key_vault_certificate_certificate_policy_113

    Name string

    Secret_id *string

    Tags *map[string]string

    Thumbprint *string

    Vault_uri string

    Version *string

}

var Azurerm_key_vault_certificate_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_certificate_id",

		"certificate",

		"certificate_data",

		"secret_id",

		"tags",

		"thumbprint",

		"version",

	)
	rtb.ImmutableAttributes(

		"certificate",

		"certificate_policy",

		"name",

		"vault_uri",

	)
}

// Azurerm_key_vault_certificateHandler ...
type Azurerm_key_vault_certificateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vault_certificateHandler) Create(desired *Azurerm_key_vault_certificate) (*Azurerm_key_vault_certificate, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault_certificate", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault_certificate", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vault_certificateHandler) Update(externalID string, desired *Azurerm_key_vault_certificate) (*Azurerm_key_vault_certificate, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault_certificate", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault_certificate", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_certificate{ Azurerm_key_vault_certificate_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault_certificate", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vault_certificateHandler) Read(externalID string) (*Azurerm_key_vault_certificate, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault_certificate", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault_certificate", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_certificate{ Azurerm_key_vault_certificate_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault_certificate", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vault_certificateHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault_certificate", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault_certificate", externalID)
}

type Azurerm_key_vault_key struct {

	Azurerm_key_vault_key_id *string `lyra:"ignore"`

    E *string

    Key_opts []string

    Key_size int

    Key_type string

    N *string

    Name string

    Tags *map[string]string

    Vault_uri string

    Version *string

}

var Azurerm_key_vault_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_key_id",

		"e",

		"n",

		"tags",

		"version",

	)
	rtb.ImmutableAttributes(

		"key_size",

		"key_type",

		"name",

		"vault_uri",

	)
}

// Azurerm_key_vault_keyHandler ...
type Azurerm_key_vault_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vault_keyHandler) Create(desired *Azurerm_key_vault_key) (*Azurerm_key_vault_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vault_keyHandler) Update(externalID string, desired *Azurerm_key_vault_key) (*Azurerm_key_vault_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault_key", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_key{ Azurerm_key_vault_key_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vault_keyHandler) Read(externalID string) (*Azurerm_key_vault_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_key{ Azurerm_key_vault_key_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vault_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault_key", externalID)
}

type Azurerm_key_vault_secret struct {

	Azurerm_key_vault_secret_id *string `lyra:"ignore"`

    Content_type *string

    Name string

    Tags *map[string]string

    Value string

    Vault_uri string

    Version *string

}

var Azurerm_key_vault_secret_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_secret_id",

		"content_type",

		"tags",

		"version",

	)
	rtb.ImmutableAttributes(

		"name",

		"vault_uri",

	)
}

// Azurerm_key_vault_secretHandler ...
type Azurerm_key_vault_secretHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vault_secretHandler) Create(desired *Azurerm_key_vault_secret) (*Azurerm_key_vault_secret, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault_secret", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault_secret", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vault_secretHandler) Update(externalID string, desired *Azurerm_key_vault_secret) (*Azurerm_key_vault_secret, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault_secret", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault_secret", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_secret{ Azurerm_key_vault_secret_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault_secret", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vault_secretHandler) Read(externalID string) (*Azurerm_key_vault_secret, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault_secret", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault_secret", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_secret{ Azurerm_key_vault_secret_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault_secret", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vault_secretHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault_secret", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault_secret", externalID)
}

type Azurerm_kubernetes_cluster_addon_profile_122_aci_connector_linux_123 struct {


    Enabled bool

    Subnet_name string

}

type Azurerm_kubernetes_cluster_addon_profile_122_http_application_routing_124 struct {


    Enabled bool

    Http_application_routing_zone_name *string

}

type Azurerm_kubernetes_cluster_addon_profile_122_oms_agent_125 struct {


    Enabled bool

    Log_analytics_workspace_id string

}

type Azurerm_kubernetes_cluster_addon_profile_122 struct {


    Aci_connector_linux *[]Azurerm_kubernetes_cluster_addon_profile_122_aci_connector_linux_123

    Http_application_routing *[]Azurerm_kubernetes_cluster_addon_profile_122_http_application_routing_124

    Oms_agent *[]Azurerm_kubernetes_cluster_addon_profile_122_oms_agent_125

}

type Azurerm_kubernetes_cluster_agent_pool_profile_126 struct {


    Count *int

    Dns_prefix *string

    Fqdn *string

    Max_pods *int

    Name string

    Os_disk_size_gb *int

    Os_type *string

    Vm_size string

    Vnet_subnet_id *string

}

type Azurerm_kubernetes_cluster_kube_admin_config_127 struct {


    Client_certificate *string

    Client_key *string

    Cluster_ca_certificate *string

    Host *string

    Password *string

    Username *string

}

type Azurerm_kubernetes_cluster_kube_config_128 struct {


    Client_certificate *string

    Client_key *string

    Cluster_ca_certificate *string

    Host *string

    Password *string

    Username *string

}

type Azurerm_kubernetes_cluster_linux_profile_129_ssh_key_130 struct {


    Key_data string

}

type Azurerm_kubernetes_cluster_linux_profile_129 struct {


    Admin_username string

    Ssh_key []Azurerm_kubernetes_cluster_linux_profile_129_ssh_key_130

}

type Azurerm_kubernetes_cluster_network_profile_131 struct {


    Dns_service_ip *string

    Docker_bridge_cidr *string

    Network_plugin string

    Pod_cidr *string

    Service_cidr *string

}

type Azurerm_kubernetes_cluster_role_based_access_control_132_azure_active_directory_133 struct {


    Client_app_id string

    Server_app_id string

    Server_app_secret string

    Tenant_id *string

}

type Azurerm_kubernetes_cluster_role_based_access_control_132 struct {


    Azure_active_directory *[]Azurerm_kubernetes_cluster_role_based_access_control_132_azure_active_directory_133

    Enabled bool

}

type Azurerm_kubernetes_cluster_service_principal_134 struct {


    Client_id string

    Client_secret string

}

type Azurerm_kubernetes_cluster struct {

	Azurerm_kubernetes_cluster_id *string `lyra:"ignore"`

    Addon_profile *[]Azurerm_kubernetes_cluster_addon_profile_122

    Agent_pool_profile []Azurerm_kubernetes_cluster_agent_pool_profile_126

    Dns_prefix string

    Fqdn *string

    Kube_admin_config *[]Azurerm_kubernetes_cluster_kube_admin_config_127

    Kube_admin_config_raw *string

    Kube_config *[]Azurerm_kubernetes_cluster_kube_config_128

    Kube_config_raw *string

    Kubernetes_version *string

    Linux_profile *[]Azurerm_kubernetes_cluster_linux_profile_129

    Location string

    Name string

    Network_profile *[]Azurerm_kubernetes_cluster_network_profile_131

    Node_resource_group *string

    Resource_group_name string

    Role_based_access_control *[]Azurerm_kubernetes_cluster_role_based_access_control_132

    Service_principal []Azurerm_kubernetes_cluster_service_principal_134

    Tags *map[string]string

}

var Azurerm_kubernetes_cluster_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_kubernetes_cluster_id",

		"addon_profile",

		"fqdn",

		"kube_admin_config",

		"kube_admin_config_raw",

		"kube_config",

		"kube_config_raw",

		"kubernetes_version",

		"linux_profile",

		"network_profile",

		"node_resource_group",

		"role_based_access_control",

		"tags",

	)
	rtb.ImmutableAttributes(

		"dns_prefix",

		"location",

		"name",

		"network_profile",

		"resource_group_name",

		"role_based_access_control",

	)
}

// Azurerm_kubernetes_clusterHandler ...
type Azurerm_kubernetes_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_kubernetes_clusterHandler) Create(desired *Azurerm_kubernetes_cluster) (*Azurerm_kubernetes_cluster, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_kubernetes_cluster", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_kubernetes_cluster", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_kubernetes_clusterHandler) Update(externalID string, desired *Azurerm_kubernetes_cluster) (*Azurerm_kubernetes_cluster, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_kubernetes_cluster", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_kubernetes_cluster", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_kubernetes_cluster{ Azurerm_kubernetes_cluster_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_kubernetes_cluster", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_kubernetes_clusterHandler) Read(externalID string) (*Azurerm_kubernetes_cluster, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_kubernetes_cluster", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_kubernetes_cluster", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_kubernetes_cluster{ Azurerm_kubernetes_cluster_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_kubernetes_cluster", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_kubernetes_clusterHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_kubernetes_cluster", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_kubernetes_cluster", externalID)
}

type Azurerm_lb_frontend_ip_configuration_135 struct {


    Inbound_nat_rules *[]string

    Load_balancer_rules *[]string

    Name string

    Private_ip_address *string

    Private_ip_address_allocation *string

    Public_ip_address_id *string

    Subnet_id *string

    Zones *[]string

}

type Azurerm_lb struct {

	Azurerm_lb_id *string `lyra:"ignore"`

    Frontend_ip_configuration *[]Azurerm_lb_frontend_ip_configuration_135

    Location string

    Name string

    Private_ip_address *string

    Private_ip_addresses *[]string

    Resource_group_name string

    Sku *string

    Tags *map[string]string

}

var Azurerm_lb_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_id",

		"frontend_ip_configuration",

		"private_ip_address",

		"private_ip_addresses",

		"sku",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"sku",

	)
}

// Azurerm_lbHandler ...
type Azurerm_lbHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lbHandler) Create(desired *Azurerm_lb) (*Azurerm_lb, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lbHandler) Update(externalID string, desired *Azurerm_lb) (*Azurerm_lb, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb{ Azurerm_lb_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lbHandler) Read(externalID string) (*Azurerm_lb, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb{ Azurerm_lb_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lbHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb", externalID)
}

type Azurerm_lb_backend_address_pool struct {

	Azurerm_lb_backend_address_pool_id *string `lyra:"ignore"`

    Backend_ip_configurations *[]string

    Load_balancing_rules *[]string

    Loadbalancer_id string

    Location *string

    Name string

    Resource_group_name string

}

var Azurerm_lb_backend_address_pool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_backend_address_pool_id",

		"backend_ip_configurations",

		"load_balancing_rules",

		"location",

	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_lb_backend_address_poolHandler ...
type Azurerm_lb_backend_address_poolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_backend_address_poolHandler) Create(desired *Azurerm_lb_backend_address_pool) (*Azurerm_lb_backend_address_pool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_backend_address_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_backend_address_pool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_backend_address_poolHandler) Update(externalID string, desired *Azurerm_lb_backend_address_pool) (*Azurerm_lb_backend_address_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_backend_address_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_backend_address_pool", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_backend_address_pool{ Azurerm_lb_backend_address_pool_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_backend_address_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_backend_address_poolHandler) Read(externalID string) (*Azurerm_lb_backend_address_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_backend_address_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_backend_address_pool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_backend_address_pool{ Azurerm_lb_backend_address_pool_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_backend_address_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_backend_address_poolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_backend_address_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_backend_address_pool", externalID)
}

type Azurerm_lb_nat_pool struct {

	Azurerm_lb_nat_pool_id *string `lyra:"ignore"`

    Backend_port int

    Frontend_ip_configuration_id *string

    Frontend_ip_configuration_name string

    Frontend_port_end int

    Frontend_port_start int

    Loadbalancer_id string

    Location *string

    Name string

    Protocol string

    Resource_group_name string

}

var Azurerm_lb_nat_pool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_nat_pool_id",

		"frontend_ip_configuration_id",

		"location",

	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_lb_nat_poolHandler ...
type Azurerm_lb_nat_poolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_nat_poolHandler) Create(desired *Azurerm_lb_nat_pool) (*Azurerm_lb_nat_pool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_nat_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_nat_pool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_nat_poolHandler) Update(externalID string, desired *Azurerm_lb_nat_pool) (*Azurerm_lb_nat_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_nat_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_nat_pool", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_nat_pool{ Azurerm_lb_nat_pool_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_nat_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_nat_poolHandler) Read(externalID string) (*Azurerm_lb_nat_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_nat_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_nat_pool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_nat_pool{ Azurerm_lb_nat_pool_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_nat_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_nat_poolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_nat_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_nat_pool", externalID)
}

type Azurerm_lb_nat_rule struct {

	Azurerm_lb_nat_rule_id *string `lyra:"ignore"`

    Backend_ip_configuration_id *string

    Backend_port int

    Enable_floating_ip *bool

    Frontend_ip_configuration_id *string

    Frontend_ip_configuration_name string

    Frontend_port int

    Loadbalancer_id string

    Location *string

    Name string

    Protocol string

    Resource_group_name string

}

var Azurerm_lb_nat_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_nat_rule_id",

		"backend_ip_configuration_id",

		"enable_floating_ip",

		"frontend_ip_configuration_id",

		"location",

	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_lb_nat_ruleHandler ...
type Azurerm_lb_nat_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_nat_ruleHandler) Create(desired *Azurerm_lb_nat_rule) (*Azurerm_lb_nat_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_nat_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_nat_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_nat_ruleHandler) Update(externalID string, desired *Azurerm_lb_nat_rule) (*Azurerm_lb_nat_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_nat_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_nat_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_nat_rule{ Azurerm_lb_nat_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_nat_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_nat_ruleHandler) Read(externalID string) (*Azurerm_lb_nat_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_nat_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_nat_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_nat_rule{ Azurerm_lb_nat_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_nat_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_nat_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_nat_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_nat_rule", externalID)
}

type Azurerm_lb_probe struct {

	Azurerm_lb_probe_id *string `lyra:"ignore"`

    Interval_in_seconds *int

    Load_balancer_rules *[]string

    Loadbalancer_id string

    Location *string

    Name string

    Number_of_probes *int

    Port int

    Protocol *string

    Request_path *string

    Resource_group_name string

}

var Azurerm_lb_probe_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_probe_id",

		"interval_in_seconds",

		"load_balancer_rules",

		"location",

		"number_of_probes",

		"protocol",

		"request_path",

	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_lb_probeHandler ...
type Azurerm_lb_probeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_probeHandler) Create(desired *Azurerm_lb_probe) (*Azurerm_lb_probe, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_probe", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_probe", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_probeHandler) Update(externalID string, desired *Azurerm_lb_probe) (*Azurerm_lb_probe, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_probe", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_probe", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_probe{ Azurerm_lb_probe_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_probe", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_probeHandler) Read(externalID string) (*Azurerm_lb_probe, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_probe", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_probe", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_probe{ Azurerm_lb_probe_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_probe", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_probeHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_probe", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_probe", externalID)
}

type Azurerm_lb_rule struct {

	Azurerm_lb_rule_id *string `lyra:"ignore"`

    Backend_address_pool_id *string

    Backend_port int

    Enable_floating_ip *bool

    Frontend_ip_configuration_id *string

    Frontend_ip_configuration_name string

    Frontend_port int

    Idle_timeout_in_minutes *int

    Load_distribution *string

    Loadbalancer_id string

    Location *string

    Name string

    Probe_id *string

    Protocol string

    Resource_group_name string

}

var Azurerm_lb_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_rule_id",

		"backend_address_pool_id",

		"enable_floating_ip",

		"frontend_ip_configuration_id",

		"idle_timeout_in_minutes",

		"load_distribution",

		"location",

		"probe_id",

	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_lb_ruleHandler ...
type Azurerm_lb_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_ruleHandler) Create(desired *Azurerm_lb_rule) (*Azurerm_lb_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_ruleHandler) Update(externalID string, desired *Azurerm_lb_rule) (*Azurerm_lb_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_rule{ Azurerm_lb_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_ruleHandler) Read(externalID string) (*Azurerm_lb_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_rule{ Azurerm_lb_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_rule", externalID)
}

type Azurerm_local_network_gateway_bgp_settings_136 struct {


    Asn int

    Bgp_peering_address string

    Peer_weight *int

}

type Azurerm_local_network_gateway struct {

	Azurerm_local_network_gateway_id *string `lyra:"ignore"`

    Address_space []string

    Bgp_settings *[]Azurerm_local_network_gateway_bgp_settings_136

    Gateway_address string

    Location string

    Name string

    Resource_group_name string

    Tags *map[string]string

}

var Azurerm_local_network_gateway_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_local_network_gateway_id",

		"bgp_settings",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_local_network_gatewayHandler ...
type Azurerm_local_network_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_local_network_gatewayHandler) Create(desired *Azurerm_local_network_gateway) (*Azurerm_local_network_gateway, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_local_network_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_local_network_gateway", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_local_network_gatewayHandler) Update(externalID string, desired *Azurerm_local_network_gateway) (*Azurerm_local_network_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_local_network_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_local_network_gateway", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_local_network_gateway{ Azurerm_local_network_gateway_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_local_network_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_local_network_gatewayHandler) Read(externalID string) (*Azurerm_local_network_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_local_network_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_local_network_gateway", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_local_network_gateway{ Azurerm_local_network_gateway_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_local_network_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_local_network_gatewayHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_local_network_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_local_network_gateway", externalID)
}

type Azurerm_log_analytics_solution_plan_137 struct {


    Name *string

    Product string

    Promotion_code *string

    Publisher string

}

type Azurerm_log_analytics_solution struct {

	Azurerm_log_analytics_solution_id *string `lyra:"ignore"`

    Location string

    Plan []Azurerm_log_analytics_solution_plan_137

    Resource_group_name string

    Solution_name string

    Workspace_name string

    Workspace_resource_id string

}

var Azurerm_log_analytics_solution_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_log_analytics_solution_id",

	)
	rtb.ImmutableAttributes(

		"location",

		"resource_group_name",

		"solution_name",

		"workspace_name",

		"workspace_resource_id",

	)
}

// Azurerm_log_analytics_solutionHandler ...
type Azurerm_log_analytics_solutionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_log_analytics_solutionHandler) Create(desired *Azurerm_log_analytics_solution) (*Azurerm_log_analytics_solution, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_log_analytics_solution", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_log_analytics_solution", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_log_analytics_solutionHandler) Update(externalID string, desired *Azurerm_log_analytics_solution) (*Azurerm_log_analytics_solution, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_log_analytics_solution", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_log_analytics_solution", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_solution{ Azurerm_log_analytics_solution_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_log_analytics_solution", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_log_analytics_solutionHandler) Read(externalID string) (*Azurerm_log_analytics_solution, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_log_analytics_solution", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_log_analytics_solution", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_solution{ Azurerm_log_analytics_solution_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_log_analytics_solution", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_log_analytics_solutionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_log_analytics_solution", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_log_analytics_solution", externalID)
}

type Azurerm_log_analytics_workspace struct {

	Azurerm_log_analytics_workspace_id *string `lyra:"ignore"`

    Location string

    Name string

    Portal_url *string

    Primary_shared_key *string

    Resource_group_name string

    Retention_in_days *int

    Secondary_shared_key *string

    Sku string

    Tags *map[string]string

    Workspace_id *string

}

var Azurerm_log_analytics_workspace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_log_analytics_workspace_id",

		"portal_url",

		"primary_shared_key",

		"retention_in_days",

		"secondary_shared_key",

		"tags",

		"workspace_id",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"sku",

	)
}

// Azurerm_log_analytics_workspaceHandler ...
type Azurerm_log_analytics_workspaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_log_analytics_workspaceHandler) Create(desired *Azurerm_log_analytics_workspace) (*Azurerm_log_analytics_workspace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_log_analytics_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_log_analytics_workspace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_log_analytics_workspaceHandler) Update(externalID string, desired *Azurerm_log_analytics_workspace) (*Azurerm_log_analytics_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_log_analytics_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_log_analytics_workspace", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_workspace{ Azurerm_log_analytics_workspace_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_log_analytics_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_log_analytics_workspaceHandler) Read(externalID string) (*Azurerm_log_analytics_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_log_analytics_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_log_analytics_workspace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_workspace{ Azurerm_log_analytics_workspace_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_log_analytics_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_log_analytics_workspaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_log_analytics_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_log_analytics_workspace", externalID)
}

type Azurerm_log_analytics_workspace_linked_service struct {

	Azurerm_log_analytics_workspace_linked_service_id *string `lyra:"ignore"`

    Linked_service_name *string

    Linked_service_properties map[string]string

    Name *string

    Resource_group_name string

    Tags *map[string]string

    Workspace_name string

}

var Azurerm_log_analytics_workspace_linked_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_log_analytics_workspace_linked_service_id",

		"linked_service_name",

		"name",

		"tags",

	)
	rtb.ImmutableAttributes(

		"linked_service_name",

		"linked_service_properties",

		"resource_group_name",

		"workspace_name",

	)
}

// Azurerm_log_analytics_workspace_linked_serviceHandler ...
type Azurerm_log_analytics_workspace_linked_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_log_analytics_workspace_linked_serviceHandler) Create(desired *Azurerm_log_analytics_workspace_linked_service) (*Azurerm_log_analytics_workspace_linked_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_log_analytics_workspace_linked_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_log_analytics_workspace_linked_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_log_analytics_workspace_linked_serviceHandler) Update(externalID string, desired *Azurerm_log_analytics_workspace_linked_service) (*Azurerm_log_analytics_workspace_linked_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_log_analytics_workspace_linked_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_log_analytics_workspace_linked_service", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_workspace_linked_service{ Azurerm_log_analytics_workspace_linked_service_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_log_analytics_workspace_linked_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_log_analytics_workspace_linked_serviceHandler) Read(externalID string) (*Azurerm_log_analytics_workspace_linked_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_log_analytics_workspace_linked_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_log_analytics_workspace_linked_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_workspace_linked_service{ Azurerm_log_analytics_workspace_linked_service_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_log_analytics_workspace_linked_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_log_analytics_workspace_linked_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_log_analytics_workspace_linked_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_log_analytics_workspace_linked_service", externalID)
}

type Azurerm_logic_app_action_custom struct {

	Azurerm_logic_app_action_custom_id *string `lyra:"ignore"`

    Body string

    Logic_app_id string

    Name string

}

var Azurerm_logic_app_action_custom_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_action_custom_id",

	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",

	)
}

// Azurerm_logic_app_action_customHandler ...
type Azurerm_logic_app_action_customHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_action_customHandler) Create(desired *Azurerm_logic_app_action_custom) (*Azurerm_logic_app_action_custom, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_action_custom", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_action_custom", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_action_customHandler) Update(externalID string, desired *Azurerm_logic_app_action_custom) (*Azurerm_logic_app_action_custom, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_action_custom", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_action_custom", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_action_custom{ Azurerm_logic_app_action_custom_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_action_custom", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_action_customHandler) Read(externalID string) (*Azurerm_logic_app_action_custom, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_action_custom", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_action_custom", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_action_custom{ Azurerm_logic_app_action_custom_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_action_custom", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_action_customHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_action_custom", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_action_custom", externalID)
}

type Azurerm_logic_app_action_http struct {

	Azurerm_logic_app_action_http_id *string `lyra:"ignore"`

    Body *string

    Headers *map[string]string

    Logic_app_id string

    Method string

    Name string

    Uri string

}

var Azurerm_logic_app_action_http_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_action_http_id",

		"body",

		"headers",

	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",

	)
}

// Azurerm_logic_app_action_httpHandler ...
type Azurerm_logic_app_action_httpHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_action_httpHandler) Create(desired *Azurerm_logic_app_action_http) (*Azurerm_logic_app_action_http, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_action_http", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_action_http", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_action_httpHandler) Update(externalID string, desired *Azurerm_logic_app_action_http) (*Azurerm_logic_app_action_http, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_action_http", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_action_http", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_action_http{ Azurerm_logic_app_action_http_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_action_http", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_action_httpHandler) Read(externalID string) (*Azurerm_logic_app_action_http, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_action_http", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_action_http", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_action_http{ Azurerm_logic_app_action_http_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_action_http", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_action_httpHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_action_http", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_action_http", externalID)
}

type Azurerm_logic_app_trigger_custom struct {

	Azurerm_logic_app_trigger_custom_id *string `lyra:"ignore"`

    Body string

    Logic_app_id string

    Name string

}

var Azurerm_logic_app_trigger_custom_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_trigger_custom_id",

	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",

	)
}

// Azurerm_logic_app_trigger_customHandler ...
type Azurerm_logic_app_trigger_customHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_trigger_customHandler) Create(desired *Azurerm_logic_app_trigger_custom) (*Azurerm_logic_app_trigger_custom, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_trigger_custom", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_trigger_custom", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_trigger_customHandler) Update(externalID string, desired *Azurerm_logic_app_trigger_custom) (*Azurerm_logic_app_trigger_custom, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_trigger_custom", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_trigger_custom", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_custom{ Azurerm_logic_app_trigger_custom_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_trigger_custom", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_trigger_customHandler) Read(externalID string) (*Azurerm_logic_app_trigger_custom, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_trigger_custom", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_trigger_custom", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_custom{ Azurerm_logic_app_trigger_custom_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_trigger_custom", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_trigger_customHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_trigger_custom", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_trigger_custom", externalID)
}

type Azurerm_logic_app_trigger_http_request struct {

	Azurerm_logic_app_trigger_http_request_id *string `lyra:"ignore"`

    Logic_app_id string

    Method *string

    Name string

    Relative_path *string

    Schema string

}

var Azurerm_logic_app_trigger_http_request_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_trigger_http_request_id",

		"method",

		"relative_path",

	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",

	)
}

// Azurerm_logic_app_trigger_http_requestHandler ...
type Azurerm_logic_app_trigger_http_requestHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_trigger_http_requestHandler) Create(desired *Azurerm_logic_app_trigger_http_request) (*Azurerm_logic_app_trigger_http_request, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_trigger_http_request", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_trigger_http_request", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_trigger_http_requestHandler) Update(externalID string, desired *Azurerm_logic_app_trigger_http_request) (*Azurerm_logic_app_trigger_http_request, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_trigger_http_request", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_trigger_http_request", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_http_request{ Azurerm_logic_app_trigger_http_request_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_trigger_http_request", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_trigger_http_requestHandler) Read(externalID string) (*Azurerm_logic_app_trigger_http_request, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_trigger_http_request", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_trigger_http_request", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_http_request{ Azurerm_logic_app_trigger_http_request_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_trigger_http_request", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_trigger_http_requestHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_trigger_http_request", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_trigger_http_request", externalID)
}

type Azurerm_logic_app_trigger_recurrence struct {

	Azurerm_logic_app_trigger_recurrence_id *string `lyra:"ignore"`

    Frequency string

    Interval int

    Logic_app_id string

    Name string

}

var Azurerm_logic_app_trigger_recurrence_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_trigger_recurrence_id",

	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",

	)
}

// Azurerm_logic_app_trigger_recurrenceHandler ...
type Azurerm_logic_app_trigger_recurrenceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_trigger_recurrenceHandler) Create(desired *Azurerm_logic_app_trigger_recurrence) (*Azurerm_logic_app_trigger_recurrence, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_trigger_recurrence", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_trigger_recurrence", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_trigger_recurrenceHandler) Update(externalID string, desired *Azurerm_logic_app_trigger_recurrence) (*Azurerm_logic_app_trigger_recurrence, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_trigger_recurrence", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_trigger_recurrence", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_recurrence{ Azurerm_logic_app_trigger_recurrence_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_trigger_recurrence", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_trigger_recurrenceHandler) Read(externalID string) (*Azurerm_logic_app_trigger_recurrence, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_trigger_recurrence", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_trigger_recurrence", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_recurrence{ Azurerm_logic_app_trigger_recurrence_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_trigger_recurrence", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_trigger_recurrenceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_trigger_recurrence", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_trigger_recurrence", externalID)
}

type Azurerm_logic_app_workflow struct {

	Azurerm_logic_app_workflow_id *string `lyra:"ignore"`

    Access_endpoint *string

    Location string

    Name string

    Parameters *map[string]string

    Resource_group_name string

    Tags *map[string]string

    Workflow_schema *string

    Workflow_version *string

}

var Azurerm_logic_app_workflow_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_workflow_id",

		"access_endpoint",

		"parameters",

		"tags",

		"workflow_schema",

		"workflow_version",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"workflow_schema",

		"workflow_version",

	)
}

// Azurerm_logic_app_workflowHandler ...
type Azurerm_logic_app_workflowHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_workflowHandler) Create(desired *Azurerm_logic_app_workflow) (*Azurerm_logic_app_workflow, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_workflow", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_workflow", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_workflowHandler) Update(externalID string, desired *Azurerm_logic_app_workflow) (*Azurerm_logic_app_workflow, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_workflow", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_workflow", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_workflow{ Azurerm_logic_app_workflow_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_workflow", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_workflowHandler) Read(externalID string) (*Azurerm_logic_app_workflow, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_workflow", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_workflow", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_workflow{ Azurerm_logic_app_workflow_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_workflow", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_workflowHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_workflow", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_workflow", externalID)
}

type Azurerm_managed_disk_encryption_settings_138_disk_encryption_key_139 struct {


    Secret_url string

    Source_vault_id string

}

type Azurerm_managed_disk_encryption_settings_138_key_encryption_key_140 struct {


    Key_url string

    Source_vault_id string

}

type Azurerm_managed_disk_encryption_settings_138 struct {


    Disk_encryption_key *[]Azurerm_managed_disk_encryption_settings_138_disk_encryption_key_139

    Enabled bool

    Key_encryption_key *[]Azurerm_managed_disk_encryption_settings_138_key_encryption_key_140

}

type Azurerm_managed_disk struct {

	Azurerm_managed_disk_id *string `lyra:"ignore"`

    Create_option string

    Disk_size_gb *int

    Encryption_settings *[]Azurerm_managed_disk_encryption_settings_138

    Image_reference_id *string

    Location string

    Name string

    Os_type *string

    Resource_group_name string

    Source_resource_id *string

    Source_uri *string

    Storage_account_type string

    Tags *map[string]string

    Zones *[]string

}

var Azurerm_managed_disk_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_managed_disk_id",

		"disk_size_gb",

		"encryption_settings",

		"image_reference_id",

		"os_type",

		"source_resource_id",

		"source_uri",

		"tags",

		"zones",

	)
	rtb.ImmutableAttributes(

		"create_option",

		"image_reference_id",

		"location",

		"name",

		"resource_group_name",

		"source_resource_id",

		"source_uri",

		"zones",

	)
}

// Azurerm_managed_diskHandler ...
type Azurerm_managed_diskHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_managed_diskHandler) Create(desired *Azurerm_managed_disk) (*Azurerm_managed_disk, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_managed_disk", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_managed_disk", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_managed_diskHandler) Update(externalID string, desired *Azurerm_managed_disk) (*Azurerm_managed_disk, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_managed_disk", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_managed_disk", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_managed_disk{ Azurerm_managed_disk_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_managed_disk", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_managed_diskHandler) Read(externalID string) (*Azurerm_managed_disk, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_managed_disk", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_managed_disk", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_managed_disk{ Azurerm_managed_disk_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_managed_disk", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_managed_diskHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_managed_disk", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_managed_disk", externalID)
}

type Azurerm_management_group struct {

	Azurerm_management_group_id *string `lyra:"ignore"`

    Display_name *string

    Group_id *string

    Parent_management_group_id *string

    Subscription_ids *[]string

}

var Azurerm_management_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_management_group_id",

		"display_name",

		"group_id",

		"parent_management_group_id",

		"subscription_ids",

	)
	rtb.ImmutableAttributes(

		"group_id",

	)
}

// Azurerm_management_groupHandler ...
type Azurerm_management_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_management_groupHandler) Create(desired *Azurerm_management_group) (*Azurerm_management_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_management_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_management_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_management_groupHandler) Update(externalID string, desired *Azurerm_management_group) (*Azurerm_management_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_management_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_management_group", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_management_group{ Azurerm_management_group_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_management_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_management_groupHandler) Read(externalID string) (*Azurerm_management_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_management_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_management_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_management_group{ Azurerm_management_group_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_management_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_management_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_management_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_management_group", externalID)
}

type Azurerm_management_lock struct {

	Azurerm_management_lock_id *string `lyra:"ignore"`

    Lock_level string

    Name string

    Notes *string

    Scope string

}

var Azurerm_management_lock_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_management_lock_id",

		"notes",

	)
	rtb.ImmutableAttributes(

		"lock_level",

		"name",

		"notes",

		"scope",

	)
}

// Azurerm_management_lockHandler ...
type Azurerm_management_lockHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_management_lockHandler) Create(desired *Azurerm_management_lock) (*Azurerm_management_lock, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_management_lock", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_management_lock", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_management_lockHandler) Update(externalID string, desired *Azurerm_management_lock) (*Azurerm_management_lock, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_management_lock", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_management_lock", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_management_lock{ Azurerm_management_lock_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_management_lock", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_management_lockHandler) Read(externalID string) (*Azurerm_management_lock, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_management_lock", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_management_lock", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_management_lock{ Azurerm_management_lock_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_management_lock", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_management_lockHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_management_lock", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_management_lock", externalID)
}

type Azurerm_mariadb_database struct {

	Azurerm_mariadb_database_id *string `lyra:"ignore"`

    Charset string

    Collation string

    Name string

    Resource_group_name string

    Server_name string

}

var Azurerm_mariadb_database_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mariadb_database_id",

	)
	rtb.ImmutableAttributes(

		"charset",

		"collation",

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_mariadb_databaseHandler ...
type Azurerm_mariadb_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mariadb_databaseHandler) Create(desired *Azurerm_mariadb_database) (*Azurerm_mariadb_database, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mariadb_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mariadb_database", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mariadb_databaseHandler) Update(externalID string, desired *Azurerm_mariadb_database) (*Azurerm_mariadb_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mariadb_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mariadb_database", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mariadb_database{ Azurerm_mariadb_database_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mariadb_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mariadb_databaseHandler) Read(externalID string) (*Azurerm_mariadb_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mariadb_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mariadb_database", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mariadb_database{ Azurerm_mariadb_database_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mariadb_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mariadb_databaseHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mariadb_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mariadb_database", externalID)
}

type Azurerm_mariadb_server_sku_141 struct {


    Capacity int

    Family string

    Name string

    Tier string

}

type Azurerm_mariadb_server_storage_profile_142 struct {


    Backup_retention_days *int

    Geo_redundant_backup *string

    Storage_mb int

}

type Azurerm_mariadb_server struct {

	Azurerm_mariadb_server_id *string `lyra:"ignore"`

    Administrator_login string

    Administrator_login_password string

    Fqdn *string

    Location string

    Name string

    Resource_group_name string

    Sku []Azurerm_mariadb_server_sku_141

    Ssl_enforcement string

    Storage_profile []Azurerm_mariadb_server_storage_profile_142

    Tags *map[string]string

    Version string

}

var Azurerm_mariadb_server_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mariadb_server_id",

		"fqdn",

		"tags",

	)
	rtb.ImmutableAttributes(

		"administrator_login",

		"location",

		"name",

		"resource_group_name",

		"version",

	)
}

// Azurerm_mariadb_serverHandler ...
type Azurerm_mariadb_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mariadb_serverHandler) Create(desired *Azurerm_mariadb_server) (*Azurerm_mariadb_server, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mariadb_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mariadb_server", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mariadb_serverHandler) Update(externalID string, desired *Azurerm_mariadb_server) (*Azurerm_mariadb_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mariadb_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mariadb_server", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mariadb_server{ Azurerm_mariadb_server_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mariadb_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mariadb_serverHandler) Read(externalID string) (*Azurerm_mariadb_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mariadb_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mariadb_server", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mariadb_server{ Azurerm_mariadb_server_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mariadb_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mariadb_serverHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mariadb_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mariadb_server", externalID)
}

type Azurerm_metric_alertrule_email_action_143 struct {


    Custom_emails *[]string

    Send_to_service_owners *bool

}

type Azurerm_metric_alertrule_webhook_action_144 struct {


    Properties *map[string]string

    Service_uri string

}

type Azurerm_metric_alertrule struct {

	Azurerm_metric_alertrule_id *string `lyra:"ignore"`

    Aggregation string

    Description *string

    Email_action *[]Azurerm_metric_alertrule_email_action_143

    Enabled *bool

    Location string

    Metric_name string

    Name string

    Operator string

    Period string

    Resource_group_name string

    Resource_id string

    Tags *map[string]string

    Threshold float64

    Webhook_action *[]Azurerm_metric_alertrule_webhook_action_144

}

var Azurerm_metric_alertrule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_metric_alertrule_id",

		"description",

		"email_action",

		"enabled",

		"tags",

		"webhook_action",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_metric_alertruleHandler ...
type Azurerm_metric_alertruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_metric_alertruleHandler) Create(desired *Azurerm_metric_alertrule) (*Azurerm_metric_alertrule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_metric_alertrule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_metric_alertrule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_metric_alertruleHandler) Update(externalID string, desired *Azurerm_metric_alertrule) (*Azurerm_metric_alertrule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_metric_alertrule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_metric_alertrule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_metric_alertrule{ Azurerm_metric_alertrule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_metric_alertrule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_metric_alertruleHandler) Read(externalID string) (*Azurerm_metric_alertrule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_metric_alertrule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_metric_alertrule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_metric_alertrule{ Azurerm_metric_alertrule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_metric_alertrule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_metric_alertruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_metric_alertrule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_metric_alertrule", externalID)
}

type Azurerm_monitor_action_group_email_receiver_145 struct {


    Email_address string

    Name string

}

type Azurerm_monitor_action_group_sms_receiver_146 struct {


    Country_code string

    Name string

    Phone_number string

}

type Azurerm_monitor_action_group_webhook_receiver_147 struct {


    Name string

    Service_uri string

}

type Azurerm_monitor_action_group struct {

	Azurerm_monitor_action_group_id *string `lyra:"ignore"`

    Email_receiver *[]Azurerm_monitor_action_group_email_receiver_145

    Enabled *bool

    Name string

    Resource_group_name string

    Short_name string

    Sms_receiver *[]Azurerm_monitor_action_group_sms_receiver_146

    Tags *map[string]string

    Webhook_receiver *[]Azurerm_monitor_action_group_webhook_receiver_147

}

var Azurerm_monitor_action_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_action_group_id",

		"email_receiver",

		"enabled",

		"sms_receiver",

		"tags",

		"webhook_receiver",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_monitor_action_groupHandler ...
type Azurerm_monitor_action_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_action_groupHandler) Create(desired *Azurerm_monitor_action_group) (*Azurerm_monitor_action_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_action_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_action_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_action_groupHandler) Update(externalID string, desired *Azurerm_monitor_action_group) (*Azurerm_monitor_action_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_action_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_action_group", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_action_group{ Azurerm_monitor_action_group_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_action_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_action_groupHandler) Read(externalID string) (*Azurerm_monitor_action_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_action_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_action_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_action_group{ Azurerm_monitor_action_group_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_action_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_action_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_action_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_action_group", externalID)
}

type Azurerm_monitor_activity_log_alert_action_148 struct {


    Action_group_id string

    Webhook_properties *map[string]string

}

type Azurerm_monitor_activity_log_alert_criteria_149 struct {


    Caller *string

    Category string

    Level *string

    Operation_name *string

    Resource_group *string

    Resource_id *string

    Resource_provider *string

    Resource_type *string

    Status *string

    Sub_status *string

}

type Azurerm_monitor_activity_log_alert struct {

	Azurerm_monitor_activity_log_alert_id *string `lyra:"ignore"`

    Action *[]Azurerm_monitor_activity_log_alert_action_148

    Criteria []Azurerm_monitor_activity_log_alert_criteria_149

    Description *string

    Enabled *bool

    Name string

    Resource_group_name string

    Scopes []string

    Tags *map[string]string

}

var Azurerm_monitor_activity_log_alert_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_activity_log_alert_id",

		"action",

		"description",

		"enabled",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_monitor_activity_log_alertHandler ...
type Azurerm_monitor_activity_log_alertHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_activity_log_alertHandler) Create(desired *Azurerm_monitor_activity_log_alert) (*Azurerm_monitor_activity_log_alert, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_activity_log_alert", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_activity_log_alert", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_activity_log_alertHandler) Update(externalID string, desired *Azurerm_monitor_activity_log_alert) (*Azurerm_monitor_activity_log_alert, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_activity_log_alert", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_activity_log_alert", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_activity_log_alert{ Azurerm_monitor_activity_log_alert_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_activity_log_alert", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_activity_log_alertHandler) Read(externalID string) (*Azurerm_monitor_activity_log_alert, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_activity_log_alert", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_activity_log_alert", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_activity_log_alert{ Azurerm_monitor_activity_log_alert_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_activity_log_alert", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_activity_log_alertHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_activity_log_alert", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_activity_log_alert", externalID)
}

type Azurerm_monitor_diagnostic_setting_log_150_retention_policy_151 struct {


    Days *int

    Enabled bool

}

type Azurerm_monitor_diagnostic_setting_log_150 struct {


    Category string

    Enabled *bool

    Retention_policy []Azurerm_monitor_diagnostic_setting_log_150_retention_policy_151

}

type Azurerm_monitor_diagnostic_setting_metric_152_retention_policy_153 struct {


    Days *int

    Enabled bool

}

type Azurerm_monitor_diagnostic_setting_metric_152 struct {


    Category string

    Enabled *bool

    Retention_policy []Azurerm_monitor_diagnostic_setting_metric_152_retention_policy_153

}

type Azurerm_monitor_diagnostic_setting struct {

	Azurerm_monitor_diagnostic_setting_id *string `lyra:"ignore"`

    Eventhub_authorization_rule_id *string

    Eventhub_name *string

    Log *[]Azurerm_monitor_diagnostic_setting_log_150

    Log_analytics_workspace_id *string

    Metric *[]Azurerm_monitor_diagnostic_setting_metric_152

    Name string

    Storage_account_id *string

    Target_resource_id string

}

var Azurerm_monitor_diagnostic_setting_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_diagnostic_setting_id",

		"eventhub_authorization_rule_id",

		"eventhub_name",

		"log",

		"log_analytics_workspace_id",

		"metric",

		"storage_account_id",

	)
	rtb.ImmutableAttributes(

		"eventhub_authorization_rule_id",

		"eventhub_name",

		"log_analytics_workspace_id",

		"name",

		"storage_account_id",

		"target_resource_id",

	)
}

// Azurerm_monitor_diagnostic_settingHandler ...
type Azurerm_monitor_diagnostic_settingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_diagnostic_settingHandler) Create(desired *Azurerm_monitor_diagnostic_setting) (*Azurerm_monitor_diagnostic_setting, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_diagnostic_setting", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_diagnostic_setting", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_diagnostic_settingHandler) Update(externalID string, desired *Azurerm_monitor_diagnostic_setting) (*Azurerm_monitor_diagnostic_setting, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_diagnostic_setting", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_diagnostic_setting", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_diagnostic_setting{ Azurerm_monitor_diagnostic_setting_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_diagnostic_setting", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_diagnostic_settingHandler) Read(externalID string) (*Azurerm_monitor_diagnostic_setting, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_diagnostic_setting", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_diagnostic_setting", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_diagnostic_setting{ Azurerm_monitor_diagnostic_setting_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_diagnostic_setting", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_diagnostic_settingHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_diagnostic_setting", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_diagnostic_setting", externalID)
}

type Azurerm_monitor_log_profile_retention_policy_154 struct {


    Days *int

    Enabled bool

}

type Azurerm_monitor_log_profile struct {

	Azurerm_monitor_log_profile_id *string `lyra:"ignore"`

    Categories []string

    Locations []string

    Name string

    Retention_policy []Azurerm_monitor_log_profile_retention_policy_154

    Servicebus_rule_id *string

    Storage_account_id *string

}

var Azurerm_monitor_log_profile_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_log_profile_id",

		"servicebus_rule_id",

		"storage_account_id",

	)
	rtb.ImmutableAttributes(

		"name",

	)
}

// Azurerm_monitor_log_profileHandler ...
type Azurerm_monitor_log_profileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_log_profileHandler) Create(desired *Azurerm_monitor_log_profile) (*Azurerm_monitor_log_profile, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_log_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_log_profile", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_log_profileHandler) Update(externalID string, desired *Azurerm_monitor_log_profile) (*Azurerm_monitor_log_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_log_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_log_profile", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_log_profile{ Azurerm_monitor_log_profile_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_log_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_log_profileHandler) Read(externalID string) (*Azurerm_monitor_log_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_log_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_log_profile", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_log_profile{ Azurerm_monitor_log_profile_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_log_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_log_profileHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_log_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_log_profile", externalID)
}

type Azurerm_monitor_metric_alert_action_155 struct {


    Action_group_id string

    Webhook_properties *map[string]string

}

type Azurerm_monitor_metric_alert_criteria_156_dimension_157 struct {


    Name string

    Operator string

    Values []string

}

type Azurerm_monitor_metric_alert_criteria_156 struct {


    Aggregation string

    Dimension *[]Azurerm_monitor_metric_alert_criteria_156_dimension_157

    Metric_name string

    Metric_namespace string

    Operator string

    Threshold float64

}

type Azurerm_monitor_metric_alert struct {

	Azurerm_monitor_metric_alert_id *string `lyra:"ignore"`

    Action *[]Azurerm_monitor_metric_alert_action_155

    Auto_mitigate *bool

    Criteria []Azurerm_monitor_metric_alert_criteria_156

    Description *string

    Enabled *bool

    Frequency *string

    Name string

    Resource_group_name string

    Scopes []string

    Severity *int

    Tags *map[string]string

    Window_size *string

}

var Azurerm_monitor_metric_alert_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_metric_alert_id",

		"action",

		"auto_mitigate",

		"description",

		"enabled",

		"frequency",

		"severity",

		"tags",

		"window_size",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_monitor_metric_alertHandler ...
type Azurerm_monitor_metric_alertHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_metric_alertHandler) Create(desired *Azurerm_monitor_metric_alert) (*Azurerm_monitor_metric_alert, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_metric_alert", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_metric_alert", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_metric_alertHandler) Update(externalID string, desired *Azurerm_monitor_metric_alert) (*Azurerm_monitor_metric_alert, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_metric_alert", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_metric_alert", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_metric_alert{ Azurerm_monitor_metric_alert_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_metric_alert", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_metric_alertHandler) Read(externalID string) (*Azurerm_monitor_metric_alert, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_metric_alert", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_metric_alert", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_metric_alert{ Azurerm_monitor_metric_alert_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_metric_alert", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_metric_alertHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_metric_alert", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_metric_alert", externalID)
}

type Azurerm_mssql_elasticpool_elastic_pool_properties_158 struct {


    Creation_date *string

    License_type *string

    Max_size_bytes *int

    State *string

    Zone_redundant *bool

}

type Azurerm_mssql_elasticpool_per_database_settings_159 struct {


    Max_capacity float64

    Min_capacity float64

}

type Azurerm_mssql_elasticpool_sku_160 struct {


    Capacity int

    Family *string

    Name string

    Tier string

}

type Azurerm_mssql_elasticpool struct {

	Azurerm_mssql_elasticpool_id *string `lyra:"ignore"`

    Elastic_pool_properties *[]Azurerm_mssql_elasticpool_elastic_pool_properties_158

    Location string

    Max_size_bytes *int

    Name string

    Per_database_settings []Azurerm_mssql_elasticpool_per_database_settings_159

    Resource_group_name string

    Server_name string

    Sku []Azurerm_mssql_elasticpool_sku_160

    Tags *map[string]string

    Zone_redundant *bool

}

var Azurerm_mssql_elasticpool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mssql_elasticpool_id",

		"elastic_pool_properties",

		"max_size_bytes",

		"tags",

		"zone_redundant",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_mssql_elasticpoolHandler ...
type Azurerm_mssql_elasticpoolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mssql_elasticpoolHandler) Create(desired *Azurerm_mssql_elasticpool) (*Azurerm_mssql_elasticpool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mssql_elasticpool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mssql_elasticpool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mssql_elasticpoolHandler) Update(externalID string, desired *Azurerm_mssql_elasticpool) (*Azurerm_mssql_elasticpool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mssql_elasticpool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mssql_elasticpool", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mssql_elasticpool{ Azurerm_mssql_elasticpool_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mssql_elasticpool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mssql_elasticpoolHandler) Read(externalID string) (*Azurerm_mssql_elasticpool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mssql_elasticpool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mssql_elasticpool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mssql_elasticpool{ Azurerm_mssql_elasticpool_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mssql_elasticpool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mssql_elasticpoolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mssql_elasticpool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mssql_elasticpool", externalID)
}

type Azurerm_mysql_configuration struct {

	Azurerm_mysql_configuration_id *string `lyra:"ignore"`

    Name string

    Resource_group_name string

    Server_name string

    Value string

}

var Azurerm_mysql_configuration_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_configuration_id",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",

		"value",

	)
}

// Azurerm_mysql_configurationHandler ...
type Azurerm_mysql_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_configurationHandler) Create(desired *Azurerm_mysql_configuration) (*Azurerm_mysql_configuration, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_configuration", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_configurationHandler) Update(externalID string, desired *Azurerm_mysql_configuration) (*Azurerm_mysql_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_configuration", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_configuration{ Azurerm_mysql_configuration_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_configurationHandler) Read(externalID string) (*Azurerm_mysql_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_configuration", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_configuration{ Azurerm_mysql_configuration_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_configurationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_configuration", externalID)
}

type Azurerm_mysql_database struct {

	Azurerm_mysql_database_id *string `lyra:"ignore"`

    Charset string

    Collation string

    Name string

    Resource_group_name string

    Server_name string

}

var Azurerm_mysql_database_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_database_id",

	)
	rtb.ImmutableAttributes(

		"charset",

		"collation",

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_mysql_databaseHandler ...
type Azurerm_mysql_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_databaseHandler) Create(desired *Azurerm_mysql_database) (*Azurerm_mysql_database, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_database", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_databaseHandler) Update(externalID string, desired *Azurerm_mysql_database) (*Azurerm_mysql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_database", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_database{ Azurerm_mysql_database_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_databaseHandler) Read(externalID string) (*Azurerm_mysql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_database", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_database{ Azurerm_mysql_database_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_databaseHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_database", externalID)
}

type Azurerm_mysql_firewall_rule struct {

	Azurerm_mysql_firewall_rule_id *string `lyra:"ignore"`

    End_ip_address string

    Name string

    Resource_group_name string

    Server_name string

    Start_ip_address string

}

var Azurerm_mysql_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_firewall_rule_id",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_mysql_firewall_ruleHandler ...
type Azurerm_mysql_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_firewall_ruleHandler) Create(desired *Azurerm_mysql_firewall_rule) (*Azurerm_mysql_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_firewall_ruleHandler) Update(externalID string, desired *Azurerm_mysql_firewall_rule) (*Azurerm_mysql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_firewall_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_firewall_rule{ Azurerm_mysql_firewall_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_firewall_ruleHandler) Read(externalID string) (*Azurerm_mysql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_firewall_rule{ Azurerm_mysql_firewall_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_firewall_rule", externalID)
}

type Azurerm_mysql_server_sku_161 struct {


    Capacity int

    Family string

    Name string

    Tier string

}

type Azurerm_mysql_server_storage_profile_162 struct {


    Backup_retention_days *int

    Geo_redundant_backup *string

    Storage_mb int

}

type Azurerm_mysql_server struct {

	Azurerm_mysql_server_id *string `lyra:"ignore"`

    Administrator_login string

    Administrator_login_password string

    Fqdn *string

    Location string

    Name string

    Resource_group_name string

    Sku []Azurerm_mysql_server_sku_161

    Ssl_enforcement string

    Storage_profile []Azurerm_mysql_server_storage_profile_162

    Tags *map[string]string

    Version string

}

var Azurerm_mysql_server_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_server_id",

		"fqdn",

		"tags",

	)
	rtb.ImmutableAttributes(

		"administrator_login",

		"location",

		"name",

		"resource_group_name",

		"version",

	)
}

// Azurerm_mysql_serverHandler ...
type Azurerm_mysql_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_serverHandler) Create(desired *Azurerm_mysql_server) (*Azurerm_mysql_server, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_server", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_serverHandler) Update(externalID string, desired *Azurerm_mysql_server) (*Azurerm_mysql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_server", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_server{ Azurerm_mysql_server_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_serverHandler) Read(externalID string) (*Azurerm_mysql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_server", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_server{ Azurerm_mysql_server_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_serverHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_server", externalID)
}

type Azurerm_mysql_virtual_network_rule struct {

	Azurerm_mysql_virtual_network_rule_id *string `lyra:"ignore"`

    Name string

    Resource_group_name string

    Server_name string

    Subnet_id string

}

var Azurerm_mysql_virtual_network_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_virtual_network_rule_id",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_mysql_virtual_network_ruleHandler ...
type Azurerm_mysql_virtual_network_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_virtual_network_ruleHandler) Create(desired *Azurerm_mysql_virtual_network_rule) (*Azurerm_mysql_virtual_network_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_virtual_network_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_virtual_network_ruleHandler) Update(externalID string, desired *Azurerm_mysql_virtual_network_rule) (*Azurerm_mysql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_virtual_network_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_virtual_network_rule{ Azurerm_mysql_virtual_network_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_virtual_network_ruleHandler) Read(externalID string) (*Azurerm_mysql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_virtual_network_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_virtual_network_rule{ Azurerm_mysql_virtual_network_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_virtual_network_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_virtual_network_rule", externalID)
}

type Azurerm_network_interface_ip_configuration_163 struct {


    Application_gateway_backend_address_pools_ids *[]string

    Application_security_group_ids *[]string

    Load_balancer_backend_address_pools_ids *[]string

    Load_balancer_inbound_nat_rules_ids *[]string

    Name string

    Primary *bool

    Private_ip_address *string

    Private_ip_address_allocation string

    Private_ip_address_version *string

    Public_ip_address_id *string

    Subnet_id *string

}

type Azurerm_network_interface struct {

	Azurerm_network_interface_id *string `lyra:"ignore"`

    Applied_dns_servers *[]string

    Dns_servers *[]string

    Enable_accelerated_networking *bool

    Enable_ip_forwarding *bool

    Internal_dns_name_label *string

    Internal_fqdn *string

    Ip_configuration []Azurerm_network_interface_ip_configuration_163

    Location string

    Mac_address *string

    Name string

    Network_security_group_id *string

    Private_ip_address *string

    Private_ip_addresses *[]string

    Resource_group_name string

    Tags *map[string]string

    Virtual_machine_id *string

}

var Azurerm_network_interface_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_interface_id",

		"applied_dns_servers",

		"dns_servers",

		"enable_accelerated_networking",

		"enable_ip_forwarding",

		"internal_dns_name_label",

		"internal_fqdn",

		"mac_address",

		"network_security_group_id",

		"private_ip_address",

		"private_ip_addresses",

		"tags",

		"virtual_machine_id",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_network_interfaceHandler ...
type Azurerm_network_interfaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_interfaceHandler) Create(desired *Azurerm_network_interface) (*Azurerm_network_interface, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_interface", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_interface", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_interfaceHandler) Update(externalID string, desired *Azurerm_network_interface) (*Azurerm_network_interface, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_interface", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_interface", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface{ Azurerm_network_interface_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_interface", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_interfaceHandler) Read(externalID string) (*Azurerm_network_interface, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_interface", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_interface", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface{ Azurerm_network_interface_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_interface", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_interfaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_interface", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_interface", externalID)
}

type Azurerm_network_interface_application_gateway_backend_address_pool_association struct {

	Azurerm_network_interface_application_gateway_backend_address_pool_association_id *string `lyra:"ignore"`

    Backend_address_pool_id string

    Ip_configuration_name string

    Network_interface_id string

}

var Azurerm_network_interface_application_gateway_backend_address_pool_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_interface_application_gateway_backend_address_pool_association_id",

	)
	rtb.ImmutableAttributes(

		"backend_address_pool_id",

		"ip_configuration_name",

		"network_interface_id",

	)
}

// Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler ...
type Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler) Create(desired *Azurerm_network_interface_application_gateway_backend_address_pool_association) (*Azurerm_network_interface_application_gateway_backend_address_pool_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_interface_application_gateway_backend_address_pool_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_interface_application_gateway_backend_address_pool_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler) Update(externalID string, desired *Azurerm_network_interface_application_gateway_backend_address_pool_association) (*Azurerm_network_interface_application_gateway_backend_address_pool_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_interface_application_gateway_backend_address_pool_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_interface_application_gateway_backend_address_pool_association", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_application_gateway_backend_address_pool_association{ Azurerm_network_interface_application_gateway_backend_address_pool_association_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_interface_application_gateway_backend_address_pool_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler) Read(externalID string) (*Azurerm_network_interface_application_gateway_backend_address_pool_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_interface_application_gateway_backend_address_pool_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_interface_application_gateway_backend_address_pool_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_application_gateway_backend_address_pool_association{ Azurerm_network_interface_application_gateway_backend_address_pool_association_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_interface_application_gateway_backend_address_pool_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_interface_application_gateway_backend_address_pool_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_interface_application_gateway_backend_address_pool_association", externalID)
}

type Azurerm_network_interface_backend_address_pool_association struct {

	Azurerm_network_interface_backend_address_pool_association_id *string `lyra:"ignore"`

    Backend_address_pool_id string

    Ip_configuration_name string

    Network_interface_id string

}

var Azurerm_network_interface_backend_address_pool_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_interface_backend_address_pool_association_id",

	)
	rtb.ImmutableAttributes(

		"backend_address_pool_id",

		"ip_configuration_name",

		"network_interface_id",

	)
}

// Azurerm_network_interface_backend_address_pool_associationHandler ...
type Azurerm_network_interface_backend_address_pool_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_interface_backend_address_pool_associationHandler) Create(desired *Azurerm_network_interface_backend_address_pool_association) (*Azurerm_network_interface_backend_address_pool_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_interface_backend_address_pool_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_interface_backend_address_pool_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_interface_backend_address_pool_associationHandler) Update(externalID string, desired *Azurerm_network_interface_backend_address_pool_association) (*Azurerm_network_interface_backend_address_pool_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_interface_backend_address_pool_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_interface_backend_address_pool_association", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_backend_address_pool_association{ Azurerm_network_interface_backend_address_pool_association_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_interface_backend_address_pool_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_interface_backend_address_pool_associationHandler) Read(externalID string) (*Azurerm_network_interface_backend_address_pool_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_interface_backend_address_pool_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_interface_backend_address_pool_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_backend_address_pool_association{ Azurerm_network_interface_backend_address_pool_association_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_interface_backend_address_pool_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_interface_backend_address_pool_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_interface_backend_address_pool_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_interface_backend_address_pool_association", externalID)
}

type Azurerm_network_interface_nat_rule_association struct {

	Azurerm_network_interface_nat_rule_association_id *string `lyra:"ignore"`

    Ip_configuration_name string

    Nat_rule_id string

    Network_interface_id string

}

var Azurerm_network_interface_nat_rule_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_interface_nat_rule_association_id",

	)
	rtb.ImmutableAttributes(

		"ip_configuration_name",

		"nat_rule_id",

		"network_interface_id",

	)
}

// Azurerm_network_interface_nat_rule_associationHandler ...
type Azurerm_network_interface_nat_rule_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_interface_nat_rule_associationHandler) Create(desired *Azurerm_network_interface_nat_rule_association) (*Azurerm_network_interface_nat_rule_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_interface_nat_rule_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_interface_nat_rule_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_interface_nat_rule_associationHandler) Update(externalID string, desired *Azurerm_network_interface_nat_rule_association) (*Azurerm_network_interface_nat_rule_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_interface_nat_rule_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_interface_nat_rule_association", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_nat_rule_association{ Azurerm_network_interface_nat_rule_association_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_interface_nat_rule_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_interface_nat_rule_associationHandler) Read(externalID string) (*Azurerm_network_interface_nat_rule_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_interface_nat_rule_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_interface_nat_rule_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_nat_rule_association{ Azurerm_network_interface_nat_rule_association_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_interface_nat_rule_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_interface_nat_rule_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_interface_nat_rule_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_interface_nat_rule_association", externalID)
}

type Azurerm_network_security_group_security_rule_164 struct {


    Access string

    Description *string

    Destination_address_prefix *string

    Destination_address_prefixes *[]string

    Destination_application_security_group_ids *[]string

    Destination_port_range *string

    Destination_port_ranges *[]string

    Direction string

    Name string

    Priority int

    Protocol string

    Source_address_prefix *string

    Source_address_prefixes *[]string

    Source_application_security_group_ids *[]string

    Source_port_range *string

    Source_port_ranges *[]string

}

type Azurerm_network_security_group struct {

	Azurerm_network_security_group_id *string `lyra:"ignore"`

    Location string

    Name string

    Resource_group_name string

    Security_rule *[]Azurerm_network_security_group_security_rule_164

    Tags *map[string]string

}

var Azurerm_network_security_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_security_group_id",

		"security_rule",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_network_security_groupHandler ...
type Azurerm_network_security_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_security_groupHandler) Create(desired *Azurerm_network_security_group) (*Azurerm_network_security_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_security_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_security_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_security_groupHandler) Update(externalID string, desired *Azurerm_network_security_group) (*Azurerm_network_security_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_security_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_security_group", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_security_group{ Azurerm_network_security_group_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_security_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_security_groupHandler) Read(externalID string) (*Azurerm_network_security_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_security_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_security_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_security_group{ Azurerm_network_security_group_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_security_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_security_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_security_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_security_group", externalID)
}

type Azurerm_network_security_rule struct {

	Azurerm_network_security_rule_id *string `lyra:"ignore"`

    Access string

    Description *string

    Destination_address_prefix *string

    Destination_address_prefixes *[]string

    Destination_application_security_group_ids *[]string

    Destination_port_range *string

    Destination_port_ranges *[]string

    Direction string

    Name string

    Network_security_group_name string

    Priority int

    Protocol string

    Resource_group_name string

    Source_address_prefix *string

    Source_address_prefixes *[]string

    Source_application_security_group_ids *[]string

    Source_port_range *string

    Source_port_ranges *[]string

}

var Azurerm_network_security_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_security_rule_id",

		"description",

		"destination_address_prefix",

		"destination_address_prefixes",

		"destination_application_security_group_ids",

		"destination_port_range",

		"destination_port_ranges",

		"source_address_prefix",

		"source_address_prefixes",

		"source_application_security_group_ids",

		"source_port_range",

		"source_port_ranges",

	)
	rtb.ImmutableAttributes(

		"name",

		"network_security_group_name",

		"resource_group_name",

	)
}

// Azurerm_network_security_ruleHandler ...
type Azurerm_network_security_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_security_ruleHandler) Create(desired *Azurerm_network_security_rule) (*Azurerm_network_security_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_security_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_security_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_security_ruleHandler) Update(externalID string, desired *Azurerm_network_security_rule) (*Azurerm_network_security_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_security_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_security_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_security_rule{ Azurerm_network_security_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_security_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_security_ruleHandler) Read(externalID string) (*Azurerm_network_security_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_security_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_security_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_security_rule{ Azurerm_network_security_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_security_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_security_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_security_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_security_rule", externalID)
}

type Azurerm_network_watcher struct {

	Azurerm_network_watcher_id *string `lyra:"ignore"`

    Location string

    Name string

    Resource_group_name string

    Tags *map[string]string

}

var Azurerm_network_watcher_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_watcher_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_network_watcherHandler ...
type Azurerm_network_watcherHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_watcherHandler) Create(desired *Azurerm_network_watcher) (*Azurerm_network_watcher, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_watcher", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_watcher", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_watcherHandler) Update(externalID string, desired *Azurerm_network_watcher) (*Azurerm_network_watcher, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_watcher", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_watcher", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_watcher{ Azurerm_network_watcher_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_watcher", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_watcherHandler) Read(externalID string) (*Azurerm_network_watcher, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_watcher", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_watcher", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_watcher{ Azurerm_network_watcher_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_watcher", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_watcherHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_watcher", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_watcher", externalID)
}

type Azurerm_notification_hub_apns_credential_165 struct {


    Application_mode string

    Bundle_id string

    Key_id string

    Team_id string

    Token string

}

type Azurerm_notification_hub_gcm_credential_166 struct {


    Api_key string

}

type Azurerm_notification_hub struct {

	Azurerm_notification_hub_id *string `lyra:"ignore"`

    Apns_credential *[]Azurerm_notification_hub_apns_credential_165

    Gcm_credential *[]Azurerm_notification_hub_gcm_credential_166

    Location string

    Name string

    Namespace_name string

    Resource_group_name string

}

var Azurerm_notification_hub_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_notification_hub_id",

		"apns_credential",

		"gcm_credential",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"namespace_name",

		"resource_group_name",

	)
}

// Azurerm_notification_hubHandler ...
type Azurerm_notification_hubHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_notification_hubHandler) Create(desired *Azurerm_notification_hub) (*Azurerm_notification_hub, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_notification_hub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_notification_hub", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_notification_hubHandler) Update(externalID string, desired *Azurerm_notification_hub) (*Azurerm_notification_hub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_notification_hub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_notification_hub", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub{ Azurerm_notification_hub_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_notification_hub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_notification_hubHandler) Read(externalID string) (*Azurerm_notification_hub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_notification_hub", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_notification_hub", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub{ Azurerm_notification_hub_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_notification_hub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_notification_hubHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_notification_hub", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_notification_hub", externalID)
}

type Azurerm_notification_hub_authorization_rule struct {

	Azurerm_notification_hub_authorization_rule_id *string `lyra:"ignore"`

    Listen *bool

    Manage *bool

    Name string

    Namespace_name string

    Notification_hub_name string

    Primary_access_key *string

    Resource_group_name string

    Secondary_access_key *string

    Send *bool

}

var Azurerm_notification_hub_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_notification_hub_authorization_rule_id",

		"listen",

		"manage",

		"primary_access_key",

		"secondary_access_key",

		"send",

	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"notification_hub_name",

		"resource_group_name",

	)
}

// Azurerm_notification_hub_authorization_ruleHandler ...
type Azurerm_notification_hub_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_notification_hub_authorization_ruleHandler) Create(desired *Azurerm_notification_hub_authorization_rule) (*Azurerm_notification_hub_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_notification_hub_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_notification_hub_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_notification_hub_authorization_ruleHandler) Update(externalID string, desired *Azurerm_notification_hub_authorization_rule) (*Azurerm_notification_hub_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_notification_hub_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_notification_hub_authorization_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub_authorization_rule{ Azurerm_notification_hub_authorization_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_notification_hub_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_notification_hub_authorization_ruleHandler) Read(externalID string) (*Azurerm_notification_hub_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_notification_hub_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_notification_hub_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub_authorization_rule{ Azurerm_notification_hub_authorization_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_notification_hub_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_notification_hub_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_notification_hub_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_notification_hub_authorization_rule", externalID)
}

type Azurerm_notification_hub_namespace_sku_167 struct {


    Name string

}

type Azurerm_notification_hub_namespace struct {

	Azurerm_notification_hub_namespace_id *string `lyra:"ignore"`

    Enabled *bool

    Location string

    Name string

    Namespace_type string

    Resource_group_name string

    Servicebus_endpoint *string

    Sku []Azurerm_notification_hub_namespace_sku_167

}

var Azurerm_notification_hub_namespace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_notification_hub_namespace_id",

		"enabled",

		"servicebus_endpoint",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_notification_hub_namespaceHandler ...
type Azurerm_notification_hub_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_notification_hub_namespaceHandler) Create(desired *Azurerm_notification_hub_namespace) (*Azurerm_notification_hub_namespace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_notification_hub_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_notification_hub_namespace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_notification_hub_namespaceHandler) Update(externalID string, desired *Azurerm_notification_hub_namespace) (*Azurerm_notification_hub_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_notification_hub_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_notification_hub_namespace", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub_namespace{ Azurerm_notification_hub_namespace_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_notification_hub_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_notification_hub_namespaceHandler) Read(externalID string) (*Azurerm_notification_hub_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_notification_hub_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_notification_hub_namespace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub_namespace{ Azurerm_notification_hub_namespace_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_notification_hub_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_notification_hub_namespaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_notification_hub_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_notification_hub_namespace", externalID)
}

type Azurerm_packet_capture_filter_168 struct {


    Local_ip_address *string

    Local_port *string

    Protocol string

    Remote_ip_address *string

    Remote_port *string

}

type Azurerm_packet_capture_storage_location_169 struct {


    File_path *string

    Storage_account_id *string

    Storage_path *string

}

type Azurerm_packet_capture struct {

	Azurerm_packet_capture_id *string `lyra:"ignore"`

    Filter *[]Azurerm_packet_capture_filter_168

    Maximum_bytes_per_packet *int

    Maximum_bytes_per_session *int

    Maximum_capture_duration *int

    Name string

    Network_watcher_name string

    Resource_group_name string

    Storage_location []Azurerm_packet_capture_storage_location_169

    Target_resource_id string

}

var Azurerm_packet_capture_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_packet_capture_id",

		"filter",

		"maximum_bytes_per_packet",

		"maximum_bytes_per_session",

		"maximum_capture_duration",

	)
	rtb.ImmutableAttributes(

		"filter",

		"maximum_bytes_per_packet",

		"maximum_bytes_per_session",

		"maximum_capture_duration",

		"name",

		"network_watcher_name",

		"resource_group_name",

		"storage_location",

		"target_resource_id",

	)
}

// Azurerm_packet_captureHandler ...
type Azurerm_packet_captureHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_packet_captureHandler) Create(desired *Azurerm_packet_capture) (*Azurerm_packet_capture, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_packet_capture", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_packet_capture", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_packet_captureHandler) Update(externalID string, desired *Azurerm_packet_capture) (*Azurerm_packet_capture, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_packet_capture", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_packet_capture", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_packet_capture{ Azurerm_packet_capture_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_packet_capture", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_packet_captureHandler) Read(externalID string) (*Azurerm_packet_capture, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_packet_capture", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_packet_capture", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_packet_capture{ Azurerm_packet_capture_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_packet_capture", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_packet_captureHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_packet_capture", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_packet_capture", externalID)
}

type Azurerm_policy_assignment_identity_170 struct {


    Principal_id *string

    Tenant_id *string

    Type *string

}

type Azurerm_policy_assignment struct {

	Azurerm_policy_assignment_id *string `lyra:"ignore"`

    Description *string

    Display_name *string

    Identity *[]Azurerm_policy_assignment_identity_170

    Location *string

    Name string

    Not_scopes *[]string

    Parameters *string

    Policy_definition_id string

    Scope string

}

var Azurerm_policy_assignment_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_policy_assignment_id",

		"description",

		"display_name",

		"identity",

		"location",

		"not_scopes",

		"parameters",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"parameters",

		"policy_definition_id",

		"scope",

	)
}

// Azurerm_policy_assignmentHandler ...
type Azurerm_policy_assignmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_policy_assignmentHandler) Create(desired *Azurerm_policy_assignment) (*Azurerm_policy_assignment, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_policy_assignment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_policy_assignment", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_policy_assignmentHandler) Update(externalID string, desired *Azurerm_policy_assignment) (*Azurerm_policy_assignment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_policy_assignment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_policy_assignment", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_assignment{ Azurerm_policy_assignment_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_policy_assignment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_policy_assignmentHandler) Read(externalID string) (*Azurerm_policy_assignment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_policy_assignment", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_policy_assignment", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_assignment{ Azurerm_policy_assignment_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_policy_assignment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_policy_assignmentHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_policy_assignment", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_policy_assignment", externalID)
}

type Azurerm_policy_definition struct {

	Azurerm_policy_definition_id *string `lyra:"ignore"`

    Description *string

    Display_name string

    Management_group_id *string

    Metadata *string

    Mode string

    Name string

    Parameters *string

    Policy_rule *string

    Policy_type string

}

var Azurerm_policy_definition_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_policy_definition_id",

		"description",

		"management_group_id",

		"metadata",

		"parameters",

		"policy_rule",

	)
	rtb.ImmutableAttributes(

		"management_group_id",

		"mode",

		"name",

		"policy_type",

	)
}

// Azurerm_policy_definitionHandler ...
type Azurerm_policy_definitionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_policy_definitionHandler) Create(desired *Azurerm_policy_definition) (*Azurerm_policy_definition, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_policy_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_policy_definition", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_policy_definitionHandler) Update(externalID string, desired *Azurerm_policy_definition) (*Azurerm_policy_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_policy_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_policy_definition", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_definition{ Azurerm_policy_definition_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_policy_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_policy_definitionHandler) Read(externalID string) (*Azurerm_policy_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_policy_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_policy_definition", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_definition{ Azurerm_policy_definition_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_policy_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_policy_definitionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_policy_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_policy_definition", externalID)
}

type Azurerm_policy_set_definition struct {

	Azurerm_policy_set_definition_id *string `lyra:"ignore"`

    Description *string

    Display_name string

    Management_group_id *string

    Metadata *string

    Name string

    Parameters *string

    Policy_definitions *string

    Policy_type string

}

var Azurerm_policy_set_definition_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_policy_set_definition_id",

		"description",

		"management_group_id",

		"metadata",

		"parameters",

		"policy_definitions",

	)
	rtb.ImmutableAttributes(

		"management_group_id",

		"name",

		"policy_type",

	)
}

// Azurerm_policy_set_definitionHandler ...
type Azurerm_policy_set_definitionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_policy_set_definitionHandler) Create(desired *Azurerm_policy_set_definition) (*Azurerm_policy_set_definition, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_policy_set_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_policy_set_definition", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_policy_set_definitionHandler) Update(externalID string, desired *Azurerm_policy_set_definition) (*Azurerm_policy_set_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_policy_set_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_policy_set_definition", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_set_definition{ Azurerm_policy_set_definition_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_policy_set_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_policy_set_definitionHandler) Read(externalID string) (*Azurerm_policy_set_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_policy_set_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_policy_set_definition", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_set_definition{ Azurerm_policy_set_definition_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_policy_set_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_policy_set_definitionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_policy_set_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_policy_set_definition", externalID)
}

type Azurerm_postgresql_configuration struct {

	Azurerm_postgresql_configuration_id *string `lyra:"ignore"`

    Name string

    Resource_group_name string

    Server_name string

    Value string

}

var Azurerm_postgresql_configuration_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_configuration_id",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",

		"value",

	)
}

// Azurerm_postgresql_configurationHandler ...
type Azurerm_postgresql_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_configurationHandler) Create(desired *Azurerm_postgresql_configuration) (*Azurerm_postgresql_configuration, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_configuration", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_configurationHandler) Update(externalID string, desired *Azurerm_postgresql_configuration) (*Azurerm_postgresql_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_configuration", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_configuration{ Azurerm_postgresql_configuration_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_configurationHandler) Read(externalID string) (*Azurerm_postgresql_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_configuration", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_configuration{ Azurerm_postgresql_configuration_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_configurationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_configuration", externalID)
}

type Azurerm_postgresql_database struct {

	Azurerm_postgresql_database_id *string `lyra:"ignore"`

    Charset string

    Collation string

    Name string

    Resource_group_name string

    Server_name string

}

var Azurerm_postgresql_database_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_database_id",

	)
	rtb.ImmutableAttributes(

		"charset",

		"collation",

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_postgresql_databaseHandler ...
type Azurerm_postgresql_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_databaseHandler) Create(desired *Azurerm_postgresql_database) (*Azurerm_postgresql_database, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_database", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_databaseHandler) Update(externalID string, desired *Azurerm_postgresql_database) (*Azurerm_postgresql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_database", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_database{ Azurerm_postgresql_database_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_databaseHandler) Read(externalID string) (*Azurerm_postgresql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_database", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_database{ Azurerm_postgresql_database_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_databaseHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_database", externalID)
}

type Azurerm_postgresql_firewall_rule struct {

	Azurerm_postgresql_firewall_rule_id *string `lyra:"ignore"`

    End_ip_address string

    Name string

    Resource_group_name string

    Server_name string

    Start_ip_address string

}

var Azurerm_postgresql_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_firewall_rule_id",

	)
	rtb.ImmutableAttributes(

		"end_ip_address",

		"name",

		"resource_group_name",

		"server_name",

		"start_ip_address",

	)
}

// Azurerm_postgresql_firewall_ruleHandler ...
type Azurerm_postgresql_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_firewall_ruleHandler) Create(desired *Azurerm_postgresql_firewall_rule) (*Azurerm_postgresql_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_firewall_ruleHandler) Update(externalID string, desired *Azurerm_postgresql_firewall_rule) (*Azurerm_postgresql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_firewall_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_firewall_rule{ Azurerm_postgresql_firewall_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_firewall_ruleHandler) Read(externalID string) (*Azurerm_postgresql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_firewall_rule{ Azurerm_postgresql_firewall_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_firewall_rule", externalID)
}

type Azurerm_postgresql_server_sku_171 struct {


    Capacity int

    Family string

    Name string

    Tier string

}

type Azurerm_postgresql_server_storage_profile_172 struct {


    Backup_retention_days *int

    Geo_redundant_backup *string

    Storage_mb int

}

type Azurerm_postgresql_server struct {

	Azurerm_postgresql_server_id *string `lyra:"ignore"`

    Administrator_login string

    Administrator_login_password string

    Fqdn *string

    Location string

    Name string

    Resource_group_name string

    Sku []Azurerm_postgresql_server_sku_171

    Ssl_enforcement string

    Storage_profile []Azurerm_postgresql_server_storage_profile_172

    Tags *map[string]string

    Version string

}

var Azurerm_postgresql_server_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_server_id",

		"fqdn",

		"tags",

	)
	rtb.ImmutableAttributes(

		"administrator_login",

		"location",

		"name",

		"resource_group_name",

		"version",

	)
}

// Azurerm_postgresql_serverHandler ...
type Azurerm_postgresql_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_serverHandler) Create(desired *Azurerm_postgresql_server) (*Azurerm_postgresql_server, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_server", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_serverHandler) Update(externalID string, desired *Azurerm_postgresql_server) (*Azurerm_postgresql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_server", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_server{ Azurerm_postgresql_server_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_serverHandler) Read(externalID string) (*Azurerm_postgresql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_server", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_server{ Azurerm_postgresql_server_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_serverHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_server", externalID)
}

type Azurerm_postgresql_virtual_network_rule struct {

	Azurerm_postgresql_virtual_network_rule_id *string `lyra:"ignore"`

    Ignore_missing_vnet_service_endpoint *bool

    Name string

    Resource_group_name string

    Server_name string

    Subnet_id string

}

var Azurerm_postgresql_virtual_network_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_virtual_network_rule_id",

		"ignore_missing_vnet_service_endpoint",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_postgresql_virtual_network_ruleHandler ...
type Azurerm_postgresql_virtual_network_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_virtual_network_ruleHandler) Create(desired *Azurerm_postgresql_virtual_network_rule) (*Azurerm_postgresql_virtual_network_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_virtual_network_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_virtual_network_ruleHandler) Update(externalID string, desired *Azurerm_postgresql_virtual_network_rule) (*Azurerm_postgresql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_virtual_network_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_virtual_network_rule{ Azurerm_postgresql_virtual_network_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_virtual_network_ruleHandler) Read(externalID string) (*Azurerm_postgresql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_virtual_network_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_virtual_network_rule{ Azurerm_postgresql_virtual_network_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_virtual_network_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_virtual_network_rule", externalID)
}

type Azurerm_public_ip struct {

	Azurerm_public_ip_id *string `lyra:"ignore"`

    Allocation_method *string

    Domain_name_label *string

    Fqdn *string

    Idle_timeout_in_minutes *int

    Ip_address *string

    Ip_version *string

    Location string

    Name string

    Public_ip_address_allocation *string

    Resource_group_name string

    Reverse_fqdn *string

    Sku *string

    Tags *map[string]string

    Zones *[]string

}

var Azurerm_public_ip_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_public_ip_id",

		"allocation_method",

		"domain_name_label",

		"fqdn",

		"idle_timeout_in_minutes",

		"ip_address",

		"ip_version",

		"public_ip_address_allocation",

		"reverse_fqdn",

		"sku",

		"tags",

		"zones",

	)
	rtb.ImmutableAttributes(

		"ip_version",

		"location",

		"name",

		"resource_group_name",

		"sku",

		"zones",

	)
}

// Azurerm_public_ipHandler ...
type Azurerm_public_ipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_public_ipHandler) Create(desired *Azurerm_public_ip) (*Azurerm_public_ip, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_public_ip", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_public_ip", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_public_ipHandler) Update(externalID string, desired *Azurerm_public_ip) (*Azurerm_public_ip, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_public_ip", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_public_ip", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_public_ip{ Azurerm_public_ip_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_public_ip", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_public_ipHandler) Read(externalID string) (*Azurerm_public_ip, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_public_ip", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_public_ip", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_public_ip{ Azurerm_public_ip_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_public_ip", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_public_ipHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_public_ip", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_public_ip", externalID)
}

type Azurerm_recovery_services_protected_vm struct {

	Azurerm_recovery_services_protected_vm_id *string `lyra:"ignore"`

    Backup_policy_id string

    Recovery_vault_name string

    Resource_group_name string

    Source_vm_id string

    Tags *map[string]string

}

var Azurerm_recovery_services_protected_vm_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_recovery_services_protected_vm_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"backup_policy_id",

		"recovery_vault_name",

		"resource_group_name",

		"source_vm_id",

	)
}

// Azurerm_recovery_services_protected_vmHandler ...
type Azurerm_recovery_services_protected_vmHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_recovery_services_protected_vmHandler) Create(desired *Azurerm_recovery_services_protected_vm) (*Azurerm_recovery_services_protected_vm, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_recovery_services_protected_vm", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_recovery_services_protected_vm", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_recovery_services_protected_vmHandler) Update(externalID string, desired *Azurerm_recovery_services_protected_vm) (*Azurerm_recovery_services_protected_vm, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_recovery_services_protected_vm", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_recovery_services_protected_vm", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_protected_vm{ Azurerm_recovery_services_protected_vm_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_recovery_services_protected_vm", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_recovery_services_protected_vmHandler) Read(externalID string) (*Azurerm_recovery_services_protected_vm, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_recovery_services_protected_vm", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_recovery_services_protected_vm", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_protected_vm{ Azurerm_recovery_services_protected_vm_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_recovery_services_protected_vm", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_recovery_services_protected_vmHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_recovery_services_protected_vm", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_recovery_services_protected_vm", externalID)
}

type Azurerm_recovery_services_protection_policy_vm_backup_173 struct {


    Frequency string

    Time string

    Weekdays *[]string

}

type Azurerm_recovery_services_protection_policy_vm_retention_daily_174 struct {


    Count int

}

type Azurerm_recovery_services_protection_policy_vm_retention_monthly_175 struct {


    Count int

    Weekdays []string

    Weeks []string

}

type Azurerm_recovery_services_protection_policy_vm_retention_weekly_176 struct {


    Count int

    Weekdays []string

}

type Azurerm_recovery_services_protection_policy_vm_retention_yearly_177 struct {


    Count int

    Months []string

    Weekdays []string

    Weeks []string

}

type Azurerm_recovery_services_protection_policy_vm struct {

	Azurerm_recovery_services_protection_policy_vm_id *string `lyra:"ignore"`

    Backup []Azurerm_recovery_services_protection_policy_vm_backup_173

    Name string

    Recovery_vault_name string

    Resource_group_name string

    Retention_daily *[]Azurerm_recovery_services_protection_policy_vm_retention_daily_174

    Retention_monthly *[]Azurerm_recovery_services_protection_policy_vm_retention_monthly_175

    Retention_weekly *[]Azurerm_recovery_services_protection_policy_vm_retention_weekly_176

    Retention_yearly *[]Azurerm_recovery_services_protection_policy_vm_retention_yearly_177

    Tags *map[string]string

    Timezone *string

}

var Azurerm_recovery_services_protection_policy_vm_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_recovery_services_protection_policy_vm_id",

		"retention_daily",

		"retention_monthly",

		"retention_weekly",

		"retention_yearly",

		"tags",

		"timezone",

	)
	rtb.ImmutableAttributes(

		"name",

		"recovery_vault_name",

		"resource_group_name",

	)
}

// Azurerm_recovery_services_protection_policy_vmHandler ...
type Azurerm_recovery_services_protection_policy_vmHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_recovery_services_protection_policy_vmHandler) Create(desired *Azurerm_recovery_services_protection_policy_vm) (*Azurerm_recovery_services_protection_policy_vm, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_recovery_services_protection_policy_vm", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_recovery_services_protection_policy_vm", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_recovery_services_protection_policy_vmHandler) Update(externalID string, desired *Azurerm_recovery_services_protection_policy_vm) (*Azurerm_recovery_services_protection_policy_vm, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_recovery_services_protection_policy_vm", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_recovery_services_protection_policy_vm", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_protection_policy_vm{ Azurerm_recovery_services_protection_policy_vm_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_recovery_services_protection_policy_vm", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_recovery_services_protection_policy_vmHandler) Read(externalID string) (*Azurerm_recovery_services_protection_policy_vm, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_recovery_services_protection_policy_vm", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_recovery_services_protection_policy_vm", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_protection_policy_vm{ Azurerm_recovery_services_protection_policy_vm_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_recovery_services_protection_policy_vm", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_recovery_services_protection_policy_vmHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_recovery_services_protection_policy_vm", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_recovery_services_protection_policy_vm", externalID)
}

type Azurerm_recovery_services_vault struct {

	Azurerm_recovery_services_vault_id *string `lyra:"ignore"`

    Location string

    Name string

    Resource_group_name string

    Sku string

    Tags *map[string]string

}

var Azurerm_recovery_services_vault_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_recovery_services_vault_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_recovery_services_vaultHandler ...
type Azurerm_recovery_services_vaultHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_recovery_services_vaultHandler) Create(desired *Azurerm_recovery_services_vault) (*Azurerm_recovery_services_vault, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_recovery_services_vault", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_recovery_services_vault", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_recovery_services_vaultHandler) Update(externalID string, desired *Azurerm_recovery_services_vault) (*Azurerm_recovery_services_vault, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_recovery_services_vault", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_recovery_services_vault", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_vault{ Azurerm_recovery_services_vault_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_recovery_services_vault", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_recovery_services_vaultHandler) Read(externalID string) (*Azurerm_recovery_services_vault, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_recovery_services_vault", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_recovery_services_vault", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_vault{ Azurerm_recovery_services_vault_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_recovery_services_vault", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_recovery_services_vaultHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_recovery_services_vault", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_recovery_services_vault", externalID)
}

type Azurerm_redis_cache_patch_schedule_178 struct {


    Day_of_week string

    Start_hour_utc *int

}

type Azurerm_redis_cache_redis_configuration_179 struct {


    Maxclients *int

    Maxmemory_delta *int

    Maxmemory_policy *string

    Maxmemory_reserved *int

    Notify_keyspace_events *string

    Rdb_backup_enabled *bool

    Rdb_backup_frequency *int

    Rdb_backup_max_snapshot_count *int

    Rdb_storage_connection_string *string

}

type Azurerm_redis_cache struct {

	Azurerm_redis_cache_id *string `lyra:"ignore"`

    Capacity int

    Enable_non_ssl_port *bool

    Family string

    Hostname *string

    Location string

    Name string

    Patch_schedule *[]Azurerm_redis_cache_patch_schedule_178

    Port *int

    Primary_access_key *string

    Private_static_ip_address *string

    Redis_configuration []Azurerm_redis_cache_redis_configuration_179

    Resource_group_name string

    Secondary_access_key *string

    Shard_count *int

    Sku_name string

    Ssl_port *int

    Subnet_id *string

    Tags *map[string]string

    Zones *[]string

}

var Azurerm_redis_cache_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_redis_cache_id",

		"enable_non_ssl_port",

		"hostname",

		"patch_schedule",

		"port",

		"primary_access_key",

		"private_static_ip_address",

		"secondary_access_key",

		"shard_count",

		"ssl_port",

		"subnet_id",

		"tags",

		"zones",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"private_static_ip_address",

		"resource_group_name",

		"subnet_id",

		"zones",

	)
}

// Azurerm_redis_cacheHandler ...
type Azurerm_redis_cacheHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_redis_cacheHandler) Create(desired *Azurerm_redis_cache) (*Azurerm_redis_cache, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_redis_cache", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_redis_cache", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_redis_cacheHandler) Update(externalID string, desired *Azurerm_redis_cache) (*Azurerm_redis_cache, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_redis_cache", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_redis_cache", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_redis_cache{ Azurerm_redis_cache_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_redis_cache", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_redis_cacheHandler) Read(externalID string) (*Azurerm_redis_cache, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_redis_cache", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_redis_cache", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_redis_cache{ Azurerm_redis_cache_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_redis_cache", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_redis_cacheHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_redis_cache", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_redis_cache", externalID)
}

type Azurerm_redis_firewall_rule struct {

	Azurerm_redis_firewall_rule_id *string `lyra:"ignore"`

    End_ip string

    Name string

    Redis_cache_name string

    Resource_group_name string

    Start_ip string

}

var Azurerm_redis_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_redis_firewall_rule_id",

	)
	rtb.ImmutableAttributes(

		"name",

		"redis_cache_name",

		"resource_group_name",

	)
}

// Azurerm_redis_firewall_ruleHandler ...
type Azurerm_redis_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_redis_firewall_ruleHandler) Create(desired *Azurerm_redis_firewall_rule) (*Azurerm_redis_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_redis_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_redis_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_redis_firewall_ruleHandler) Update(externalID string, desired *Azurerm_redis_firewall_rule) (*Azurerm_redis_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_redis_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_redis_firewall_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_redis_firewall_rule{ Azurerm_redis_firewall_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_redis_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_redis_firewall_ruleHandler) Read(externalID string) (*Azurerm_redis_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_redis_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_redis_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_redis_firewall_rule{ Azurerm_redis_firewall_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_redis_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_redis_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_redis_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_redis_firewall_rule", externalID)
}

type Azurerm_relay_namespace_sku_180 struct {


    Name string

}

type Azurerm_relay_namespace struct {

	Azurerm_relay_namespace_id *string `lyra:"ignore"`

    Location string

    Metric_id *string

    Name string

    Primary_connection_string *string

    Primary_key *string

    Resource_group_name string

    Secondary_connection_string *string

    Secondary_key *string

    Sku []Azurerm_relay_namespace_sku_180

    Tags *map[string]string

}

var Azurerm_relay_namespace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_relay_namespace_id",

		"metric_id",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_relay_namespaceHandler ...
type Azurerm_relay_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_relay_namespaceHandler) Create(desired *Azurerm_relay_namespace) (*Azurerm_relay_namespace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_relay_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_relay_namespace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_relay_namespaceHandler) Update(externalID string, desired *Azurerm_relay_namespace) (*Azurerm_relay_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_relay_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_relay_namespace", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_relay_namespace{ Azurerm_relay_namespace_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_relay_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_relay_namespaceHandler) Read(externalID string) (*Azurerm_relay_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_relay_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_relay_namespace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_relay_namespace{ Azurerm_relay_namespace_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_relay_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_relay_namespaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_relay_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_relay_namespace", externalID)
}

type Azurerm_resource_group struct {

	Azurerm_resource_group_id *string `lyra:"ignore"`

    Location string

    Name string

    Tags *map[string]string

}

var Azurerm_resource_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_resource_group_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

	)
}

// Azurerm_resource_groupHandler ...
type Azurerm_resource_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_resource_groupHandler) Create(desired *Azurerm_resource_group) (*Azurerm_resource_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_resource_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_resource_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_resource_groupHandler) Update(externalID string, desired *Azurerm_resource_group) (*Azurerm_resource_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_resource_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_resource_group", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_resource_group{ Azurerm_resource_group_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_resource_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_resource_groupHandler) Read(externalID string) (*Azurerm_resource_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_resource_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_resource_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_resource_group{ Azurerm_resource_group_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_resource_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_resource_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_resource_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_resource_group", externalID)
}

type Azurerm_role_assignment struct {

	Azurerm_role_assignment_id *string `lyra:"ignore"`

    Name *string

    Principal_id string

    Role_definition_id *string

    Role_definition_name *string

    Scope string

}

var Azurerm_role_assignment_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_role_assignment_id",

		"name",

		"role_definition_id",

		"role_definition_name",

	)
	rtb.ImmutableAttributes(

		"name",

		"principal_id",

		"role_definition_id",

		"role_definition_name",

		"scope",

	)
}

// Azurerm_role_assignmentHandler ...
type Azurerm_role_assignmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_role_assignmentHandler) Create(desired *Azurerm_role_assignment) (*Azurerm_role_assignment, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_role_assignment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_role_assignment", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_role_assignmentHandler) Update(externalID string, desired *Azurerm_role_assignment) (*Azurerm_role_assignment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_role_assignment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_role_assignment", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_role_assignment{ Azurerm_role_assignment_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_role_assignment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_role_assignmentHandler) Read(externalID string) (*Azurerm_role_assignment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_role_assignment", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_role_assignment", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_role_assignment{ Azurerm_role_assignment_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_role_assignment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_role_assignmentHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_role_assignment", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_role_assignment", externalID)
}

type Azurerm_role_definition_permissions_181 struct {


    Actions *[]string

    Data_actions *[]string

    Not_actions *[]string

    Not_data_actions *[]string

}

type Azurerm_role_definition struct {

	Azurerm_role_definition_id *string `lyra:"ignore"`

    Assignable_scopes []string

    Description *string

    Name string

    Permissions []Azurerm_role_definition_permissions_181

    Role_definition_id *string

    Scope string

}

var Azurerm_role_definition_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_role_definition_id",

		"description",

		"role_definition_id",

	)
	rtb.ImmutableAttributes(

		"role_definition_id",

		"scope",

	)
}

// Azurerm_role_definitionHandler ...
type Azurerm_role_definitionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_role_definitionHandler) Create(desired *Azurerm_role_definition) (*Azurerm_role_definition, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_role_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_role_definition", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_role_definitionHandler) Update(externalID string, desired *Azurerm_role_definition) (*Azurerm_role_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_role_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_role_definition", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_role_definition{ Azurerm_role_definition_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_role_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_role_definitionHandler) Read(externalID string) (*Azurerm_role_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_role_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_role_definition", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_role_definition{ Azurerm_role_definition_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_role_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_role_definitionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_role_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_role_definition", externalID)
}

type Azurerm_route struct {

	Azurerm_route_id *string `lyra:"ignore"`

    Address_prefix string

    Name string

    Next_hop_in_ip_address *string

    Next_hop_type string

    Resource_group_name string

    Route_table_name string

}

var Azurerm_route_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_route_id",

		"next_hop_in_ip_address",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"route_table_name",

	)
}

// Azurerm_routeHandler ...
type Azurerm_routeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_routeHandler) Create(desired *Azurerm_route) (*Azurerm_route, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_route", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_route", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_routeHandler) Update(externalID string, desired *Azurerm_route) (*Azurerm_route, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_route", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_route", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_route{ Azurerm_route_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_route", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_routeHandler) Read(externalID string) (*Azurerm_route, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_route", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_route", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_route{ Azurerm_route_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_route", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_routeHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_route", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_route", externalID)
}

type Azurerm_route_table_route_182 struct {


    Address_prefix string

    Name string

    Next_hop_in_ip_address *string

    Next_hop_type string

}

type Azurerm_route_table struct {

	Azurerm_route_table_id *string `lyra:"ignore"`

    Disable_bgp_route_propagation *bool

    Location string

    Name string

    Resource_group_name string

    Route *[]Azurerm_route_table_route_182

    Subnets *[]string

    Tags *map[string]string

}

var Azurerm_route_table_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_route_table_id",

		"disable_bgp_route_propagation",

		"route",

		"subnets",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_route_tableHandler ...
type Azurerm_route_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_route_tableHandler) Create(desired *Azurerm_route_table) (*Azurerm_route_table, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_route_table", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_route_table", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_route_tableHandler) Update(externalID string, desired *Azurerm_route_table) (*Azurerm_route_table, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_route_table", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_route_table", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_route_table{ Azurerm_route_table_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_route_table", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_route_tableHandler) Read(externalID string) (*Azurerm_route_table, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_route_table", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_route_table", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_route_table{ Azurerm_route_table_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_route_table", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_route_tableHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_route_table", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_route_table", externalID)
}

type Azurerm_scheduler_job_action_storage_queue_183 struct {


    Message string

    Sas_token string

    Storage_account_name string

    Storage_queue_name string

}

type Azurerm_scheduler_job_action_web_184_authentication_active_directory_185 struct {


    Audience *string

    Client_id string

    Secret string

    Tenant_id string

}

type Azurerm_scheduler_job_action_web_184_authentication_basic_186 struct {


    Password string

    Username string

}

type Azurerm_scheduler_job_action_web_184_authentication_certificate_187 struct {


    Expiration *string

    Password string

    Pfx string

    Subject_name *string

    Thumbprint *string

}

type Azurerm_scheduler_job_action_web_184 struct {


    Authentication_active_directory *[]Azurerm_scheduler_job_action_web_184_authentication_active_directory_185

    Authentication_basic *[]Azurerm_scheduler_job_action_web_184_authentication_basic_186

    Authentication_certificate *[]Azurerm_scheduler_job_action_web_184_authentication_certificate_187

    Body *string

    Headers *map[string]string

    Method string

    Url string

}

type Azurerm_scheduler_job_error_action_storage_queue_188 struct {


    Message string

    Sas_token string

    Storage_account_name string

    Storage_queue_name string

}

type Azurerm_scheduler_job_error_action_web_189_authentication_active_directory_190 struct {


    Audience *string

    Client_id string

    Secret string

    Tenant_id string

}

type Azurerm_scheduler_job_error_action_web_189_authentication_basic_191 struct {


    Password string

    Username string

}

type Azurerm_scheduler_job_error_action_web_189_authentication_certificate_192 struct {


    Expiration *string

    Password string

    Pfx string

    Subject_name *string

    Thumbprint *string

}

type Azurerm_scheduler_job_error_action_web_189 struct {


    Authentication_active_directory *[]Azurerm_scheduler_job_error_action_web_189_authentication_active_directory_190

    Authentication_basic *[]Azurerm_scheduler_job_error_action_web_189_authentication_basic_191

    Authentication_certificate *[]Azurerm_scheduler_job_error_action_web_189_authentication_certificate_192

    Body *string

    Headers *map[string]string

    Method string

    Url string

}

type Azurerm_scheduler_job_recurrence_193_monthly_occurrences_194 struct {


    Day string

    Occurrence int

}

type Azurerm_scheduler_job_recurrence_193 struct {


    Count *int

    End_time *string

    Frequency string

    Hours *[]int

    Interval *int

    Minutes *[]int

    Month_days *[]int

    Monthly_occurrences *[]Azurerm_scheduler_job_recurrence_193_monthly_occurrences_194

    Week_days *[]string

}

type Azurerm_scheduler_job_retry_195 struct {


    Count *int

    Interval *string

}

type Azurerm_scheduler_job struct {

	Azurerm_scheduler_job_id *string `lyra:"ignore"`

    Action_storage_queue *[]Azurerm_scheduler_job_action_storage_queue_183

    Action_web *[]Azurerm_scheduler_job_action_web_184

    Error_action_storage_queue *[]Azurerm_scheduler_job_error_action_storage_queue_188

    Error_action_web *[]Azurerm_scheduler_job_error_action_web_189

    Job_collection_name string

    Name string

    Recurrence *[]Azurerm_scheduler_job_recurrence_193

    Resource_group_name string

    Retry *[]Azurerm_scheduler_job_retry_195

    Start_time *string

    State *string

}

var Azurerm_scheduler_job_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_scheduler_job_id",

		"action_storage_queue",

		"action_web",

		"error_action_storage_queue",

		"error_action_web",

		"recurrence",

		"retry",

		"start_time",

		"state",

	)
	rtb.ImmutableAttributes(

		"job_collection_name",

		"name",

		"resource_group_name",

	)
}

// Azurerm_scheduler_jobHandler ...
type Azurerm_scheduler_jobHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_scheduler_jobHandler) Create(desired *Azurerm_scheduler_job) (*Azurerm_scheduler_job, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_scheduler_job", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_scheduler_job", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_scheduler_jobHandler) Update(externalID string, desired *Azurerm_scheduler_job) (*Azurerm_scheduler_job, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_scheduler_job", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_scheduler_job", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_scheduler_job{ Azurerm_scheduler_job_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_scheduler_job", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_scheduler_jobHandler) Read(externalID string) (*Azurerm_scheduler_job, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_scheduler_job", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_scheduler_job", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_scheduler_job{ Azurerm_scheduler_job_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_scheduler_job", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_scheduler_jobHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_scheduler_job", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_scheduler_job", externalID)
}

type Azurerm_scheduler_job_collection_quota_196 struct {


    Max_job_count *int

    Max_recurrence_frequency string

    Max_recurrence_interval *int

    Max_retry_interval *int

}

type Azurerm_scheduler_job_collection struct {

	Azurerm_scheduler_job_collection_id *string `lyra:"ignore"`

    Location string

    Name string

    Quota *[]Azurerm_scheduler_job_collection_quota_196

    Resource_group_name string

    Sku string

    State *string

    Tags *map[string]string

}

var Azurerm_scheduler_job_collection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_scheduler_job_collection_id",

		"quota",

		"state",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_scheduler_job_collectionHandler ...
type Azurerm_scheduler_job_collectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_scheduler_job_collectionHandler) Create(desired *Azurerm_scheduler_job_collection) (*Azurerm_scheduler_job_collection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_scheduler_job_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_scheduler_job_collection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_scheduler_job_collectionHandler) Update(externalID string, desired *Azurerm_scheduler_job_collection) (*Azurerm_scheduler_job_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_scheduler_job_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_scheduler_job_collection", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_scheduler_job_collection{ Azurerm_scheduler_job_collection_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_scheduler_job_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_scheduler_job_collectionHandler) Read(externalID string) (*Azurerm_scheduler_job_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_scheduler_job_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_scheduler_job_collection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_scheduler_job_collection{ Azurerm_scheduler_job_collection_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_scheduler_job_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_scheduler_job_collectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_scheduler_job_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_scheduler_job_collection", externalID)
}

type Azurerm_search_service struct {

	Azurerm_search_service_id *string `lyra:"ignore"`

    Location string

    Name string

    Partition_count *int

    Primary_key *string

    Replica_count *int

    Resource_group_name string

    Secondary_key *string

    Sku string

    Tags *map[string]string

}

var Azurerm_search_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_search_service_id",

		"partition_count",

		"primary_key",

		"replica_count",

		"secondary_key",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"partition_count",

		"replica_count",

		"resource_group_name",

		"sku",

		"tags",

	)
}

// Azurerm_search_serviceHandler ...
type Azurerm_search_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_search_serviceHandler) Create(desired *Azurerm_search_service) (*Azurerm_search_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_search_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_search_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_search_serviceHandler) Update(externalID string, desired *Azurerm_search_service) (*Azurerm_search_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_search_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_search_service", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_search_service{ Azurerm_search_service_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_search_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_search_serviceHandler) Read(externalID string) (*Azurerm_search_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_search_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_search_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_search_service{ Azurerm_search_service_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_search_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_search_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_search_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_search_service", externalID)
}

type Azurerm_security_center_contact struct {

	Azurerm_security_center_contact_id *string `lyra:"ignore"`

    Alert_notifications bool

    Alerts_to_admins bool

    Email string

    Phone string

}

var Azurerm_security_center_contact_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_security_center_contact_id",

	)
	rtb.ImmutableAttributes(

	)
}

// Azurerm_security_center_contactHandler ...
type Azurerm_security_center_contactHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_security_center_contactHandler) Create(desired *Azurerm_security_center_contact) (*Azurerm_security_center_contact, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_security_center_contact", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_security_center_contact", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_security_center_contactHandler) Update(externalID string, desired *Azurerm_security_center_contact) (*Azurerm_security_center_contact, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_security_center_contact", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_security_center_contact", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_contact{ Azurerm_security_center_contact_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_security_center_contact", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_security_center_contactHandler) Read(externalID string) (*Azurerm_security_center_contact, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_security_center_contact", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_security_center_contact", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_contact{ Azurerm_security_center_contact_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_security_center_contact", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_security_center_contactHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_security_center_contact", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_security_center_contact", externalID)
}

type Azurerm_security_center_subscription_pricing struct {

	Azurerm_security_center_subscription_pricing_id *string `lyra:"ignore"`

    Tier string

}

var Azurerm_security_center_subscription_pricing_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_security_center_subscription_pricing_id",

	)
	rtb.ImmutableAttributes(

	)
}

// Azurerm_security_center_subscription_pricingHandler ...
type Azurerm_security_center_subscription_pricingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_security_center_subscription_pricingHandler) Create(desired *Azurerm_security_center_subscription_pricing) (*Azurerm_security_center_subscription_pricing, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_security_center_subscription_pricing", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_security_center_subscription_pricing", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_security_center_subscription_pricingHandler) Update(externalID string, desired *Azurerm_security_center_subscription_pricing) (*Azurerm_security_center_subscription_pricing, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_security_center_subscription_pricing", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_security_center_subscription_pricing", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_subscription_pricing{ Azurerm_security_center_subscription_pricing_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_security_center_subscription_pricing", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_security_center_subscription_pricingHandler) Read(externalID string) (*Azurerm_security_center_subscription_pricing, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_security_center_subscription_pricing", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_security_center_subscription_pricing", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_subscription_pricing{ Azurerm_security_center_subscription_pricing_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_security_center_subscription_pricing", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_security_center_subscription_pricingHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_security_center_subscription_pricing", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_security_center_subscription_pricing", externalID)
}

type Azurerm_security_center_workspace struct {

	Azurerm_security_center_workspace_id *string `lyra:"ignore"`

    Scope string

    Workspace_id string

}

var Azurerm_security_center_workspace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_security_center_workspace_id",

	)
	rtb.ImmutableAttributes(

	)
}

// Azurerm_security_center_workspaceHandler ...
type Azurerm_security_center_workspaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_security_center_workspaceHandler) Create(desired *Azurerm_security_center_workspace) (*Azurerm_security_center_workspace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_security_center_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_security_center_workspace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_security_center_workspaceHandler) Update(externalID string, desired *Azurerm_security_center_workspace) (*Azurerm_security_center_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_security_center_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_security_center_workspace", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_workspace{ Azurerm_security_center_workspace_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_security_center_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_security_center_workspaceHandler) Read(externalID string) (*Azurerm_security_center_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_security_center_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_security_center_workspace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_workspace{ Azurerm_security_center_workspace_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_security_center_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_security_center_workspaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_security_center_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_security_center_workspace", externalID)
}

type Azurerm_service_fabric_cluster_azure_active_directory_197 struct {


    Client_application_id string

    Cluster_application_id string

    Tenant_id string

}

type Azurerm_service_fabric_cluster_certificate_198 struct {


    Thumbprint string

    Thumbprint_secondary *string

    X509_store_name string

}

type Azurerm_service_fabric_cluster_client_certificate_thumbprint_199 struct {


    Is_admin bool

    Thumbprint string

}

type Azurerm_service_fabric_cluster_diagnostics_config_200 struct {


    Blob_endpoint string

    Protected_account_key_name string

    Queue_endpoint string

    Storage_account_name string

    Table_endpoint string

}

type Azurerm_service_fabric_cluster_fabric_settings_201 struct {


    Name string

    Parameters *map[string]string

}

type Azurerm_service_fabric_cluster_node_type_202_application_ports_203 struct {


    End_port int

    Start_port int

}

type Azurerm_service_fabric_cluster_node_type_202_ephemeral_ports_204 struct {


    End_port int

    Start_port int

}

type Azurerm_service_fabric_cluster_node_type_202 struct {


    Application_ports *[]Azurerm_service_fabric_cluster_node_type_202_application_ports_203

    Client_endpoint_port int

    Durability_level *string

    Ephemeral_ports *[]Azurerm_service_fabric_cluster_node_type_202_ephemeral_ports_204

    Http_endpoint_port int

    Instance_count int

    Is_primary bool

    Name string

    Reverse_proxy_endpoint_port *int

}

type Azurerm_service_fabric_cluster_reverse_proxy_certificate_205 struct {


    Thumbprint string

    Thumbprint_secondary *string

    X509_store_name string

}

type Azurerm_service_fabric_cluster struct {

	Azurerm_service_fabric_cluster_id *string `lyra:"ignore"`

    Add_on_features *[]string

    Azure_active_directory *[]Azurerm_service_fabric_cluster_azure_active_directory_197

    Certificate *[]Azurerm_service_fabric_cluster_certificate_198

    Client_certificate_thumbprint *[]Azurerm_service_fabric_cluster_client_certificate_thumbprint_199

    Cluster_code_version *string

    Cluster_endpoint *string

    Diagnostics_config *[]Azurerm_service_fabric_cluster_diagnostics_config_200

    Fabric_settings *[]Azurerm_service_fabric_cluster_fabric_settings_201

    Location string

    Management_endpoint string

    Name string

    Node_type []Azurerm_service_fabric_cluster_node_type_202

    Reliability_level string

    Resource_group_name string

    Reverse_proxy_certificate *[]Azurerm_service_fabric_cluster_reverse_proxy_certificate_205

    Tags *map[string]string

    Upgrade_mode string

    Vm_image string

}

var Azurerm_service_fabric_cluster_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_service_fabric_cluster_id",

		"add_on_features",

		"azure_active_directory",

		"certificate",

		"client_certificate_thumbprint",

		"cluster_code_version",

		"cluster_endpoint",

		"diagnostics_config",

		"fabric_settings",

		"reverse_proxy_certificate",

		"tags",

	)
	rtb.ImmutableAttributes(

		"azure_active_directory",

		"diagnostics_config",

		"location",

		"management_endpoint",

		"name",

		"resource_group_name",

		"vm_image",

	)
}

// Azurerm_service_fabric_clusterHandler ...
type Azurerm_service_fabric_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_service_fabric_clusterHandler) Create(desired *Azurerm_service_fabric_cluster) (*Azurerm_service_fabric_cluster, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_service_fabric_cluster", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_service_fabric_cluster", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_service_fabric_clusterHandler) Update(externalID string, desired *Azurerm_service_fabric_cluster) (*Azurerm_service_fabric_cluster, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_service_fabric_cluster", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_service_fabric_cluster", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_service_fabric_cluster{ Azurerm_service_fabric_cluster_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_service_fabric_cluster", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_service_fabric_clusterHandler) Read(externalID string) (*Azurerm_service_fabric_cluster, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_service_fabric_cluster", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_service_fabric_cluster", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_service_fabric_cluster{ Azurerm_service_fabric_cluster_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_service_fabric_cluster", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_service_fabric_clusterHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_service_fabric_cluster", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_service_fabric_cluster", externalID)
}

type Azurerm_servicebus_namespace struct {

	Azurerm_servicebus_namespace_id *string `lyra:"ignore"`

    Capacity *int

    Default_primary_connection_string *string

    Default_primary_key *string

    Default_secondary_connection_string *string

    Default_secondary_key *string

    Location string

    Name string

    Resource_group_name string

    Sku string

    Tags *map[string]string

}

var Azurerm_servicebus_namespace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_namespace_id",

		"capacity",

		"default_primary_connection_string",

		"default_primary_key",

		"default_secondary_connection_string",

		"default_secondary_key",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"sku",

	)
}

// Azurerm_servicebus_namespaceHandler ...
type Azurerm_servicebus_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_namespaceHandler) Create(desired *Azurerm_servicebus_namespace) (*Azurerm_servicebus_namespace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_namespace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_namespaceHandler) Update(externalID string, desired *Azurerm_servicebus_namespace) (*Azurerm_servicebus_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_namespace", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_namespace{ Azurerm_servicebus_namespace_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_namespaceHandler) Read(externalID string) (*Azurerm_servicebus_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_namespace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_namespace{ Azurerm_servicebus_namespace_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_namespaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_namespace", externalID)
}

type Azurerm_servicebus_namespace_authorization_rule struct {

	Azurerm_servicebus_namespace_authorization_rule_id *string `lyra:"ignore"`

    Listen *bool

    Manage *bool

    Name string

    Namespace_name string

    Primary_connection_string *string

    Primary_key *string

    Resource_group_name string

    Secondary_connection_string *string

    Secondary_key *string

    Send *bool

}

var Azurerm_servicebus_namespace_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_namespace_authorization_rule_id",

		"listen",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",

	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"resource_group_name",

	)
}

// Azurerm_servicebus_namespace_authorization_ruleHandler ...
type Azurerm_servicebus_namespace_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_namespace_authorization_ruleHandler) Create(desired *Azurerm_servicebus_namespace_authorization_rule) (*Azurerm_servicebus_namespace_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_namespace_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_namespace_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_namespace_authorization_ruleHandler) Update(externalID string, desired *Azurerm_servicebus_namespace_authorization_rule) (*Azurerm_servicebus_namespace_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_namespace_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_namespace_authorization_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_namespace_authorization_rule{ Azurerm_servicebus_namespace_authorization_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_namespace_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_namespace_authorization_ruleHandler) Read(externalID string) (*Azurerm_servicebus_namespace_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_namespace_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_namespace_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_namespace_authorization_rule{ Azurerm_servicebus_namespace_authorization_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_namespace_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_namespace_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_namespace_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_namespace_authorization_rule", externalID)
}

type Azurerm_servicebus_queue struct {

	Azurerm_servicebus_queue_id *string `lyra:"ignore"`

    Auto_delete_on_idle *string

    Dead_lettering_on_message_expiration *bool

    Default_message_ttl *string

    Duplicate_detection_history_time_window *string

    Enable_batched_operations *bool

    Enable_express *bool

    Enable_partitioning *bool

    Location *string

    Lock_duration *string

    Max_delivery_count *int

    Max_size_in_megabytes *int

    Name string

    Namespace_name string

    Requires_duplicate_detection *bool

    Requires_session *bool

    Resource_group_name string

    Support_ordering *bool

}

var Azurerm_servicebus_queue_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_queue_id",

		"auto_delete_on_idle",

		"dead_lettering_on_message_expiration",

		"default_message_ttl",

		"duplicate_detection_history_time_window",

		"enable_batched_operations",

		"enable_express",

		"enable_partitioning",

		"location",

		"lock_duration",

		"max_delivery_count",

		"max_size_in_megabytes",

		"requires_duplicate_detection",

		"requires_session",

		"support_ordering",

	)
	rtb.ImmutableAttributes(

		"enable_partitioning",

		"location",

		"name",

		"namespace_name",

		"requires_duplicate_detection",

		"requires_session",

		"resource_group_name",

	)
}

// Azurerm_servicebus_queueHandler ...
type Azurerm_servicebus_queueHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_queueHandler) Create(desired *Azurerm_servicebus_queue) (*Azurerm_servicebus_queue, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_queue", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_queue", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_queueHandler) Update(externalID string, desired *Azurerm_servicebus_queue) (*Azurerm_servicebus_queue, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_queue", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_queue", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_queue{ Azurerm_servicebus_queue_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_queue", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_queueHandler) Read(externalID string) (*Azurerm_servicebus_queue, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_queue", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_queue", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_queue{ Azurerm_servicebus_queue_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_queue", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_queueHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_queue", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_queue", externalID)
}

type Azurerm_servicebus_queue_authorization_rule struct {

	Azurerm_servicebus_queue_authorization_rule_id *string `lyra:"ignore"`

    Listen *bool

    Manage *bool

    Name string

    Namespace_name string

    Primary_connection_string *string

    Primary_key *string

    Queue_name string

    Resource_group_name string

    Secondary_connection_string *string

    Secondary_key *string

    Send *bool

}

var Azurerm_servicebus_queue_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_queue_authorization_rule_id",

		"listen",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",

	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"queue_name",

		"resource_group_name",

	)
}

// Azurerm_servicebus_queue_authorization_ruleHandler ...
type Azurerm_servicebus_queue_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_queue_authorization_ruleHandler) Create(desired *Azurerm_servicebus_queue_authorization_rule) (*Azurerm_servicebus_queue_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_queue_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_queue_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_queue_authorization_ruleHandler) Update(externalID string, desired *Azurerm_servicebus_queue_authorization_rule) (*Azurerm_servicebus_queue_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_queue_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_queue_authorization_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_queue_authorization_rule{ Azurerm_servicebus_queue_authorization_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_queue_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_queue_authorization_ruleHandler) Read(externalID string) (*Azurerm_servicebus_queue_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_queue_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_queue_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_queue_authorization_rule{ Azurerm_servicebus_queue_authorization_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_queue_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_queue_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_queue_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_queue_authorization_rule", externalID)
}

type Azurerm_servicebus_subscription struct {

	Azurerm_servicebus_subscription_id *string `lyra:"ignore"`

    Auto_delete_on_idle *string

    Dead_lettering_on_filter_evaluation_exceptions *bool

    Dead_lettering_on_message_expiration *bool

    Default_message_ttl *string

    Enable_batched_operations *bool

    Forward_to *string

    Location *string

    Lock_duration *string

    Max_delivery_count int

    Name string

    Namespace_name string

    Requires_session *bool

    Resource_group_name string

    Topic_name string

}

var Azurerm_servicebus_subscription_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_subscription_id",

		"auto_delete_on_idle",

		"dead_lettering_on_filter_evaluation_exceptions",

		"dead_lettering_on_message_expiration",

		"default_message_ttl",

		"enable_batched_operations",

		"forward_to",

		"location",

		"lock_duration",

		"requires_session",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"namespace_name",

		"requires_session",

		"resource_group_name",

		"topic_name",

	)
}

// Azurerm_servicebus_subscriptionHandler ...
type Azurerm_servicebus_subscriptionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_subscriptionHandler) Create(desired *Azurerm_servicebus_subscription) (*Azurerm_servicebus_subscription, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_subscription", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_subscription", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_subscriptionHandler) Update(externalID string, desired *Azurerm_servicebus_subscription) (*Azurerm_servicebus_subscription, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_subscription", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_subscription", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_subscription{ Azurerm_servicebus_subscription_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_subscription", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_subscriptionHandler) Read(externalID string) (*Azurerm_servicebus_subscription, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_subscription", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_subscription", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_subscription{ Azurerm_servicebus_subscription_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_subscription", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_subscriptionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_subscription", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_subscription", externalID)
}

type Azurerm_servicebus_subscription_rule_correlation_filter_206 struct {


    Content_type *string

    Correlation_id *string

    Label *string

    Message_id *string

    Reply_to *string

    Reply_to_session_id *string

    Session_id *string

    To *string

}

type Azurerm_servicebus_subscription_rule struct {

	Azurerm_servicebus_subscription_rule_id *string `lyra:"ignore"`

    Action *string

    Correlation_filter *[]Azurerm_servicebus_subscription_rule_correlation_filter_206

    Filter_type string

    Name string

    Namespace_name string

    Resource_group_name string

    Sql_filter *string

    Subscription_name string

    Topic_name string

}

var Azurerm_servicebus_subscription_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_subscription_rule_id",

		"action",

		"correlation_filter",

		"sql_filter",

	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"resource_group_name",

		"subscription_name",

		"topic_name",

	)
}

// Azurerm_servicebus_subscription_ruleHandler ...
type Azurerm_servicebus_subscription_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_subscription_ruleHandler) Create(desired *Azurerm_servicebus_subscription_rule) (*Azurerm_servicebus_subscription_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_subscription_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_subscription_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_subscription_ruleHandler) Update(externalID string, desired *Azurerm_servicebus_subscription_rule) (*Azurerm_servicebus_subscription_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_subscription_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_subscription_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_subscription_rule{ Azurerm_servicebus_subscription_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_subscription_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_subscription_ruleHandler) Read(externalID string) (*Azurerm_servicebus_subscription_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_subscription_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_subscription_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_subscription_rule{ Azurerm_servicebus_subscription_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_subscription_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_subscription_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_subscription_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_subscription_rule", externalID)
}

type Azurerm_servicebus_topic struct {

	Azurerm_servicebus_topic_id *string `lyra:"ignore"`

    Auto_delete_on_idle *string

    Default_message_ttl *string

    Duplicate_detection_history_time_window *string

    Enable_batched_operations *bool

    Enable_express *bool

    Enable_filtering_messages_before_publishing *bool

    Enable_partitioning *bool

    Location *string

    Max_size_in_megabytes *int

    Name string

    Namespace_name string

    Requires_duplicate_detection *bool

    Resource_group_name string

    Status *string

    Support_ordering *bool

}

var Azurerm_servicebus_topic_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_topic_id",

		"auto_delete_on_idle",

		"default_message_ttl",

		"duplicate_detection_history_time_window",

		"enable_batched_operations",

		"enable_express",

		"enable_filtering_messages_before_publishing",

		"enable_partitioning",

		"location",

		"max_size_in_megabytes",

		"requires_duplicate_detection",

		"status",

		"support_ordering",

	)
	rtb.ImmutableAttributes(

		"enable_partitioning",

		"location",

		"name",

		"namespace_name",

		"requires_duplicate_detection",

		"resource_group_name",

	)
}

// Azurerm_servicebus_topicHandler ...
type Azurerm_servicebus_topicHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_topicHandler) Create(desired *Azurerm_servicebus_topic) (*Azurerm_servicebus_topic, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_topic", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_topic", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_topicHandler) Update(externalID string, desired *Azurerm_servicebus_topic) (*Azurerm_servicebus_topic, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_topic", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_topic", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_topic{ Azurerm_servicebus_topic_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_topic", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_topicHandler) Read(externalID string) (*Azurerm_servicebus_topic, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_topic", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_topic", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_topic{ Azurerm_servicebus_topic_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_topic", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_topicHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_topic", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_topic", externalID)
}

type Azurerm_servicebus_topic_authorization_rule struct {

	Azurerm_servicebus_topic_authorization_rule_id *string `lyra:"ignore"`

    Listen *bool

    Manage *bool

    Name string

    Namespace_name string

    Primary_connection_string *string

    Primary_key *string

    Resource_group_name string

    Secondary_connection_string *string

    Secondary_key *string

    Send *bool

    Topic_name string

}

var Azurerm_servicebus_topic_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_topic_authorization_rule_id",

		"listen",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",

	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"resource_group_name",

		"topic_name",

	)
}

// Azurerm_servicebus_topic_authorization_ruleHandler ...
type Azurerm_servicebus_topic_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_topic_authorization_ruleHandler) Create(desired *Azurerm_servicebus_topic_authorization_rule) (*Azurerm_servicebus_topic_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_topic_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_topic_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_topic_authorization_ruleHandler) Update(externalID string, desired *Azurerm_servicebus_topic_authorization_rule) (*Azurerm_servicebus_topic_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_topic_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_topic_authorization_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_topic_authorization_rule{ Azurerm_servicebus_topic_authorization_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_topic_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_topic_authorization_ruleHandler) Read(externalID string) (*Azurerm_servicebus_topic_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_topic_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_topic_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_topic_authorization_rule{ Azurerm_servicebus_topic_authorization_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_topic_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_topic_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_topic_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_topic_authorization_rule", externalID)
}

type Azurerm_shared_image_identifier_207 struct {


    Offer string

    Publisher string

    Sku string

}

type Azurerm_shared_image struct {

	Azurerm_shared_image_id *string `lyra:"ignore"`

    Description *string

    Eula *string

    Gallery_name string

    Identifier []Azurerm_shared_image_identifier_207

    Location string

    Name string

    Os_type string

    Privacy_statement_uri *string

    Release_note_uri *string

    Resource_group_name string

    Tags *map[string]string

}

var Azurerm_shared_image_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_shared_image_id",

		"description",

		"eula",

		"privacy_statement_uri",

		"release_note_uri",

		"tags",

	)
	rtb.ImmutableAttributes(

		"gallery_name",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_shared_imageHandler ...
type Azurerm_shared_imageHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_shared_imageHandler) Create(desired *Azurerm_shared_image) (*Azurerm_shared_image, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_shared_image", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_shared_image", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_shared_imageHandler) Update(externalID string, desired *Azurerm_shared_image) (*Azurerm_shared_image, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_shared_image", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_shared_image", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image{ Azurerm_shared_image_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_shared_image", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_shared_imageHandler) Read(externalID string) (*Azurerm_shared_image, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_shared_image", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_shared_image", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image{ Azurerm_shared_image_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_shared_image", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_shared_imageHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_shared_image", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_shared_image", externalID)
}

type Azurerm_shared_image_gallery struct {

	Azurerm_shared_image_gallery_id *string `lyra:"ignore"`

    Description *string

    Location string

    Name string

    Resource_group_name string

    Tags *map[string]string

    Unique_name *string

}

var Azurerm_shared_image_gallery_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_shared_image_gallery_id",

		"description",

		"tags",

		"unique_name",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_shared_image_galleryHandler ...
type Azurerm_shared_image_galleryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_shared_image_galleryHandler) Create(desired *Azurerm_shared_image_gallery) (*Azurerm_shared_image_gallery, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_shared_image_gallery", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_shared_image_gallery", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_shared_image_galleryHandler) Update(externalID string, desired *Azurerm_shared_image_gallery) (*Azurerm_shared_image_gallery, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_shared_image_gallery", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_shared_image_gallery", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image_gallery{ Azurerm_shared_image_gallery_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_shared_image_gallery", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_shared_image_galleryHandler) Read(externalID string) (*Azurerm_shared_image_gallery, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_shared_image_gallery", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_shared_image_gallery", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image_gallery{ Azurerm_shared_image_gallery_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_shared_image_gallery", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_shared_image_galleryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_shared_image_gallery", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_shared_image_gallery", externalID)
}

type Azurerm_shared_image_version_target_region_208 struct {


    Name string

    Regional_replica_count int

}

type Azurerm_shared_image_version struct {

	Azurerm_shared_image_version_id *string `lyra:"ignore"`

    Exclude_from_latest *bool

    Gallery_name string

    Image_name string

    Location string

    Managed_image_id string

    Name string

    Resource_group_name string

    Tags *map[string]string

    Target_region []Azurerm_shared_image_version_target_region_208

}

var Azurerm_shared_image_version_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_shared_image_version_id",

		"exclude_from_latest",

		"tags",

	)
	rtb.ImmutableAttributes(

		"gallery_name",

		"image_name",

		"location",

		"managed_image_id",

		"name",

		"resource_group_name",

	)
}

// Azurerm_shared_image_versionHandler ...
type Azurerm_shared_image_versionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_shared_image_versionHandler) Create(desired *Azurerm_shared_image_version) (*Azurerm_shared_image_version, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_shared_image_version", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_shared_image_version", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_shared_image_versionHandler) Update(externalID string, desired *Azurerm_shared_image_version) (*Azurerm_shared_image_version, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_shared_image_version", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_shared_image_version", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image_version{ Azurerm_shared_image_version_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_shared_image_version", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_shared_image_versionHandler) Read(externalID string) (*Azurerm_shared_image_version, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_shared_image_version", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_shared_image_version", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image_version{ Azurerm_shared_image_version_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_shared_image_version", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_shared_image_versionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_shared_image_version", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_shared_image_version", externalID)
}

type Azurerm_signalr_service_sku_209 struct {


    Capacity int

    Name string

}

type Azurerm_signalr_service struct {

	Azurerm_signalr_service_id *string `lyra:"ignore"`

    Hostname *string

    Ip_address *string

    Location string

    Name string

    Public_port *int

    Resource_group_name string

    Server_port *int

    Sku []Azurerm_signalr_service_sku_209

    Tags *map[string]string

}

var Azurerm_signalr_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_signalr_service_id",

		"hostname",

		"ip_address",

		"public_port",

		"server_port",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_signalr_serviceHandler ...
type Azurerm_signalr_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_signalr_serviceHandler) Create(desired *Azurerm_signalr_service) (*Azurerm_signalr_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_signalr_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_signalr_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_signalr_serviceHandler) Update(externalID string, desired *Azurerm_signalr_service) (*Azurerm_signalr_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_signalr_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_signalr_service", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_signalr_service{ Azurerm_signalr_service_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_signalr_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_signalr_serviceHandler) Read(externalID string) (*Azurerm_signalr_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_signalr_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_signalr_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_signalr_service{ Azurerm_signalr_service_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_signalr_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_signalr_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_signalr_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_signalr_service", externalID)
}

type Azurerm_snapshot_encryption_settings_210_disk_encryption_key_211 struct {


    Secret_url string

    Source_vault_id string

}

type Azurerm_snapshot_encryption_settings_210_key_encryption_key_212 struct {


    Key_url string

    Source_vault_id string

}

type Azurerm_snapshot_encryption_settings_210 struct {


    Disk_encryption_key *[]Azurerm_snapshot_encryption_settings_210_disk_encryption_key_211

    Enabled bool

    Key_encryption_key *[]Azurerm_snapshot_encryption_settings_210_key_encryption_key_212

}

type Azurerm_snapshot struct {

	Azurerm_snapshot_id *string `lyra:"ignore"`

    Create_option string

    Disk_size_gb *int

    Encryption_settings *[]Azurerm_snapshot_encryption_settings_210

    Location string

    Name string

    Resource_group_name string

    Source_resource_id *string

    Source_uri *string

    Storage_account_id *string

    Tags *map[string]string

}

var Azurerm_snapshot_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_snapshot_id",

		"disk_size_gb",

		"encryption_settings",

		"source_resource_id",

		"source_uri",

		"storage_account_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"source_resource_id",

		"source_uri",

		"storage_account_id",

	)
}

// Azurerm_snapshotHandler ...
type Azurerm_snapshotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_snapshotHandler) Create(desired *Azurerm_snapshot) (*Azurerm_snapshot, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_snapshot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_snapshot", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_snapshotHandler) Update(externalID string, desired *Azurerm_snapshot) (*Azurerm_snapshot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_snapshot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_snapshot", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_snapshot{ Azurerm_snapshot_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_snapshot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_snapshotHandler) Read(externalID string) (*Azurerm_snapshot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_snapshot", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_snapshot", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_snapshot{ Azurerm_snapshot_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_snapshot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_snapshotHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_snapshot", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_snapshot", externalID)
}

type Azurerm_sql_active_directory_administrator struct {

	Azurerm_sql_active_directory_administrator_id *string `lyra:"ignore"`

    Login string

    Object_id string

    Resource_group_name string

    Server_name string

    Tenant_id string

}

var Azurerm_sql_active_directory_administrator_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_active_directory_administrator_id",

	)
	rtb.ImmutableAttributes(

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_sql_active_directory_administratorHandler ...
type Azurerm_sql_active_directory_administratorHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_active_directory_administratorHandler) Create(desired *Azurerm_sql_active_directory_administrator) (*Azurerm_sql_active_directory_administrator, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_active_directory_administrator", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_active_directory_administrator", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_active_directory_administratorHandler) Update(externalID string, desired *Azurerm_sql_active_directory_administrator) (*Azurerm_sql_active_directory_administrator, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_active_directory_administrator", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_active_directory_administrator", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_active_directory_administrator{ Azurerm_sql_active_directory_administrator_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_active_directory_administrator", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_active_directory_administratorHandler) Read(externalID string) (*Azurerm_sql_active_directory_administrator, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_active_directory_administrator", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_active_directory_administrator", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_active_directory_administrator{ Azurerm_sql_active_directory_administrator_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_active_directory_administrator", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_active_directory_administratorHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_active_directory_administrator", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_active_directory_administrator", externalID)
}

type Azurerm_sql_database_import_213 struct {


    Administrator_login string

    Administrator_login_password string

    Authentication_type string

    Operation_mode *string

    Storage_key string

    Storage_key_type string

    Storage_uri string

}

type Azurerm_sql_database_threat_detection_policy_214 struct {


    Disabled_alerts *[]string

    Email_account_admins *string

    Email_addresses *[]string

    Retention_days *int

    State *string

    Storage_account_access_key *string

    Storage_endpoint *string

    Use_server_default *string

}

type Azurerm_sql_database struct {

	Azurerm_sql_database_id *string `lyra:"ignore"`

    Collation *string

    Create_mode *string

    Creation_date *string

    Default_secondary_location *string

    Edition *string

    Elastic_pool_name *string

    Encryption *string

    Import *[]Azurerm_sql_database_import_213

    Location string

    Max_size_bytes *string

    Name string

    Requested_service_objective_id *string

    Requested_service_objective_name *string

    Resource_group_name string

    Restore_point_in_time *string

    Server_name string

    Source_database_deletion_date *string

    Source_database_id *string

    Tags *map[string]string

    Threat_detection_policy *[]Azurerm_sql_database_threat_detection_policy_214

}

var Azurerm_sql_database_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_database_id",

		"collation",

		"create_mode",

		"creation_date",

		"default_secondary_location",

		"edition",

		"elastic_pool_name",

		"encryption",

		"import",

		"max_size_bytes",

		"requested_service_objective_id",

		"requested_service_objective_name",

		"restore_point_in_time",

		"source_database_deletion_date",

		"source_database_id",

		"tags",

		"threat_detection_policy",

	)
	rtb.ImmutableAttributes(

		"collation",

		"location",

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_sql_databaseHandler ...
type Azurerm_sql_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_databaseHandler) Create(desired *Azurerm_sql_database) (*Azurerm_sql_database, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_database", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_databaseHandler) Update(externalID string, desired *Azurerm_sql_database) (*Azurerm_sql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_database", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_database{ Azurerm_sql_database_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_databaseHandler) Read(externalID string) (*Azurerm_sql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_database", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_database{ Azurerm_sql_database_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_databaseHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_database", externalID)
}

type Azurerm_sql_elasticpool struct {

	Azurerm_sql_elasticpool_id *string `lyra:"ignore"`

    Creation_date *string

    Db_dtu_max *int

    Db_dtu_min *int

    Dtu int

    Edition string

    Location string

    Name string

    Pool_size *int

    Resource_group_name string

    Server_name string

    Tags *map[string]string

}

var Azurerm_sql_elasticpool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_elasticpool_id",

		"creation_date",

		"db_dtu_max",

		"db_dtu_min",

		"pool_size",

		"tags",

	)
	rtb.ImmutableAttributes(

		"edition",

		"location",

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_sql_elasticpoolHandler ...
type Azurerm_sql_elasticpoolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_elasticpoolHandler) Create(desired *Azurerm_sql_elasticpool) (*Azurerm_sql_elasticpool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_elasticpool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_elasticpool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_elasticpoolHandler) Update(externalID string, desired *Azurerm_sql_elasticpool) (*Azurerm_sql_elasticpool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_elasticpool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_elasticpool", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_elasticpool{ Azurerm_sql_elasticpool_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_elasticpool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_elasticpoolHandler) Read(externalID string) (*Azurerm_sql_elasticpool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_elasticpool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_elasticpool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_elasticpool{ Azurerm_sql_elasticpool_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_elasticpool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_elasticpoolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_elasticpool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_elasticpool", externalID)
}

type Azurerm_sql_firewall_rule struct {

	Azurerm_sql_firewall_rule_id *string `lyra:"ignore"`

    End_ip_address string

    Name string

    Resource_group_name string

    Server_name string

    Start_ip_address string

}

var Azurerm_sql_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_firewall_rule_id",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_sql_firewall_ruleHandler ...
type Azurerm_sql_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_firewall_ruleHandler) Create(desired *Azurerm_sql_firewall_rule) (*Azurerm_sql_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_firewall_ruleHandler) Update(externalID string, desired *Azurerm_sql_firewall_rule) (*Azurerm_sql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_firewall_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_firewall_rule{ Azurerm_sql_firewall_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_firewall_ruleHandler) Read(externalID string) (*Azurerm_sql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_firewall_rule{ Azurerm_sql_firewall_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_firewall_rule", externalID)
}

type Azurerm_sql_server struct {

	Azurerm_sql_server_id *string `lyra:"ignore"`

    Administrator_login string

    Administrator_login_password string

    Fully_qualified_domain_name *string

    Location string

    Name string

    Resource_group_name string

    Tags *map[string]string

    Version string

}

var Azurerm_sql_server_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_server_id",

		"fully_qualified_domain_name",

		"tags",

	)
	rtb.ImmutableAttributes(

		"administrator_login",

		"location",

		"name",

		"resource_group_name",

		"version",

	)
}

// Azurerm_sql_serverHandler ...
type Azurerm_sql_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_serverHandler) Create(desired *Azurerm_sql_server) (*Azurerm_sql_server, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_server", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_serverHandler) Update(externalID string, desired *Azurerm_sql_server) (*Azurerm_sql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_server", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_server{ Azurerm_sql_server_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_serverHandler) Read(externalID string) (*Azurerm_sql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_server", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_server{ Azurerm_sql_server_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_serverHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_server", externalID)
}

type Azurerm_sql_virtual_network_rule struct {

	Azurerm_sql_virtual_network_rule_id *string `lyra:"ignore"`

    Ignore_missing_vnet_service_endpoint *bool

    Name string

    Resource_group_name string

    Server_name string

    Subnet_id string

}

var Azurerm_sql_virtual_network_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_virtual_network_rule_id",

		"ignore_missing_vnet_service_endpoint",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",

	)
}

// Azurerm_sql_virtual_network_ruleHandler ...
type Azurerm_sql_virtual_network_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_virtual_network_ruleHandler) Create(desired *Azurerm_sql_virtual_network_rule) (*Azurerm_sql_virtual_network_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_virtual_network_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_virtual_network_ruleHandler) Update(externalID string, desired *Azurerm_sql_virtual_network_rule) (*Azurerm_sql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_virtual_network_rule", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_virtual_network_rule{ Azurerm_sql_virtual_network_rule_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_virtual_network_ruleHandler) Read(externalID string) (*Azurerm_sql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_virtual_network_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_virtual_network_rule{ Azurerm_sql_virtual_network_rule_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_virtual_network_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_virtual_network_rule", externalID)
}

type Azurerm_storage_account_custom_domain_215 struct {


    Name string

    Use_subdomain *bool

}

type Azurerm_storage_account_identity_216 struct {


    Principal_id *string

    Tenant_id *string

    Type string

}

type Azurerm_storage_account_network_rules_217 struct {


    Bypass *[]string

    Ip_rules *[]string

    Virtual_network_subnet_ids *[]string

}

type Azurerm_storage_account struct {

	Azurerm_storage_account_id *string `lyra:"ignore"`

    Access_tier *string

    Account_encryption_source *string

    Account_kind *string

    Account_replication_type string

    Account_tier string

    Account_type *string

    Custom_domain *[]Azurerm_storage_account_custom_domain_215

    Enable_blob_encryption *bool

    Enable_file_encryption *bool

    Enable_https_traffic_only *bool

    Identity *[]Azurerm_storage_account_identity_216

    Location string

    Name string

    Network_rules *[]Azurerm_storage_account_network_rules_217

    Primary_access_key *string

    Primary_blob_connection_string *string

    Primary_blob_endpoint *string

    Primary_connection_string *string

    Primary_file_endpoint *string

    Primary_location *string

    Primary_queue_endpoint *string

    Primary_table_endpoint *string

    Resource_group_name string

    Secondary_access_key *string

    Secondary_blob_connection_string *string

    Secondary_blob_endpoint *string

    Secondary_connection_string *string

    Secondary_location *string

    Secondary_queue_endpoint *string

    Secondary_table_endpoint *string

    Tags *map[string]string

}

var Azurerm_storage_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_account_id",

		"access_tier",

		"account_encryption_source",

		"account_kind",

		"account_type",

		"custom_domain",

		"enable_blob_encryption",

		"enable_file_encryption",

		"enable_https_traffic_only",

		"identity",

		"network_rules",

		"primary_access_key",

		"primary_blob_connection_string",

		"primary_blob_endpoint",

		"primary_connection_string",

		"primary_file_endpoint",

		"primary_location",

		"primary_queue_endpoint",

		"primary_table_endpoint",

		"secondary_access_key",

		"secondary_blob_connection_string",

		"secondary_blob_endpoint",

		"secondary_connection_string",

		"secondary_location",

		"secondary_queue_endpoint",

		"secondary_table_endpoint",

		"tags",

	)
	rtb.ImmutableAttributes(

		"account_kind",

		"account_tier",

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_storage_accountHandler ...
type Azurerm_storage_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_accountHandler) Create(desired *Azurerm_storage_account) (*Azurerm_storage_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_accountHandler) Update(externalID string, desired *Azurerm_storage_account) (*Azurerm_storage_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_account", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_account{ Azurerm_storage_account_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_accountHandler) Read(externalID string) (*Azurerm_storage_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_account{ Azurerm_storage_account_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_account", externalID)
}

type Azurerm_storage_blob struct {

	Azurerm_storage_blob_id *string `lyra:"ignore"`

    Attempts *int

    Content_type *string

    Name string

    Parallelism *int

    Resource_group_name string

    Size *int

    Source *string

    Source_uri *string

    Storage_account_name string

    Storage_container_name string

    Type *string

    Url *string

}

var Azurerm_storage_blob_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_blob_id",

		"attempts",

		"content_type",

		"parallelism",

		"size",

		"source",

		"source_uri",

		"type",

		"url",

	)
	rtb.ImmutableAttributes(

		"attempts",

		"name",

		"parallelism",

		"resource_group_name",

		"size",

		"source",

		"source_uri",

		"storage_account_name",

		"storage_container_name",

		"type",

	)
}

// Azurerm_storage_blobHandler ...
type Azurerm_storage_blobHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_blobHandler) Create(desired *Azurerm_storage_blob) (*Azurerm_storage_blob, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_blob", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_blob", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_blobHandler) Update(externalID string, desired *Azurerm_storage_blob) (*Azurerm_storage_blob, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_blob", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_blob", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_blob{ Azurerm_storage_blob_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_blob", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_blobHandler) Read(externalID string) (*Azurerm_storage_blob, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_blob", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_blob", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_blob{ Azurerm_storage_blob_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_blob", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_blobHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_blob", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_blob", externalID)
}

type Azurerm_storage_container struct {

	Azurerm_storage_container_id *string `lyra:"ignore"`

    Container_access_type *string

    Name string

    Properties *map[string]string

    Resource_group_name string

    Storage_account_name string

}

var Azurerm_storage_container_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_container_id",

		"container_access_type",

		"properties",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"storage_account_name",

	)
}

// Azurerm_storage_containerHandler ...
type Azurerm_storage_containerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_containerHandler) Create(desired *Azurerm_storage_container) (*Azurerm_storage_container, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_container", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_container", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_containerHandler) Update(externalID string, desired *Azurerm_storage_container) (*Azurerm_storage_container, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_container", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_container", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_container{ Azurerm_storage_container_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_container", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_containerHandler) Read(externalID string) (*Azurerm_storage_container, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_container", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_container", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_container{ Azurerm_storage_container_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_container", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_containerHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_container", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_container", externalID)
}

type Azurerm_storage_queue struct {

	Azurerm_storage_queue_id *string `lyra:"ignore"`

    Name string

    Resource_group_name string

    Storage_account_name string

}

var Azurerm_storage_queue_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_queue_id",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"storage_account_name",

	)
}

// Azurerm_storage_queueHandler ...
type Azurerm_storage_queueHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_queueHandler) Create(desired *Azurerm_storage_queue) (*Azurerm_storage_queue, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_queue", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_queue", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_queueHandler) Update(externalID string, desired *Azurerm_storage_queue) (*Azurerm_storage_queue, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_queue", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_queue", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_queue{ Azurerm_storage_queue_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_queue", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_queueHandler) Read(externalID string) (*Azurerm_storage_queue, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_queue", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_queue", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_queue{ Azurerm_storage_queue_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_queue", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_queueHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_queue", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_queue", externalID)
}

type Azurerm_storage_share struct {

	Azurerm_storage_share_id *string `lyra:"ignore"`

    Name string

    Quota *int

    Resource_group_name string

    Storage_account_name string

    Url *string

}

var Azurerm_storage_share_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_share_id",

		"quota",

		"url",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"storage_account_name",

	)
}

// Azurerm_storage_shareHandler ...
type Azurerm_storage_shareHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_shareHandler) Create(desired *Azurerm_storage_share) (*Azurerm_storage_share, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_share", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_share", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_shareHandler) Update(externalID string, desired *Azurerm_storage_share) (*Azurerm_storage_share, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_share", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_share", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_share{ Azurerm_storage_share_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_share", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_shareHandler) Read(externalID string) (*Azurerm_storage_share, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_share", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_share", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_share{ Azurerm_storage_share_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_share", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_shareHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_share", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_share", externalID)
}

type Azurerm_storage_table struct {

	Azurerm_storage_table_id *string `lyra:"ignore"`

    Name string

    Resource_group_name string

    Storage_account_name string

}

var Azurerm_storage_table_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_table_id",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"storage_account_name",

	)
}

// Azurerm_storage_tableHandler ...
type Azurerm_storage_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_tableHandler) Create(desired *Azurerm_storage_table) (*Azurerm_storage_table, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_table", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_table", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_tableHandler) Update(externalID string, desired *Azurerm_storage_table) (*Azurerm_storage_table, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_table", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_table", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_table{ Azurerm_storage_table_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_table", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_tableHandler) Read(externalID string) (*Azurerm_storage_table, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_table", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_table", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_table{ Azurerm_storage_table_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_table", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_tableHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_table", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_table", externalID)
}

type Azurerm_subnet_delegation_218_service_delegation_219 struct {


    Actions *[]string

    Name string

}

type Azurerm_subnet_delegation_218 struct {


    Name string

    Service_delegation []Azurerm_subnet_delegation_218_service_delegation_219

}

type Azurerm_subnet struct {

	Azurerm_subnet_id *string `lyra:"ignore"`

    Address_prefix string

    Delegation *[]Azurerm_subnet_delegation_218

    Ip_configurations *[]string

    Name string

    Network_security_group_id *string

    Resource_group_name string

    Route_table_id *string

    Service_endpoints *[]string

    Virtual_network_name string

}

var Azurerm_subnet_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_subnet_id",

		"delegation",

		"ip_configurations",

		"network_security_group_id",

		"route_table_id",

		"service_endpoints",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"virtual_network_name",

	)
}

// Azurerm_subnetHandler ...
type Azurerm_subnetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_subnetHandler) Create(desired *Azurerm_subnet) (*Azurerm_subnet, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_subnet", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_subnet", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_subnetHandler) Update(externalID string, desired *Azurerm_subnet) (*Azurerm_subnet, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_subnet", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_subnet", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet{ Azurerm_subnet_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_subnet", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_subnetHandler) Read(externalID string) (*Azurerm_subnet, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_subnet", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_subnet", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet{ Azurerm_subnet_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_subnet", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_subnetHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_subnet", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_subnet", externalID)
}

type Azurerm_subnet_network_security_group_association struct {

	Azurerm_subnet_network_security_group_association_id *string `lyra:"ignore"`

    Network_security_group_id string

    Subnet_id string

}

var Azurerm_subnet_network_security_group_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_subnet_network_security_group_association_id",

	)
	rtb.ImmutableAttributes(

		"network_security_group_id",

		"subnet_id",

	)
}

// Azurerm_subnet_network_security_group_associationHandler ...
type Azurerm_subnet_network_security_group_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_subnet_network_security_group_associationHandler) Create(desired *Azurerm_subnet_network_security_group_association) (*Azurerm_subnet_network_security_group_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_subnet_network_security_group_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_subnet_network_security_group_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_subnet_network_security_group_associationHandler) Update(externalID string, desired *Azurerm_subnet_network_security_group_association) (*Azurerm_subnet_network_security_group_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_subnet_network_security_group_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_subnet_network_security_group_association", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet_network_security_group_association{ Azurerm_subnet_network_security_group_association_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_subnet_network_security_group_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_subnet_network_security_group_associationHandler) Read(externalID string) (*Azurerm_subnet_network_security_group_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_subnet_network_security_group_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_subnet_network_security_group_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet_network_security_group_association{ Azurerm_subnet_network_security_group_association_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_subnet_network_security_group_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_subnet_network_security_group_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_subnet_network_security_group_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_subnet_network_security_group_association", externalID)
}

type Azurerm_subnet_route_table_association struct {

	Azurerm_subnet_route_table_association_id *string `lyra:"ignore"`

    Route_table_id string

    Subnet_id string

}

var Azurerm_subnet_route_table_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_subnet_route_table_association_id",

	)
	rtb.ImmutableAttributes(

		"route_table_id",

		"subnet_id",

	)
}

// Azurerm_subnet_route_table_associationHandler ...
type Azurerm_subnet_route_table_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_subnet_route_table_associationHandler) Create(desired *Azurerm_subnet_route_table_association) (*Azurerm_subnet_route_table_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_subnet_route_table_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_subnet_route_table_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_subnet_route_table_associationHandler) Update(externalID string, desired *Azurerm_subnet_route_table_association) (*Azurerm_subnet_route_table_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_subnet_route_table_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_subnet_route_table_association", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet_route_table_association{ Azurerm_subnet_route_table_association_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_subnet_route_table_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_subnet_route_table_associationHandler) Read(externalID string) (*Azurerm_subnet_route_table_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_subnet_route_table_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_subnet_route_table_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet_route_table_association{ Azurerm_subnet_route_table_association_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_subnet_route_table_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_subnet_route_table_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_subnet_route_table_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_subnet_route_table_association", externalID)
}

type Azurerm_template_deployment struct {

	Azurerm_template_deployment_id *string `lyra:"ignore"`

    Deployment_mode string

    Name string

    Outputs *map[string]string

    Parameters *map[string]string

    Parameters_body *string

    Resource_group_name string

    Template_body *string

}

var Azurerm_template_deployment_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_template_deployment_id",

		"outputs",

		"parameters",

		"parameters_body",

		"template_body",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_template_deploymentHandler ...
type Azurerm_template_deploymentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_template_deploymentHandler) Create(desired *Azurerm_template_deployment) (*Azurerm_template_deployment, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_template_deployment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_template_deployment", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_template_deploymentHandler) Update(externalID string, desired *Azurerm_template_deployment) (*Azurerm_template_deployment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_template_deployment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_template_deployment", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_template_deployment{ Azurerm_template_deployment_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_template_deployment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_template_deploymentHandler) Read(externalID string) (*Azurerm_template_deployment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_template_deployment", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_template_deployment", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_template_deployment{ Azurerm_template_deployment_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_template_deployment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_template_deploymentHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_template_deployment", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_template_deployment", externalID)
}

type Azurerm_traffic_manager_endpoint struct {

	Azurerm_traffic_manager_endpoint_id *string `lyra:"ignore"`

    Endpoint_location *string

    Endpoint_monitor_status *string

    Endpoint_status *string

    Geo_mappings *[]string

    Min_child_endpoints *int

    Name string

    Priority *int

    Profile_name string

    Resource_group_name string

    Target *string

    Target_resource_id *string

    Type string

    Weight *int

}

var Azurerm_traffic_manager_endpoint_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_traffic_manager_endpoint_id",

		"endpoint_location",

		"endpoint_monitor_status",

		"endpoint_status",

		"geo_mappings",

		"min_child_endpoints",

		"priority",

		"target",

		"target_resource_id",

		"weight",

	)
	rtb.ImmutableAttributes(

		"name",

		"profile_name",

		"resource_group_name",

		"type",

	)
}

// Azurerm_traffic_manager_endpointHandler ...
type Azurerm_traffic_manager_endpointHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_traffic_manager_endpointHandler) Create(desired *Azurerm_traffic_manager_endpoint) (*Azurerm_traffic_manager_endpoint, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_traffic_manager_endpoint", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_traffic_manager_endpoint", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_traffic_manager_endpointHandler) Update(externalID string, desired *Azurerm_traffic_manager_endpoint) (*Azurerm_traffic_manager_endpoint, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_traffic_manager_endpoint", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_traffic_manager_endpoint", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_traffic_manager_endpoint{ Azurerm_traffic_manager_endpoint_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_traffic_manager_endpoint", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_traffic_manager_endpointHandler) Read(externalID string) (*Azurerm_traffic_manager_endpoint, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_traffic_manager_endpoint", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_traffic_manager_endpoint", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_traffic_manager_endpoint{ Azurerm_traffic_manager_endpoint_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_traffic_manager_endpoint", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_traffic_manager_endpointHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_traffic_manager_endpoint", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_traffic_manager_endpoint", externalID)
}

type Azurerm_traffic_manager_profile_dns_config_220 struct {


    Relative_name string

    Ttl int

}

type Azurerm_traffic_manager_profile_monitor_config_221 struct {


    Path *string

    Port int

    Protocol string

}

type Azurerm_traffic_manager_profile struct {

	Azurerm_traffic_manager_profile_id *string `lyra:"ignore"`

    Dns_config []Azurerm_traffic_manager_profile_dns_config_220

    Fqdn *string

    Monitor_config []Azurerm_traffic_manager_profile_monitor_config_221

    Name string

    Profile_status *string

    Resource_group_name string

    Tags *map[string]string

    Traffic_routing_method string

}

var Azurerm_traffic_manager_profile_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_traffic_manager_profile_id",

		"fqdn",

		"profile_status",

		"tags",

	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

	)
}

// Azurerm_traffic_manager_profileHandler ...
type Azurerm_traffic_manager_profileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_traffic_manager_profileHandler) Create(desired *Azurerm_traffic_manager_profile) (*Azurerm_traffic_manager_profile, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_traffic_manager_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_traffic_manager_profile", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_traffic_manager_profileHandler) Update(externalID string, desired *Azurerm_traffic_manager_profile) (*Azurerm_traffic_manager_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_traffic_manager_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_traffic_manager_profile", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_traffic_manager_profile{ Azurerm_traffic_manager_profile_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_traffic_manager_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_traffic_manager_profileHandler) Read(externalID string) (*Azurerm_traffic_manager_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_traffic_manager_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_traffic_manager_profile", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_traffic_manager_profile{ Azurerm_traffic_manager_profile_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_traffic_manager_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_traffic_manager_profileHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_traffic_manager_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_traffic_manager_profile", externalID)
}

type Azurerm_user_assigned_identity struct {

	Azurerm_user_assigned_identity_id *string `lyra:"ignore"`

    Client_id *string

    Location string

    Name string

    Principal_id *string

    Resource_group_name string

    Tags *map[string]string

}

var Azurerm_user_assigned_identity_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_user_assigned_identity_id",

		"client_id",

		"principal_id",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_user_assigned_identityHandler ...
type Azurerm_user_assigned_identityHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_user_assigned_identityHandler) Create(desired *Azurerm_user_assigned_identity) (*Azurerm_user_assigned_identity, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_user_assigned_identity", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_user_assigned_identity", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_user_assigned_identityHandler) Update(externalID string, desired *Azurerm_user_assigned_identity) (*Azurerm_user_assigned_identity, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_user_assigned_identity", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_user_assigned_identity", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_user_assigned_identity{ Azurerm_user_assigned_identity_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_user_assigned_identity", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_user_assigned_identityHandler) Read(externalID string) (*Azurerm_user_assigned_identity, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_user_assigned_identity", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_user_assigned_identity", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_user_assigned_identity{ Azurerm_user_assigned_identity_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_user_assigned_identity", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_user_assigned_identityHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_user_assigned_identity", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_user_assigned_identity", externalID)
}

type Azurerm_virtual_machine_boot_diagnostics_222 struct {


    Enabled bool

    Storage_uri string

}

type Azurerm_virtual_machine_identity_223 struct {


    Identity_ids *[]string

    Principal_id *string

    Type string

}

type Azurerm_virtual_machine_os_profile_224 struct {


    Admin_password *string

    Admin_username string

    Computer_name string

    Custom_data *string

}

type Azurerm_virtual_machine_os_profile_linux_config_225_ssh_keys_226 struct {


    Key_data string

    Path string

}

type Azurerm_virtual_machine_os_profile_linux_config_225 struct {


    Disable_password_authentication bool

    Ssh_keys *[]Azurerm_virtual_machine_os_profile_linux_config_225_ssh_keys_226

}

type Azurerm_virtual_machine_os_profile_secrets_227_vault_certificates_228 struct {


    Certificate_store *string

    Certificate_url string

}

type Azurerm_virtual_machine_os_profile_secrets_227 struct {


    Source_vault_id string

    Vault_certificates *[]Azurerm_virtual_machine_os_profile_secrets_227_vault_certificates_228

}

type Azurerm_virtual_machine_os_profile_windows_config_229_additional_unattend_config_230 struct {


    Component string

    Content string

    Pass string

    Setting_name string

}

type Azurerm_virtual_machine_os_profile_windows_config_229_winrm_231 struct {


    Certificate_url *string

    Protocol string

}

type Azurerm_virtual_machine_os_profile_windows_config_229 struct {


    Additional_unattend_config *[]Azurerm_virtual_machine_os_profile_windows_config_229_additional_unattend_config_230

    Enable_automatic_upgrades *bool

    Provision_vm_agent *bool

    Timezone *string

    Winrm *[]Azurerm_virtual_machine_os_profile_windows_config_229_winrm_231

}

type Azurerm_virtual_machine_plan_232 struct {


    Name string

    Product string

    Publisher string

}

type Azurerm_virtual_machine_storage_data_disk_233 struct {


    Caching *string

    Create_option string

    Disk_size_gb *int

    Lun int

    Managed_disk_id *string

    Managed_disk_type *string

    Name string

    Vhd_uri *string

    Write_accelerator_enabled *bool

}

type Azurerm_virtual_machine_storage_image_reference_234 struct {


    Id *string

    Offer *string

    Publisher *string

    Sku *string

    Version *string

}

type Azurerm_virtual_machine_storage_os_disk_235 struct {


    Caching *string

    Create_option string

    Disk_size_gb *int

    Image_uri *string

    Managed_disk_id *string

    Managed_disk_type *string

    Name string

    Os_type *string

    Vhd_uri *string

    Write_accelerator_enabled *bool

}

type Azurerm_virtual_machine struct {

	Azurerm_virtual_machine_id *string `lyra:"ignore"`

    Availability_set_id *string

    Boot_diagnostics *[]Azurerm_virtual_machine_boot_diagnostics_222

    Delete_data_disks_on_termination *bool

    Delete_os_disk_on_termination *bool

    Identity *[]Azurerm_virtual_machine_identity_223

    License_type *string

    Location string

    Name string

    Network_interface_ids []string

    Os_profile *[]Azurerm_virtual_machine_os_profile_224

    Os_profile_linux_config *[]Azurerm_virtual_machine_os_profile_linux_config_225

    Os_profile_secrets *[]Azurerm_virtual_machine_os_profile_secrets_227

    Os_profile_windows_config *[]Azurerm_virtual_machine_os_profile_windows_config_229

    Plan *[]Azurerm_virtual_machine_plan_232

    Primary_network_interface_id *string

    Resource_group_name string

    Storage_data_disk *[]Azurerm_virtual_machine_storage_data_disk_233

    Storage_image_reference *[]Azurerm_virtual_machine_storage_image_reference_234

    Storage_os_disk []Azurerm_virtual_machine_storage_os_disk_235

    Tags *map[string]string

    Vm_size string

    Zones *[]string

}

var Azurerm_virtual_machine_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_machine_id",

		"availability_set_id",

		"boot_diagnostics",

		"delete_data_disks_on_termination",

		"delete_os_disk_on_termination",

		"identity",

		"license_type",

		"os_profile",

		"os_profile_linux_config",

		"os_profile_secrets",

		"os_profile_windows_config",

		"plan",

		"primary_network_interface_id",

		"storage_data_disk",

		"storage_image_reference",

		"tags",

		"zones",

	)
	rtb.ImmutableAttributes(

		"availability_set_id",

		"location",

		"name",

		"resource_group_name",

		"storage_image_reference",

		"zones",

	)
}

// Azurerm_virtual_machineHandler ...
type Azurerm_virtual_machineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_machineHandler) Create(desired *Azurerm_virtual_machine) (*Azurerm_virtual_machine, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_machine", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_machineHandler) Update(externalID string, desired *Azurerm_virtual_machine) (*Azurerm_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_machine", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine{ Azurerm_virtual_machine_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_machineHandler) Read(externalID string) (*Azurerm_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_machine", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine{ Azurerm_virtual_machine_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_machineHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_machine", externalID)
}

type Azurerm_virtual_machine_data_disk_attachment struct {

	Azurerm_virtual_machine_data_disk_attachment_id *string `lyra:"ignore"`

    Caching string

    Create_option *string

    Lun int

    Managed_disk_id string

    Virtual_machine_id string

    Write_accelerator_enabled *bool

}

var Azurerm_virtual_machine_data_disk_attachment_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_machine_data_disk_attachment_id",

		"create_option",

		"write_accelerator_enabled",

	)
	rtb.ImmutableAttributes(

		"create_option",

		"lun",

		"managed_disk_id",

		"virtual_machine_id",

	)
}

// Azurerm_virtual_machine_data_disk_attachmentHandler ...
type Azurerm_virtual_machine_data_disk_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_machine_data_disk_attachmentHandler) Create(desired *Azurerm_virtual_machine_data_disk_attachment) (*Azurerm_virtual_machine_data_disk_attachment, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_machine_data_disk_attachment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_machine_data_disk_attachment", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_machine_data_disk_attachmentHandler) Update(externalID string, desired *Azurerm_virtual_machine_data_disk_attachment) (*Azurerm_virtual_machine_data_disk_attachment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_machine_data_disk_attachment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_machine_data_disk_attachment", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_data_disk_attachment{ Azurerm_virtual_machine_data_disk_attachment_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_machine_data_disk_attachment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_machine_data_disk_attachmentHandler) Read(externalID string) (*Azurerm_virtual_machine_data_disk_attachment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_machine_data_disk_attachment", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_machine_data_disk_attachment", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_data_disk_attachment{ Azurerm_virtual_machine_data_disk_attachment_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_machine_data_disk_attachment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_machine_data_disk_attachmentHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_machine_data_disk_attachment", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_machine_data_disk_attachment", externalID)
}

type Azurerm_virtual_machine_extension struct {

	Azurerm_virtual_machine_extension_id *string `lyra:"ignore"`

    Auto_upgrade_minor_version *bool

    Location string

    Name string

    Protected_settings *string

    Publisher string

    Resource_group_name string

    Settings *string

    Tags *map[string]string

    Type string

    Type_handler_version string

    Virtual_machine_name string

}

var Azurerm_virtual_machine_extension_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_machine_extension_id",

		"auto_upgrade_minor_version",

		"protected_settings",

		"settings",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"virtual_machine_name",

	)
}

// Azurerm_virtual_machine_extensionHandler ...
type Azurerm_virtual_machine_extensionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_machine_extensionHandler) Create(desired *Azurerm_virtual_machine_extension) (*Azurerm_virtual_machine_extension, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_machine_extension", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_machine_extension", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_machine_extensionHandler) Update(externalID string, desired *Azurerm_virtual_machine_extension) (*Azurerm_virtual_machine_extension, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_machine_extension", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_machine_extension", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_extension{ Azurerm_virtual_machine_extension_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_machine_extension", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_machine_extensionHandler) Read(externalID string) (*Azurerm_virtual_machine_extension, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_machine_extension", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_machine_extension", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_extension{ Azurerm_virtual_machine_extension_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_machine_extension", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_machine_extensionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_machine_extension", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_machine_extension", externalID)
}

type Azurerm_virtual_machine_scale_set_boot_diagnostics_236 struct {


    Enabled *bool

    Storage_uri string

}

type Azurerm_virtual_machine_scale_set_extension_237 struct {


    Auto_upgrade_minor_version *bool

    Name string

    Protected_settings *string

    Publisher string

    Settings *string

    Type string

    Type_handler_version string

}

type Azurerm_virtual_machine_scale_set_identity_238 struct {


    Identity_ids *[]string

    Principal_id *string

    Type string

}

type Azurerm_virtual_machine_scale_set_network_profile_239_dns_settings_240 struct {


    Dns_servers []string

}

type Azurerm_virtual_machine_scale_set_network_profile_239_ip_configuration_241_public_ip_address_configuration_242 struct {


    Domain_name_label string

    Idle_timeout int

    Name string

}

type Azurerm_virtual_machine_scale_set_network_profile_239_ip_configuration_241 struct {


    Application_gateway_backend_address_pool_ids *[]string

    Application_security_group_ids *[]string

    Load_balancer_backend_address_pool_ids *[]string

    Load_balancer_inbound_nat_rules_ids *[]string

    Name string

    Primary bool

    Public_ip_address_configuration *[]Azurerm_virtual_machine_scale_set_network_profile_239_ip_configuration_241_public_ip_address_configuration_242

    Subnet_id string

}

type Azurerm_virtual_machine_scale_set_network_profile_239 struct {


    Accelerated_networking *bool

    Dns_settings *[]Azurerm_virtual_machine_scale_set_network_profile_239_dns_settings_240

    Ip_configuration []Azurerm_virtual_machine_scale_set_network_profile_239_ip_configuration_241

    Ip_forwarding *bool

    Name string

    Network_security_group_id *string

    Primary bool

}

type Azurerm_virtual_machine_scale_set_os_profile_243 struct {


    Admin_password *string

    Admin_username string

    Computer_name_prefix string

    Custom_data *string

}

type Azurerm_virtual_machine_scale_set_os_profile_linux_config_244_ssh_keys_245 struct {


    Key_data *string

    Path string

}

type Azurerm_virtual_machine_scale_set_os_profile_linux_config_244 struct {


    Disable_password_authentication *bool

    Ssh_keys *[]Azurerm_virtual_machine_scale_set_os_profile_linux_config_244_ssh_keys_245

}

type Azurerm_virtual_machine_scale_set_os_profile_secrets_246_vault_certificates_247 struct {


    Certificate_store *string

    Certificate_url string

}

type Azurerm_virtual_machine_scale_set_os_profile_secrets_246 struct {


    Source_vault_id string

    Vault_certificates *[]Azurerm_virtual_machine_scale_set_os_profile_secrets_246_vault_certificates_247

}

type Azurerm_virtual_machine_scale_set_os_profile_windows_config_248_additional_unattend_config_249 struct {


    Component string

    Content string

    Pass string

    Setting_name string

}

type Azurerm_virtual_machine_scale_set_os_profile_windows_config_248_winrm_250 struct {


    Certificate_url *string

    Protocol string

}

type Azurerm_virtual_machine_scale_set_os_profile_windows_config_248 struct {


    Additional_unattend_config *[]Azurerm_virtual_machine_scale_set_os_profile_windows_config_248_additional_unattend_config_249

    Enable_automatic_upgrades *bool

    Provision_vm_agent *bool

    Winrm *[]Azurerm_virtual_machine_scale_set_os_profile_windows_config_248_winrm_250

}

type Azurerm_virtual_machine_scale_set_plan_251 struct {


    Name string

    Product string

    Publisher string

}

type Azurerm_virtual_machine_scale_set_rolling_upgrade_policy_252 struct {


    Max_batch_instance_percent *int

    Max_unhealthy_instance_percent *int

    Max_unhealthy_upgraded_instance_percent *int

    Pause_time_between_batches *string

}

type Azurerm_virtual_machine_scale_set_sku_253 struct {


    Capacity int

    Name string

    Tier *string

}

type Azurerm_virtual_machine_scale_set_storage_profile_data_disk_254 struct {


    Caching *string

    Create_option string

    Disk_size_gb *int

    Lun int

    Managed_disk_type *string

}

type Azurerm_virtual_machine_scale_set_storage_profile_image_reference_255 struct {


    Id *string

    Offer *string

    Publisher *string

    Sku *string

    Version *string

}

type Azurerm_virtual_machine_scale_set_storage_profile_os_disk_256 struct {


    Caching *string

    Create_option string

    Image *string

    Managed_disk_type *string

    Name *string

    Os_type *string

    Vhd_containers *[]string

}

type Azurerm_virtual_machine_scale_set struct {

	Azurerm_virtual_machine_scale_set_id *string `lyra:"ignore"`

    Automatic_os_upgrade *bool

    Boot_diagnostics *[]Azurerm_virtual_machine_scale_set_boot_diagnostics_236

    Eviction_policy *string

    Extension *[]Azurerm_virtual_machine_scale_set_extension_237

    Health_probe_id *string

    Identity *[]Azurerm_virtual_machine_scale_set_identity_238

    License_type *string

    Location string

    Name string

    Network_profile []Azurerm_virtual_machine_scale_set_network_profile_239

    Os_profile []Azurerm_virtual_machine_scale_set_os_profile_243

    Os_profile_linux_config *[]Azurerm_virtual_machine_scale_set_os_profile_linux_config_244

    Os_profile_secrets *[]Azurerm_virtual_machine_scale_set_os_profile_secrets_246

    Os_profile_windows_config *[]Azurerm_virtual_machine_scale_set_os_profile_windows_config_248

    Overprovision *bool

    Plan *[]Azurerm_virtual_machine_scale_set_plan_251

    Priority *string

    Resource_group_name string

    Rolling_upgrade_policy *[]Azurerm_virtual_machine_scale_set_rolling_upgrade_policy_252

    Single_placement_group *bool

    Sku []Azurerm_virtual_machine_scale_set_sku_253

    Storage_profile_data_disk *[]Azurerm_virtual_machine_scale_set_storage_profile_data_disk_254

    Storage_profile_image_reference *[]Azurerm_virtual_machine_scale_set_storage_profile_image_reference_255

    Storage_profile_os_disk []Azurerm_virtual_machine_scale_set_storage_profile_os_disk_256

    Tags *map[string]string

    Upgrade_policy_mode string

    Zones *[]string

}

var Azurerm_virtual_machine_scale_set_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_machine_scale_set_id",

		"automatic_os_upgrade",

		"boot_diagnostics",

		"eviction_policy",

		"extension",

		"health_probe_id",

		"identity",

		"license_type",

		"os_profile_linux_config",

		"os_profile_secrets",

		"os_profile_windows_config",

		"overprovision",

		"plan",

		"priority",

		"rolling_upgrade_policy",

		"single_placement_group",

		"storage_profile_data_disk",

		"storage_profile_image_reference",

		"tags",

		"zones",

	)
	rtb.ImmutableAttributes(

		"eviction_policy",

		"location",

		"name",

		"priority",

		"resource_group_name",

		"single_placement_group",

		"zones",

	)
}

// Azurerm_virtual_machine_scale_setHandler ...
type Azurerm_virtual_machine_scale_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_machine_scale_setHandler) Create(desired *Azurerm_virtual_machine_scale_set) (*Azurerm_virtual_machine_scale_set, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_machine_scale_set", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_machine_scale_set", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_machine_scale_setHandler) Update(externalID string, desired *Azurerm_virtual_machine_scale_set) (*Azurerm_virtual_machine_scale_set, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_machine_scale_set", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_machine_scale_set", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_scale_set{ Azurerm_virtual_machine_scale_set_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_machine_scale_set", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_machine_scale_setHandler) Read(externalID string) (*Azurerm_virtual_machine_scale_set, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_machine_scale_set", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_machine_scale_set", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_scale_set{ Azurerm_virtual_machine_scale_set_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_machine_scale_set", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_machine_scale_setHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_machine_scale_set", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_machine_scale_set", externalID)
}

type Azurerm_virtual_network_subnet_257 struct {


    Address_prefix string

    Id *string

    Name string

    Security_group *string

}

type Azurerm_virtual_network struct {

	Azurerm_virtual_network_id *string `lyra:"ignore"`

    Address_space []string

    Dns_servers *[]string

    Location string

    Name string

    Resource_group_name string

    Subnet *[]Azurerm_virtual_network_subnet_257

    Tags *map[string]string

}

var Azurerm_virtual_network_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_network_id",

		"dns_servers",

		"subnet",

		"tags",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

	)
}

// Azurerm_virtual_networkHandler ...
type Azurerm_virtual_networkHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_networkHandler) Create(desired *Azurerm_virtual_network) (*Azurerm_virtual_network, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_network", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_network", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_networkHandler) Update(externalID string, desired *Azurerm_virtual_network) (*Azurerm_virtual_network, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_network", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_network", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network{ Azurerm_virtual_network_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_network", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_networkHandler) Read(externalID string) (*Azurerm_virtual_network, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_network", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_network", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network{ Azurerm_virtual_network_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_network", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_networkHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_network", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_network", externalID)
}

type Azurerm_virtual_network_gateway_bgp_settings_258 struct {


    Asn *int

    Peer_weight *int

    Peering_address *string

}

type Azurerm_virtual_network_gateway_ip_configuration_259 struct {


    Name *string

    Private_ip_address_allocation *string

    Public_ip_address_id *string

    Subnet_id string

}

type Azurerm_virtual_network_gateway_vpn_client_configuration_260_revoked_certificate_261 struct {


    Name string

    Thumbprint string

}

type Azurerm_virtual_network_gateway_vpn_client_configuration_260_root_certificate_262 struct {


    Name string

    Public_cert_data string

}

type Azurerm_virtual_network_gateway_vpn_client_configuration_260 struct {


    Address_space []string

    Radius_server_address *string

    Radius_server_secret *string

    Revoked_certificate *[]Azurerm_virtual_network_gateway_vpn_client_configuration_260_revoked_certificate_261

    Root_certificate *[]Azurerm_virtual_network_gateway_vpn_client_configuration_260_root_certificate_262

    Vpn_client_protocols *[]string

}

type Azurerm_virtual_network_gateway struct {

	Azurerm_virtual_network_gateway_id *string `lyra:"ignore"`

    Active_active *bool

    Bgp_settings *[]Azurerm_virtual_network_gateway_bgp_settings_258

    Default_local_network_gateway_id *string

    Enable_bgp *bool

    Ip_configuration []Azurerm_virtual_network_gateway_ip_configuration_259

    Location string

    Name string

    Resource_group_name string

    Sku string

    Tags *map[string]string

    Type string

    Vpn_client_configuration *[]Azurerm_virtual_network_gateway_vpn_client_configuration_260

    Vpn_type *string

}

var Azurerm_virtual_network_gateway_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_network_gateway_id",

		"active_active",

		"bgp_settings",

		"default_local_network_gateway_id",

		"enable_bgp",

		"tags",

		"vpn_client_configuration",

		"vpn_type",

	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"type",

		"vpn_type",

	)
}

// Azurerm_virtual_network_gatewayHandler ...
type Azurerm_virtual_network_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_network_gatewayHandler) Create(desired *Azurerm_virtual_network_gateway) (*Azurerm_virtual_network_gateway, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_network_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_network_gateway", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_network_gatewayHandler) Update(externalID string, desired *Azurerm_virtual_network_gateway) (*Azurerm_virtual_network_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_network_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_network_gateway", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_gateway{ Azurerm_virtual_network_gateway_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_network_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_network_gatewayHandler) Read(externalID string) (*Azurerm_virtual_network_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_network_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_network_gateway", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_gateway{ Azurerm_virtual_network_gateway_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_network_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_network_gatewayHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_network_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_network_gateway", externalID)
}

type Azurerm_virtual_network_gateway_connection_ipsec_policy_263 struct {


    Dh_group string

    Ike_encryption string

    Ike_integrity string

    Ipsec_encryption string

    Ipsec_integrity string

    Pfs_group string

    Sa_datasize *int

    Sa_lifetime *int

}

type Azurerm_virtual_network_gateway_connection struct {

	Azurerm_virtual_network_gateway_connection_id *string `lyra:"ignore"`

    Authorization_key *string

    Enable_bgp *bool

    Express_route_circuit_id *string

    Ipsec_policy *[]Azurerm_virtual_network_gateway_connection_ipsec_policy_263

    Local_network_gateway_id *string

    Location string

    Name string

    Peer_virtual_network_gateway_id *string

    Resource_group_name string

    Routing_weight *int

    Shared_key *string

    Tags *map[string]string

    Type string

    Use_policy_based_traffic_selectors *bool

    Virtual_network_gateway_id string

}

var Azurerm_virtual_network_gateway_connection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_network_gateway_connection_id",

		"authorization_key",

		"enable_bgp",

		"express_route_circuit_id",

		"ipsec_policy",

		"local_network_gateway_id",

		"peer_virtual_network_gateway_id",

		"routing_weight",

		"shared_key",

		"tags",

		"use_policy_based_traffic_selectors",

	)
	rtb.ImmutableAttributes(

		"express_route_circuit_id",

		"location",

		"name",

		"peer_virtual_network_gateway_id",

		"resource_group_name",

		"type",

		"virtual_network_gateway_id",

	)
}

// Azurerm_virtual_network_gateway_connectionHandler ...
type Azurerm_virtual_network_gateway_connectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_network_gateway_connectionHandler) Create(desired *Azurerm_virtual_network_gateway_connection) (*Azurerm_virtual_network_gateway_connection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_network_gateway_connection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_network_gateway_connection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_network_gateway_connectionHandler) Update(externalID string, desired *Azurerm_virtual_network_gateway_connection) (*Azurerm_virtual_network_gateway_connection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_network_gateway_connection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_network_gateway_connection", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_gateway_connection{ Azurerm_virtual_network_gateway_connection_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_network_gateway_connection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_network_gateway_connectionHandler) Read(externalID string) (*Azurerm_virtual_network_gateway_connection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_network_gateway_connection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_network_gateway_connection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_gateway_connection{ Azurerm_virtual_network_gateway_connection_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_network_gateway_connection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_network_gateway_connectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_network_gateway_connection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_network_gateway_connection", externalID)
}

type Azurerm_virtual_network_peering struct {

	Azurerm_virtual_network_peering_id *string `lyra:"ignore"`

    Allow_forwarded_traffic *bool

    Allow_gateway_transit *bool

    Allow_virtual_network_access *bool

    Name string

    Remote_virtual_network_id string

    Resource_group_name string

    Use_remote_gateways *bool

    Virtual_network_name string

}

var Azurerm_virtual_network_peering_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_network_peering_id",

		"allow_forwarded_traffic",

		"allow_gateway_transit",

		"allow_virtual_network_access",

		"use_remote_gateways",

	)
	rtb.ImmutableAttributes(

		"name",

		"remote_virtual_network_id",

		"resource_group_name",

		"virtual_network_name",

	)
}

// Azurerm_virtual_network_peeringHandler ...
type Azurerm_virtual_network_peeringHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_network_peeringHandler) Create(desired *Azurerm_virtual_network_peering) (*Azurerm_virtual_network_peering, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_network_peering", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_network_peering", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_network_peeringHandler) Update(externalID string, desired *Azurerm_virtual_network_peering) (*Azurerm_virtual_network_peering, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_network_peering", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_network_peering", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_peering{ Azurerm_virtual_network_peering_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_network_peering", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_network_peeringHandler) Read(externalID string) (*Azurerm_virtual_network_peering, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_network_peering", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_network_peering", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_peering{ Azurerm_virtual_network_peering_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_network_peering", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_network_peeringHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_network_peering", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_network_peering", externalID)
}
