// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package generated

import (
	"sync"

	"github.com/davecgh/go-spew/spew"
	"github.com/hashicorp/go-hclog"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/terraform"
	"github.com/lyraproj/lyra/pkg/bridge"
	"github.com/lyraproj/puppet-evaluator/eval"
	"github.com/lyraproj/servicesdk/service"
)

var once sync.Once
var Config *terraform.ResourceConfig

func configureProvider(p *schema.Provider) {
	once.Do(func() {
		if Config == nil {
			Config = &terraform.ResourceConfig{
				Config: map[string]interface{}{},
			}
		}
		err := p.Configure(Config)
		if err != nil {
			panic(err)
		}
	})
}

func Initialize(sb *service.ServerBuilder, p *schema.Provider) {
    var evs []eval.Type
    evs = sb.RegisterTypes("TerraformGitHub", Github_branch_protection{})
    sb.RegisterHandler("TerraformGitHub::Github_branch_protectionHandler", &Github_branch_protectionHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_issue_label{})
    sb.RegisterHandler("TerraformGitHub::Github_issue_labelHandler", &Github_issue_labelHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_membership{})
    sb.RegisterHandler("TerraformGitHub::Github_membershipHandler", &Github_membershipHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_organization_project{})
    sb.RegisterHandler("TerraformGitHub::Github_organization_projectHandler", &Github_organization_projectHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_organization_webhook{})
    sb.RegisterHandler("TerraformGitHub::Github_organization_webhookHandler", &Github_organization_webhookHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_project_column{})
    sb.RegisterHandler("TerraformGitHub::Github_project_columnHandler", &Github_project_columnHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_repository{})
    sb.RegisterHandler("TerraformGitHub::Github_repositoryHandler", &Github_repositoryHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_repository_collaborator{})
    sb.RegisterHandler("TerraformGitHub::Github_repository_collaboratorHandler", &Github_repository_collaboratorHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_repository_deploy_key{})
    sb.RegisterHandler("TerraformGitHub::Github_repository_deploy_keyHandler", &Github_repository_deploy_keyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_repository_project{})
    sb.RegisterHandler("TerraformGitHub::Github_repository_projectHandler", &Github_repository_projectHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_repository_webhook{})
    sb.RegisterHandler("TerraformGitHub::Github_repository_webhookHandler", &Github_repository_webhookHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_team{})
    sb.RegisterHandler("TerraformGitHub::Github_teamHandler", &Github_teamHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_team_membership{})
    sb.RegisterHandler("TerraformGitHub::Github_team_membershipHandler", &Github_team_membershipHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_team_repository{})
    sb.RegisterHandler("TerraformGitHub::Github_team_repositoryHandler", &Github_team_repositoryHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_user_gpg_key{})
    sb.RegisterHandler("TerraformGitHub::Github_user_gpg_keyHandler", &Github_user_gpg_keyHandler{provider: p}, evs[0])
    evs = sb.RegisterTypes("TerraformGitHub", Github_user_ssh_key{})
    sb.RegisterHandler("TerraformGitHub::Github_user_ssh_keyHandler", &Github_user_ssh_keyHandler{provider: p}, evs[0])
}


type Github_branch_protection_required_pull_request_reviews_852 struct {

    Dismiss_stale_reviews *bool

    Dismissal_teams *[]string

    Dismissal_users *[]string

    Include_admins *bool

    Require_code_owner_reviews *bool

}

type Github_branch_protection_required_status_checks_853 struct {

    Contexts *[]string

    Include_admins *bool

    Strict *bool

}

type Github_branch_protection_restrictions_854 struct {

    Teams *[]string

    Users *[]string

}

type Github_branch_protection struct {

    Github_branch_protection_id *string `lyra:"ignore"`

    Branch string

    Enforce_admins *bool

    Etag *string

    Repository string

    Required_pull_request_reviews *[]Github_branch_protection_required_pull_request_reviews_852

    Required_status_checks *[]Github_branch_protection_required_status_checks_853

    Restrictions *[]Github_branch_protection_restrictions_854

}

// Github_branch_protectionHandler ...
type Github_branch_protectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_branch_protectionHandler) Create(desired *Github_branch_protection) (*Github_branch_protection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_branch_protection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_branch_protectionHandler) Read(externalID string) (*Github_branch_protection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_branch_protection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_branch_protection{ Github_branch_protection_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_branch_protectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_branch_protection", externalID)
}

type Github_issue_label struct {

    Github_issue_label_id *string `lyra:"ignore"`

    Color string

    Description *string

    Etag *string

    Name string

    Repository string

    Url *string

}

// Github_issue_labelHandler ...
type Github_issue_labelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_issue_labelHandler) Create(desired *Github_issue_label) (*Github_issue_label, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_issue_label", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_issue_labelHandler) Read(externalID string) (*Github_issue_label, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_issue_label", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_issue_label{ Github_issue_label_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_issue_labelHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_issue_label", externalID)
}

type Github_membership struct {

    Github_membership_id *string `lyra:"ignore"`

    Etag *string

    Role *string

    Username string

}

// Github_membershipHandler ...
type Github_membershipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_membershipHandler) Create(desired *Github_membership) (*Github_membership, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_membership", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_membershipHandler) Read(externalID string) (*Github_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_membership", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_membership{ Github_membership_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_membershipHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_membership", externalID)
}

type Github_organization_project struct {

    Github_organization_project_id *string `lyra:"ignore"`

    Body *string

    Etag *string

    Name string

    Url *string

}

// Github_organization_projectHandler ...
type Github_organization_projectHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_organization_projectHandler) Create(desired *Github_organization_project) (*Github_organization_project, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_organization_project", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_organization_projectHandler) Read(externalID string) (*Github_organization_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_organization_project", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_project{ Github_organization_project_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_organization_projectHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_organization_project", externalID)
}

type Github_organization_webhook_configuration_855 struct {

    Content_type *string

    Insecure_ssl *string

    Secret *string

    Url string

}

type Github_organization_webhook struct {

    Github_organization_webhook_id *string `lyra:"ignore"`

    Active *bool

    Configuration *[]Github_organization_webhook_configuration_855

    Etag *string

    Events []string

    Name string

    Url *string

}

// Github_organization_webhookHandler ...
type Github_organization_webhookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_organization_webhookHandler) Create(desired *Github_organization_webhook) (*Github_organization_webhook, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_organization_webhook", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_organization_webhookHandler) Read(externalID string) (*Github_organization_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_organization_webhook", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_webhook{ Github_organization_webhook_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_organization_webhookHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_organization_webhook", externalID)
}

type Github_project_column struct {

    Github_project_column_id *string `lyra:"ignore"`

    Etag *string

    Name string

    Project_id string

}

// Github_project_columnHandler ...
type Github_project_columnHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_project_columnHandler) Create(desired *Github_project_column) (*Github_project_column, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_project_column", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_project_columnHandler) Read(externalID string) (*Github_project_column, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_project_column", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_project_column{ Github_project_column_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_project_columnHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_project_column", externalID)
}

type Github_repository struct {

    Github_repository_id *string `lyra:"ignore"`

    Allow_merge_commit *bool

    Allow_rebase_merge *bool

    Allow_squash_merge *bool

    Archived *bool

    Auto_init *bool

    Default_branch *string

    Description *string

    Etag *string

    Full_name *string

    Git_clone_url *string

    Gitignore_template *string

    Has_downloads *bool

    Has_issues *bool

    Has_projects *bool

    Has_wiki *bool

    Homepage_url *string

    Html_url *string

    Http_clone_url *string

    License_template *string

    Name string

    Private *bool

    Ssh_clone_url *string

    Svn_url *string

    Topics *[]string

}

// Github_repositoryHandler ...
type Github_repositoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repositoryHandler) Create(desired *Github_repository) (*Github_repository, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_repositoryHandler) Read(externalID string) (*Github_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository{ Github_repository_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repositoryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository", externalID)
}

type Github_repository_collaborator struct {

    Github_repository_collaborator_id *string `lyra:"ignore"`

    Permission *string

    Repository string

    Username string

}

// Github_repository_collaboratorHandler ...
type Github_repository_collaboratorHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_collaboratorHandler) Create(desired *Github_repository_collaborator) (*Github_repository_collaborator, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_collaborator", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_repository_collaboratorHandler) Read(externalID string) (*Github_repository_collaborator, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_collaborator", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_collaborator{ Github_repository_collaborator_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_collaboratorHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_collaborator", externalID)
}

type Github_repository_deploy_key struct {

    Github_repository_deploy_key_id *string `lyra:"ignore"`

    Etag *string

    Key string

    Read_only *bool

    Repository string

    Title string

}

// Github_repository_deploy_keyHandler ...
type Github_repository_deploy_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_deploy_keyHandler) Create(desired *Github_repository_deploy_key) (*Github_repository_deploy_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_deploy_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_repository_deploy_keyHandler) Read(externalID string) (*Github_repository_deploy_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_deploy_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_deploy_key{ Github_repository_deploy_key_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_deploy_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_deploy_key", externalID)
}

type Github_repository_project struct {

    Github_repository_project_id *string `lyra:"ignore"`

    Body *string

    Etag *string

    Name string

    Repository string

    Url *string

}

// Github_repository_projectHandler ...
type Github_repository_projectHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_projectHandler) Create(desired *Github_repository_project) (*Github_repository_project, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_project", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_repository_projectHandler) Read(externalID string) (*Github_repository_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_project", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_project{ Github_repository_project_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_projectHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_project", externalID)
}

type Github_repository_webhook_configuration_856 struct {

    Content_type *string

    Insecure_ssl *string

    Secret *string

    Url string

}

type Github_repository_webhook struct {

    Github_repository_webhook_id *string `lyra:"ignore"`

    Active *bool

    Configuration *[]Github_repository_webhook_configuration_856

    Etag *string

    Events []string

    Name string

    Repository string

    Url *string

}

// Github_repository_webhookHandler ...
type Github_repository_webhookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_webhookHandler) Create(desired *Github_repository_webhook) (*Github_repository_webhook, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_webhook", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_repository_webhookHandler) Read(externalID string) (*Github_repository_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_webhook", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_webhook{ Github_repository_webhook_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_webhookHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_webhook", externalID)
}

type Github_team struct {

    Github_team_id *string `lyra:"ignore"`

    Description *string

    Etag *string

    Ldap_dn *string

    Name string

    Parent_team_id *int

    Privacy *string

    Slug *string

}

// Github_teamHandler ...
type Github_teamHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_teamHandler) Create(desired *Github_team) (*Github_team, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_team", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_teamHandler) Read(externalID string) (*Github_team, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_team", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_team{ Github_team_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_teamHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_team", externalID)
}

type Github_team_membership struct {

    Github_team_membership_id *string `lyra:"ignore"`

    Etag *string

    Role *string

    Team_id string

    Username string

}

// Github_team_membershipHandler ...
type Github_team_membershipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_team_membershipHandler) Create(desired *Github_team_membership) (*Github_team_membership, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_team_membership", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_team_membershipHandler) Read(externalID string) (*Github_team_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_team_membership", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_team_membership{ Github_team_membership_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_team_membershipHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_team_membership", externalID)
}

type Github_team_repository struct {

    Github_team_repository_id *string `lyra:"ignore"`

    Etag *string

    Permission *string

    Repository string

    Team_id string

}

// Github_team_repositoryHandler ...
type Github_team_repositoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_team_repositoryHandler) Create(desired *Github_team_repository) (*Github_team_repository, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_team_repository", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_team_repositoryHandler) Read(externalID string) (*Github_team_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_team_repository", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_team_repository{ Github_team_repository_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_team_repositoryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_team_repository", externalID)
}

type Github_user_gpg_key struct {

    Github_user_gpg_key_id *string `lyra:"ignore"`

    Armored_public_key string

    Etag *string

    Key_id *string

}

// Github_user_gpg_keyHandler ...
type Github_user_gpg_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_user_gpg_keyHandler) Create(desired *Github_user_gpg_key) (*Github_user_gpg_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_user_gpg_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_user_gpg_keyHandler) Read(externalID string) (*Github_user_gpg_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_user_gpg_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_user_gpg_key{ Github_user_gpg_key_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_user_gpg_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_user_gpg_key", externalID)
}

type Github_user_ssh_key struct {

    Github_user_ssh_key_id *string `lyra:"ignore"`

    Etag *string

    Key string

    Title string

    Url *string

}

// Github_user_ssh_keyHandler ...
type Github_user_ssh_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_user_ssh_keyHandler) Create(desired *Github_user_ssh_key) (*Github_user_ssh_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create {.TFType}}", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_user_ssh_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *Github_user_ssh_keyHandler) Read(externalID string) (*Github_user_ssh_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_user_ssh_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_user_ssh_key{ Github_user_ssh_key_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read {.TFType}}", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_user_ssh_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete {.TFType}}", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_user_ssh_key", externalID)
}
