// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package generated

import (
	"sync"

	"github.com/davecgh/go-spew/spew"
	"github.com/hashicorp/go-hclog"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/terraform"
	"github.com/lyraproj/lyra/pkg/bridge"
	"github.com/lyraproj/puppet-evaluator/eval"
	"github.com/lyraproj/servicesdk/service"
)

var once sync.Once
var Config *terraform.ResourceConfig

func configureProvider(p *schema.Provider) {
	once.Do(func() {
		if Config == nil {
			Config = &terraform.ResourceConfig{
				Config: map[string]interface{}{},
			}
		}
		err := p.Configure(Config)
		if err != nil {
			panic(err)
		}
	})
}

func Initialize(sb *service.ServerBuilder, p *schema.Provider) {
	var evs []eval.Type

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_branch_protection{}, Github_branch_protection_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_branch_protectionHandler", &Github_branch_protectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_issue_label{}, Github_issue_label_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_issue_labelHandler", &Github_issue_labelHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_membership{}, Github_membership_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_membershipHandler", &Github_membershipHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_organization_project{}, Github_organization_project_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_organization_projectHandler", &Github_organization_projectHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_organization_webhook{}, Github_organization_webhook_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_organization_webhookHandler", &Github_organization_webhookHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_project_column{}, Github_project_column_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_project_columnHandler", &Github_project_columnHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository{}, Github_repository_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repositoryHandler", &Github_repositoryHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository_collaborator{}, Github_repository_collaborator_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repository_collaboratorHandler", &Github_repository_collaboratorHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository_deploy_key{}, Github_repository_deploy_key_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repository_deploy_keyHandler", &Github_repository_deploy_keyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository_project{}, Github_repository_project_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repository_projectHandler", &Github_repository_projectHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository_webhook{}, Github_repository_webhook_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repository_webhookHandler", &Github_repository_webhookHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_team{}, Github_team_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_teamHandler", &Github_teamHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_team_membership{}, Github_team_membership_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_team_membershipHandler", &Github_team_membershipHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_team_repository{}, Github_team_repository_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_team_repositoryHandler", &Github_team_repositoryHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_user_gpg_key{}, Github_user_gpg_key_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_user_gpg_keyHandler", &Github_user_gpg_keyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_user_ssh_key{}, Github_user_ssh_key_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_user_ssh_keyHandler", &Github_user_ssh_keyHandler{provider: p}, evs[0])

}

type Github_branch_protection_required_pull_request_reviews_1 struct {


    Dismiss_stale_reviews *bool

    Dismissal_teams *[]string

    Dismissal_users *[]string

    Include_admins *bool

    Require_code_owner_reviews *bool

}

type Github_branch_protection_required_status_checks_2 struct {


    Contexts *[]string

    Include_admins *bool

    Strict *bool

}

type Github_branch_protection_restrictions_3 struct {


    Teams *[]string

    Users *[]string

}

type Github_branch_protection struct {

	Github_branch_protection_id *string `lyra:"ignore"`

    Branch string

    Enforce_admins *bool

    Etag *string

    Repository string

    Required_pull_request_reviews *[]Github_branch_protection_required_pull_request_reviews_1

    Required_status_checks *[]Github_branch_protection_required_status_checks_2

    Restrictions *[]Github_branch_protection_restrictions_3

}

var Github_branch_protection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_branch_protection_id",

		"enforce_admins",

		"etag",

		"required_pull_request_reviews",

		"required_status_checks",

		"restrictions",

	)
	rtb.ImmutableAttributes(

		"branch",

		"repository",

	)
}

// Github_branch_protectionHandler ...
type Github_branch_protectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_branch_protectionHandler) Create(desired *Github_branch_protection) (*Github_branch_protection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_branch_protection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_branch_protection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_branch_protectionHandler) Update(externalID string, desired *Github_branch_protection) (*Github_branch_protection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_branch_protection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_branch_protection", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_branch_protection{ Github_branch_protection_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_branch_protection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_branch_protectionHandler) Read(externalID string) (*Github_branch_protection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_branch_protection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_branch_protection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_branch_protection{ Github_branch_protection_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_branch_protection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_branch_protectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_branch_protection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_branch_protection", externalID)
}

type Github_issue_label struct {

	Github_issue_label_id *string `lyra:"ignore"`

    Color string

    Description *string

    Etag *string

    Name string

    Repository string

    Url *string

}

var Github_issue_label_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_issue_label_id",

		"description",

		"etag",

		"url",

	)
	rtb.ImmutableAttributes(

		"repository",

	)
}

// Github_issue_labelHandler ...
type Github_issue_labelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_issue_labelHandler) Create(desired *Github_issue_label) (*Github_issue_label, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_issue_label", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_issue_label", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_issue_labelHandler) Update(externalID string, desired *Github_issue_label) (*Github_issue_label, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_issue_label", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_issue_label", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_issue_label{ Github_issue_label_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_issue_label", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_issue_labelHandler) Read(externalID string) (*Github_issue_label, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_issue_label", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_issue_label", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_issue_label{ Github_issue_label_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_issue_label", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_issue_labelHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_issue_label", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_issue_label", externalID)
}

type Github_membership struct {

	Github_membership_id *string `lyra:"ignore"`

    Etag *string

    Role *string

    Username string

}

var Github_membership_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_membership_id",

		"etag",

		"role",

	)
	rtb.ImmutableAttributes(

		"username",

	)
}

// Github_membershipHandler ...
type Github_membershipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_membershipHandler) Create(desired *Github_membership) (*Github_membership, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_membership", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_membership", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_membershipHandler) Update(externalID string, desired *Github_membership) (*Github_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_membership", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_membership", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_membership{ Github_membership_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_membership", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_membershipHandler) Read(externalID string) (*Github_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_membership", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_membership", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_membership{ Github_membership_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_membership", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_membershipHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_membership", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_membership", externalID)
}

type Github_organization_project struct {

	Github_organization_project_id *string `lyra:"ignore"`

    Body *string

    Etag *string

    Name string

    Url *string

}

var Github_organization_project_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_organization_project_id",

		"body",

		"etag",

		"url",

	)
	rtb.ImmutableAttributes(

	)
}

// Github_organization_projectHandler ...
type Github_organization_projectHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_organization_projectHandler) Create(desired *Github_organization_project) (*Github_organization_project, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_organization_project", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_organization_project", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_organization_projectHandler) Update(externalID string, desired *Github_organization_project) (*Github_organization_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_organization_project", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_organization_project", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_project{ Github_organization_project_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_organization_project", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_organization_projectHandler) Read(externalID string) (*Github_organization_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_organization_project", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_organization_project", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_project{ Github_organization_project_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_organization_project", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_organization_projectHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_organization_project", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_organization_project", externalID)
}

type Github_organization_webhook_configuration_4 struct {


    Content_type *string

    Insecure_ssl *string

    Secret *string

    Url string

}

type Github_organization_webhook struct {

	Github_organization_webhook_id *string `lyra:"ignore"`

    Active *bool

    Configuration *[]Github_organization_webhook_configuration_4

    Etag *string

    Events []string

    Name string

    Url *string

}

var Github_organization_webhook_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_organization_webhook_id",

		"active",

		"configuration",

		"etag",

		"url",

	)
	rtb.ImmutableAttributes(

		"name",

	)
}

// Github_organization_webhookHandler ...
type Github_organization_webhookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_organization_webhookHandler) Create(desired *Github_organization_webhook) (*Github_organization_webhook, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_organization_webhook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_organization_webhook", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_organization_webhookHandler) Update(externalID string, desired *Github_organization_webhook) (*Github_organization_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_organization_webhook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_organization_webhook", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_webhook{ Github_organization_webhook_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_organization_webhook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_organization_webhookHandler) Read(externalID string) (*Github_organization_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_organization_webhook", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_organization_webhook", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_webhook{ Github_organization_webhook_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_organization_webhook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_organization_webhookHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_organization_webhook", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_organization_webhook", externalID)
}

type Github_project_column struct {

	Github_project_column_id *string `lyra:"ignore"`

    Etag *string

    Name string

    Project_id string

}

var Github_project_column_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_project_column_id",

		"etag",

	)
	rtb.ImmutableAttributes(

		"project_id",

	)
}

// Github_project_columnHandler ...
type Github_project_columnHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_project_columnHandler) Create(desired *Github_project_column) (*Github_project_column, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_project_column", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_project_column", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_project_columnHandler) Update(externalID string, desired *Github_project_column) (*Github_project_column, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_project_column", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_project_column", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_project_column{ Github_project_column_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_project_column", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_project_columnHandler) Read(externalID string) (*Github_project_column, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_project_column", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_project_column", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_project_column{ Github_project_column_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_project_column", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_project_columnHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_project_column", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_project_column", externalID)
}

type Github_repository struct {

	Github_repository_id *string `lyra:"ignore"`

    Allow_merge_commit *bool

    Allow_rebase_merge *bool

    Allow_squash_merge *bool

    Archived *bool

    Auto_init *bool

    Default_branch *string

    Description *string

    Etag *string

    Full_name *string

    Git_clone_url *string

    Gitignore_template *string

    Has_downloads *bool

    Has_issues *bool

    Has_projects *bool

    Has_wiki *bool

    Homepage_url *string

    Html_url *string

    Http_clone_url *string

    License_template *string

    Name string

    Private *bool

    Ssh_clone_url *string

    Svn_url *string

    Topics *[]string

}

var Github_repository_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_id",

		"allow_merge_commit",

		"allow_rebase_merge",

		"allow_squash_merge",

		"archived",

		"auto_init",

		"default_branch",

		"description",

		"etag",

		"full_name",

		"git_clone_url",

		"gitignore_template",

		"has_downloads",

		"has_issues",

		"has_projects",

		"has_wiki",

		"homepage_url",

		"html_url",

		"http_clone_url",

		"license_template",

		"private",

		"ssh_clone_url",

		"svn_url",

		"topics",

	)
	rtb.ImmutableAttributes(

		"auto_init",

		"gitignore_template",

		"license_template",

		"name",

	)
}

// Github_repositoryHandler ...
type Github_repositoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repositoryHandler) Create(desired *Github_repository) (*Github_repository, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repositoryHandler) Update(externalID string, desired *Github_repository) (*Github_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository{ Github_repository_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repositoryHandler) Read(externalID string) (*Github_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository{ Github_repository_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repositoryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository", externalID)
}

type Github_repository_collaborator struct {

	Github_repository_collaborator_id *string `lyra:"ignore"`

    Permission *string

    Repository string

    Username string

}

var Github_repository_collaborator_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_collaborator_id",

		"permission",

	)
	rtb.ImmutableAttributes(

		"permission",

		"repository",

		"username",

	)
}

// Github_repository_collaboratorHandler ...
type Github_repository_collaboratorHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_collaboratorHandler) Create(desired *Github_repository_collaborator) (*Github_repository_collaborator, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository_collaborator", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_collaborator", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repository_collaboratorHandler) Update(externalID string, desired *Github_repository_collaborator) (*Github_repository_collaborator, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository_collaborator", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository_collaborator", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_collaborator{ Github_repository_collaborator_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository_collaborator", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repository_collaboratorHandler) Read(externalID string) (*Github_repository_collaborator, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository_collaborator", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_collaborator", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_collaborator{ Github_repository_collaborator_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository_collaborator", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_collaboratorHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository_collaborator", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_collaborator", externalID)
}

type Github_repository_deploy_key struct {

	Github_repository_deploy_key_id *string `lyra:"ignore"`

    Etag *string

    Key string

    Read_only *bool

    Repository string

    Title string

}

var Github_repository_deploy_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_deploy_key_id",

		"etag",

		"read_only",

	)
	rtb.ImmutableAttributes(

		"key",

		"read_only",

		"repository",

		"title",

	)
}

// Github_repository_deploy_keyHandler ...
type Github_repository_deploy_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_deploy_keyHandler) Create(desired *Github_repository_deploy_key) (*Github_repository_deploy_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository_deploy_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_deploy_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repository_deploy_keyHandler) Update(externalID string, desired *Github_repository_deploy_key) (*Github_repository_deploy_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository_deploy_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository_deploy_key", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_deploy_key{ Github_repository_deploy_key_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository_deploy_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repository_deploy_keyHandler) Read(externalID string) (*Github_repository_deploy_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository_deploy_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_deploy_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_deploy_key{ Github_repository_deploy_key_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository_deploy_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_deploy_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository_deploy_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_deploy_key", externalID)
}

type Github_repository_project struct {

	Github_repository_project_id *string `lyra:"ignore"`

    Body *string

    Etag *string

    Name string

    Repository string

    Url *string

}

var Github_repository_project_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_project_id",

		"body",

		"etag",

		"url",

	)
	rtb.ImmutableAttributes(

		"repository",

	)
}

// Github_repository_projectHandler ...
type Github_repository_projectHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_projectHandler) Create(desired *Github_repository_project) (*Github_repository_project, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository_project", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_project", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repository_projectHandler) Update(externalID string, desired *Github_repository_project) (*Github_repository_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository_project", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository_project", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_project{ Github_repository_project_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository_project", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repository_projectHandler) Read(externalID string) (*Github_repository_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository_project", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_project", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_project{ Github_repository_project_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository_project", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_projectHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository_project", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_project", externalID)
}

type Github_repository_webhook_configuration_5 struct {


    Content_type *string

    Insecure_ssl *string

    Secret *string

    Url string

}

type Github_repository_webhook struct {

	Github_repository_webhook_id *string `lyra:"ignore"`

    Active *bool

    Configuration *[]Github_repository_webhook_configuration_5

    Etag *string

    Events []string

    Name string

    Repository string

    Url *string

}

var Github_repository_webhook_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_webhook_id",

		"active",

		"configuration",

		"etag",

		"url",

	)
	rtb.ImmutableAttributes(

		"name",

		"repository",

	)
}

// Github_repository_webhookHandler ...
type Github_repository_webhookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_webhookHandler) Create(desired *Github_repository_webhook) (*Github_repository_webhook, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository_webhook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_webhook", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repository_webhookHandler) Update(externalID string, desired *Github_repository_webhook) (*Github_repository_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository_webhook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository_webhook", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_webhook{ Github_repository_webhook_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository_webhook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repository_webhookHandler) Read(externalID string) (*Github_repository_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository_webhook", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_webhook", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_webhook{ Github_repository_webhook_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository_webhook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_webhookHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository_webhook", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_webhook", externalID)
}

type Github_team struct {

	Github_team_id *string `lyra:"ignore"`

    Description *string

    Etag *string

    Ldap_dn *string

    Name string

    Parent_team_id *int

    Privacy *string

    Slug *string

}

var Github_team_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_team_id",

		"description",

		"etag",

		"ldap_dn",

		"parent_team_id",

		"privacy",

		"slug",

	)
	rtb.ImmutableAttributes(

	)
}

// Github_teamHandler ...
type Github_teamHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_teamHandler) Create(desired *Github_team) (*Github_team, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_team", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_team", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_teamHandler) Update(externalID string, desired *Github_team) (*Github_team, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_team", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_team", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_team{ Github_team_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_team", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_teamHandler) Read(externalID string) (*Github_team, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_team", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_team", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_team{ Github_team_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_team", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_teamHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_team", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_team", externalID)
}

type Github_team_membership struct {

	Github_team_membership_id *string `lyra:"ignore"`

    Etag *string

    Role *string

    Team_id string

    Username string

}

var Github_team_membership_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_team_membership_id",

		"etag",

		"role",

	)
	rtb.ImmutableAttributes(

		"team_id",

		"username",

	)
}

// Github_team_membershipHandler ...
type Github_team_membershipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_team_membershipHandler) Create(desired *Github_team_membership) (*Github_team_membership, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_team_membership", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_team_membership", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_team_membershipHandler) Update(externalID string, desired *Github_team_membership) (*Github_team_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_team_membership", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_team_membership", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_team_membership{ Github_team_membership_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_team_membership", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_team_membershipHandler) Read(externalID string) (*Github_team_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_team_membership", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_team_membership", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_team_membership{ Github_team_membership_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_team_membership", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_team_membershipHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_team_membership", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_team_membership", externalID)
}

type Github_team_repository struct {

	Github_team_repository_id *string `lyra:"ignore"`

    Etag *string

    Permission *string

    Repository string

    Team_id string

}

var Github_team_repository_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_team_repository_id",

		"etag",

		"permission",

	)
	rtb.ImmutableAttributes(

		"repository",

		"team_id",

	)
}

// Github_team_repositoryHandler ...
type Github_team_repositoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_team_repositoryHandler) Create(desired *Github_team_repository) (*Github_team_repository, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_team_repository", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_team_repository", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_team_repositoryHandler) Update(externalID string, desired *Github_team_repository) (*Github_team_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_team_repository", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_team_repository", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_team_repository{ Github_team_repository_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_team_repository", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_team_repositoryHandler) Read(externalID string) (*Github_team_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_team_repository", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_team_repository", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_team_repository{ Github_team_repository_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_team_repository", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_team_repositoryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_team_repository", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_team_repository", externalID)
}

type Github_user_gpg_key struct {

	Github_user_gpg_key_id *string `lyra:"ignore"`

    Armored_public_key string

    Etag *string

    Key_id *string

}

var Github_user_gpg_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_user_gpg_key_id",

		"etag",

		"key_id",

	)
	rtb.ImmutableAttributes(

		"armored_public_key",

	)
}

// Github_user_gpg_keyHandler ...
type Github_user_gpg_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_user_gpg_keyHandler) Create(desired *Github_user_gpg_key) (*Github_user_gpg_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_user_gpg_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_user_gpg_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_user_gpg_keyHandler) Update(externalID string, desired *Github_user_gpg_key) (*Github_user_gpg_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_user_gpg_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_user_gpg_key", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_user_gpg_key{ Github_user_gpg_key_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_user_gpg_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_user_gpg_keyHandler) Read(externalID string) (*Github_user_gpg_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_user_gpg_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_user_gpg_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_user_gpg_key{ Github_user_gpg_key_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_user_gpg_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_user_gpg_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_user_gpg_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_user_gpg_key", externalID)
}

type Github_user_ssh_key struct {

	Github_user_ssh_key_id *string `lyra:"ignore"`

    Etag *string

    Key string

    Title string

    Url *string

}

var Github_user_ssh_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_user_ssh_key_id",

		"etag",

		"url",

	)
	rtb.ImmutableAttributes(

		"key",

		"title",

	)
}

// Github_user_ssh_keyHandler ...
type Github_user_ssh_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_user_ssh_keyHandler) Create(desired *Github_user_ssh_key) (*Github_user_ssh_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_user_ssh_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_user_ssh_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_user_ssh_keyHandler) Update(externalID string, desired *Github_user_ssh_key) (*Github_user_ssh_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_user_ssh_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_user_ssh_key", externalID,  rc)
	if err != nil {
		return nil, err
	}
	x := &Github_user_ssh_key{ Github_user_ssh_key_id: &externalID }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_user_ssh_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_user_ssh_keyHandler) Read(externalID string) (*Github_user_ssh_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_user_ssh_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_user_ssh_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_user_ssh_key{ Github_user_ssh_key_id: &id }
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_user_ssh_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_user_ssh_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_user_ssh_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_user_ssh_key", externalID)
}
